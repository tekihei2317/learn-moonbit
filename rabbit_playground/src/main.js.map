{"version":3,"sources":["/Users/tekihei2317/.moon/lib/core/builtin/int64_js.mbt","/Users/tekihei2317/.moon/lib/core/builtin/hasher.mbt","/Users/tekihei2317/.moon/lib/core/abort/abort.mbt","/Users/tekihei2317/.moon/lib/core/builtin/intrinsics.mbt","/Users/tekihei2317/.moon/lib/core/builtin/fixedarray_block.mbt","/Users/tekihei2317/.moon/lib/core/builtin/uninitialized_array.mbt","/Users/tekihei2317/.moon/lib/core/builtin/stringbuilder_concat.mbt","/Users/tekihei2317/.moon/lib/core/builtin/uint16_char.mbt","/Users/tekihei2317/.moon/lib/core/builtin/string.mbt","/Users/tekihei2317/.moon/lib/core/builtin/deprecated.mbt","/Users/tekihei2317/.moon/lib/core/builtin/autoloc.mbt","/Users/tekihei2317/.moon/lib/core/builtin/traits.mbt","/Users/tekihei2317/.moon/lib/core/builtin/stringview.mbt","/Users/tekihei2317/.moon/lib/core/builtin/iterator.mbt","/Users/tekihei2317/.moon/lib/core/builtin/to_string.mbt","/Users/tekihei2317/.moon/lib/core/builtin/failure.mbt","/Users/tekihei2317/.moon/lib/core/builtin/string_methods.mbt","/Users/tekihei2317/.moon/lib/core/builtin/arraycore_js.mbt","/Users/tekihei2317/.moon/lib/core/builtin/char.mbt","/Users/tekihei2317/.moon/lib/core/builtin/show.mbt","/Users/tekihei2317/.moon/lib/core/builtin/arrayview.mbt","/Users/tekihei2317/.moon/lib/core/builtin/array.mbt","/Users/tekihei2317/.moon/lib/core/builtin/option.mbt","/Users/tekihei2317/.moon/lib/core/builtin/linked_hash_map.mbt","/Users/tekihei2317/.moon/lib/core/builtin/int.mbt","/Users/tekihei2317/.moon/lib/core/strconv/errors.mbt","/Users/tekihei2317/ghq/github.com/tekihei2317/learn-moonbit/rabbit_playground/.mooncakes/Yoorkin/rabbit-tea/src/url/url.mbt","/Users/tekihei2317/ghq/github.com/tekihei2317/learn-moonbit/rabbit_playground/.mooncakes/rami3l/js-ffi/src/js/null.mbt","/Users/tekihei2317/ghq/github.com/tekihei2317/learn-moonbit/rabbit_playground/.mooncakes/Yoorkin/rabbit-tea/src/cmd/command.mbt","/Users/tekihei2317/ghq/github.com/tekihei2317/learn-moonbit/rabbit_playground/.mooncakes/Yoorkin/rabbit-tea/src/dom/node.mbt","/Users/tekihei2317/ghq/github.com/tekihei2317/learn-moonbit/rabbit_playground/.mooncakes/Yoorkin/rabbit-tea/src/dom/mouse_event.mbt","/Users/tekihei2317/ghq/github.com/tekihei2317/learn-moonbit/rabbit_playground/.mooncakes/Yoorkin/rabbit-tea/src/dom/html_element.mbt","/Users/tekihei2317/ghq/github.com/tekihei2317/learn-moonbit/rabbit_playground/.mooncakes/Yoorkin/rabbit-tea/src/dom/exception.mbt","/Users/tekihei2317/ghq/github.com/tekihei2317/learn-moonbit/rabbit_playground/.mooncakes/Yoorkin/rabbit-tea/src/dom/event_target.mbt","/Users/tekihei2317/ghq/github.com/tekihei2317/learn-moonbit/rabbit_playground/.mooncakes/Yoorkin/rabbit-tea/src/dom/event.mbt","/Users/tekihei2317/ghq/github.com/tekihei2317/learn-moonbit/rabbit_playground/.mooncakes/Yoorkin/rabbit-tea/src/dom/element.mbt","/Users/tekihei2317/ghq/github.com/tekihei2317/learn-moonbit/rabbit_playground/.mooncakes/Yoorkin/rabbit-tea/src/internal/browser/sandbox.mbt","/Users/tekihei2317/ghq/github.com/tekihei2317/learn-moonbit/rabbit_playground/.mooncakes/Yoorkin/rabbit-tea/src/internal/vdom/dom.mbt","/Users/tekihei2317/ghq/github.com/tekihei2317/learn-moonbit/rabbit_playground/.mooncakes/Yoorkin/rabbit-tea/src/html/html.mbt","/Users/tekihei2317/ghq/github.com/tekihei2317/learn-moonbit/rabbit_playground/.mooncakes/Yoorkin/rabbit-tea/src/html/attributes.mbt","/Users/tekihei2317/ghq/github.com/tekihei2317/learn-moonbit/rabbit_playground/.mooncakes/Yoorkin/rabbit-tea/src/top.mbt","/Users/tekihei2317/ghq/github.com/tekihei2317/learn-moonbit/rabbit_playground/src/main/main.mbt"],"sourcesContent":["// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//region MyInt64\n\n///|\npriv struct MyInt64 {\n  hi : Int\n  lo : Int\n}\n\n///|\nfn MyInt64::to_int64(self : MyInt64) -> Int64 = \"%identity\"\n\n///|\nfn MyInt64::from_int64(value : Int64) -> MyInt64 = \"%identity\"\n\n///|\nimpl Neg for MyInt64 with neg(self : MyInt64) -> MyInt64 {\n  if self.lo == 0 {\n    { hi: self.hi.lnot() + 1, lo: 0 }\n  } else {\n    { hi: self.hi.lnot(), lo: self.lo.lnot() + 1 }\n  }\n}\n\n///|\nfn MyInt64::add_hi_lo(self : MyInt64, bhi : Int, blo : Int) -> MyInt64 {\n  let { hi: ahi, lo: alo } = self\n  let lo = alo + blo\n  let s = lo >> 31\n  let as_ = alo >> 31\n  let bs = blo >> 31\n  let c = ((as_ & bs) | (s.lnot() & (as_ ^ bs))) & 1\n  let hi = ahi + bhi + c\n  { hi, lo }\n}\n\n///|\nimpl Add for MyInt64 with add(self : MyInt64, other : MyInt64) -> MyInt64 {\n  self.add_hi_lo(other.hi, other.lo)\n}\n\n///|\nimpl Sub for MyInt64 with sub(self : MyInt64, other : MyInt64) -> MyInt64 {\n  if other.lo == 0 {\n    { hi: self.hi - other.hi, lo: self.lo }\n  } else {\n    self.add_hi_lo(other.hi.lnot(), other.lo.lnot() + 1)\n  }\n}\n\n///|\nimpl Mul for MyInt64 with mul(self : MyInt64, other : MyInt64) -> MyInt64 {\n  let { hi: ahi, lo: alo } = self\n  let { hi: bhi, lo: blo } = other\n  let ahi = ahi.reinterpret_as_uint()\n  let alo = alo.reinterpret_as_uint()\n  let bhi = bhi.reinterpret_as_uint()\n  let blo = blo.reinterpret_as_uint()\n  let a48 = ahi >> 16\n  let a32 = ahi & 0xffff\n  let a16 = alo >> 16\n  let a00 = alo & 0xffff\n  let b48 = bhi >> 16\n  let b32 = bhi & 0xffff\n  let b16 = blo >> 16\n  let b00 = blo & 0xffff\n  let c00 = a00 * b00\n  let c16 = c00 >> 16\n  let c00 = c00 & 0xffff\n  let c16 = c16 + a16 * b00\n  let c32 = c16 >> 16\n  let c16 = c16 & 0xffff\n  let c16 = c16 + a00 * b16\n  let c32 = c32 + (c16 >> 16)\n  let c16 = c16 & 0xffff\n  let c32 = c32 + a32 * b00\n  let c48 = c32 >> 16\n  let c32 = c32 & 0xffff\n  let c32 = c32 + a16 * b16\n  let c48 = c48 + (c32 >> 16)\n  let c32 = c32 & 0xffff\n  let c32 = c32 + a00 * b32\n  let c48 = c48 + (c32 >> 16)\n  let c32 = c32 & 0xffff\n  let c48 = c48 + a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48\n  let c48 = c48 & 0xffff\n  {\n    hi: ((c48 << 16) | c32).reinterpret_as_int(),\n    lo: ((c16 << 16) | c00).reinterpret_as_int(),\n  }\n}\n\n///|\npriv struct Int64WasmHelper {\n  div_s : (Int, Int, Int, Int) -> Int\n  div_u : (Int, Int, Int, Int) -> Int\n  rem_s : (Int, Int, Int, Int) -> Int\n  rem_u : (Int, Int, Int, Int) -> Int\n  get_high : () -> Int\n}\n\n///|\npriv struct WasmHelperCache {\n  mut tried : Bool\n  mut exports : Int64WasmHelper?\n}\n\n///|\nlet wasm_helper_cache : WasmHelperCache = { tried: false, exports: None }\n\n///|\nfn try_get_int64_wasm_helper() -> Bool {\n  if wasm_helper_cache.tried {\n    return match wasm_helper_cache.exports {\n      Some(_) => true\n      None => false\n    }\n  }\n  wasm_helper_cache.tried = true\n  wasm_helper_cache.exports = try_init_wasm_helper()\n  match wasm_helper_cache.exports {\n    Some(_) => true\n    None => false\n  }\n}\n\n///|\nextern \"js\" fn try_init_wasm_helper() -> Int64WasmHelper? =\n  #|function() {\n  #|  try {\n  #|    return new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;\n  #|  } catch (e) {\n  #|    return undefined;\n  #|  }\n  #|}\n\n///|\n// BigInt-based fallback for signed division\nextern \"js\" fn MyInt64::div_bigint(self : MyInt64, other : MyInt64) -> MyInt64 =\n  #|(a, b) => {\n  #|  const aVal = (BigInt(a.hi) << 32n) | BigInt(a.lo >>> 0);\n  #|  const bVal = (BigInt(b.hi) << 32n) | BigInt(b.lo >>> 0);\n  #|  const result = aVal / bVal;\n  #|  const lo = Number(result & 0xFFFFFFFFn);\n  #|  const hi = Number((result >> 32n) & 0xFFFFFFFFn);\n  #|  return { hi: hi | 0, lo: lo | 0 };\n  #|}\n\n///|\n// BigInt-based fallback for unsigned division\nextern \"js\" fn MyInt64::div_u_bigint(\n  self : MyInt64,\n  other : MyInt64,\n) -> MyInt64 =\n  #|(a, b) => {\n  #|  const aVal = (BigInt(a.hi >>> 0) << 32n) | BigInt(a.lo >>> 0);\n  #|  const bVal = (BigInt(b.hi >>> 0) << 32n) | BigInt(b.lo >>> 0);\n  #|  const result = aVal / bVal;\n  #|  const lo = Number(result & 0xFFFFFFFFn);\n  #|  const hi = Number((result >> 32n) & 0xFFFFFFFFn);\n  #|  return { hi: hi | 0, lo: lo | 0 };\n  #|}\n\n///|\n// BigInt-based fallback for signed modulo\nextern \"js\" fn MyInt64::mod_bigint(self : MyInt64, other : MyInt64) -> MyInt64 =\n  #|(a, b) => {\n  #|  const aVal = (BigInt(a.hi) << 32n) | BigInt(a.lo >>> 0);\n  #|  const bVal = (BigInt(b.hi) << 32n) | BigInt(b.lo >>> 0);\n  #|  const result = aVal % bVal;\n  #|  const lo = Number(result & 0xFFFFFFFFn);\n  #|  const hi = Number((result >> 32n) & 0xFFFFFFFFn);\n  #|  return { hi: hi | 0, lo: lo | 0 };\n  #|}\n\n///|\n// BigInt-based fallback for unsigned modulo\nextern \"js\" fn MyInt64::mod_u_bigint(\n  self : MyInt64,\n  other : MyInt64,\n) -> MyInt64 =\n  #|(a, b) => {\n  #|  const aVal = (BigInt(a.hi >>> 0) << 32n) | BigInt(a.lo >>> 0);\n  #|  const bVal = (BigInt(b.hi >>> 0) << 32n) | BigInt(b.lo >>> 0);\n  #|  const result = aVal % bVal;\n  #|  const lo = Number(result & 0xFFFFFFFFn);\n  #|  const hi = Number((result >> 32n) & 0xFFFFFFFFn);\n  #|  return { hi: hi | 0, lo: lo | 0 };\n  #|}\n\n///|\nimpl Div for MyInt64 with div(self : MyInt64, other : MyInt64) -> MyInt64 {\n  guard not(other.hi == 0 && other.lo == 0) else { panic() }\n  if not(try_get_int64_wasm_helper()) {\n    // Fallback to BigInt if WebAssembly is not available\n    return self.div_bigint(other)\n  }\n  match wasm_helper_cache.exports {\n    Some(exports) => {\n      let { hi: ahi, lo: alo } = self\n      let { hi: bhi, lo: blo } = other\n      let lo = (exports.div_s)(alo, ahi, blo, bhi)\n      let hi = (exports.get_high)()\n      { hi, lo }\n    }\n    None => panic()\n  }\n}\n\n///|\nfn MyInt64::div_u(self : MyInt64, other : MyInt64) -> MyInt64 {\n  guard not(other.hi == 0 && other.lo == 0) else { panic() }\n  if not(try_get_int64_wasm_helper()) {\n    // Fallback to BigInt if WebAssembly is not available\n    return self.div_u_bigint(other)\n  }\n  match wasm_helper_cache.exports {\n    Some(exports) => {\n      let { hi: ahi, lo: alo } = self\n      let { hi: bhi, lo: blo } = other\n      let lo = (exports.div_u)(alo, ahi, blo, bhi)\n      let hi = (exports.get_high)()\n      { hi, lo }\n    }\n    None => panic()\n  }\n}\n\n///|\nimpl Mod for MyInt64 with mod(self : MyInt64, other : MyInt64) -> MyInt64 {\n  guard not(other.hi == 0 && other.lo == 0) else { panic() }\n  if not(try_get_int64_wasm_helper()) {\n    // Fallback to BigInt if WebAssembly is not available\n    return self.mod_bigint(other)\n  }\n  match wasm_helper_cache.exports {\n    Some(exports) => {\n      let { hi: ahi, lo: alo } = self\n      let { hi: bhi, lo: blo } = other\n      let lo = (exports.rem_s)(alo, ahi, blo, bhi)\n      let hi = (exports.get_high)()\n      { hi, lo }\n    }\n    None => panic()\n  }\n}\n\n///|\nfn MyInt64::mod_u(self : MyInt64, other : MyInt64) -> MyInt64 {\n  guard not(other.hi == 0 && other.lo == 0) else { panic() }\n  if not(try_get_int64_wasm_helper()) {\n    // Fallback to BigInt if WebAssembly is not available\n    return self.mod_u_bigint(other)\n  }\n  match wasm_helper_cache.exports {\n    Some(exports) => {\n      let { hi: ahi, lo: alo } = self\n      let { hi: bhi, lo: blo } = other\n      let lo = (exports.rem_u)(alo, ahi, blo, bhi)\n      let hi = (exports.get_high)()\n      { hi, lo }\n    }\n    None => panic()\n  }\n}\n\n///|\nfn MyInt64::lnot(self : MyInt64) -> MyInt64 {\n  { hi: self.hi.lnot(), lo: self.lo.lnot() }\n}\n\n///|\nfn MyInt64::land(self : MyInt64, other : MyInt64) -> MyInt64 {\n  { hi: self.hi & other.hi, lo: self.lo & other.lo }\n}\n\n///|\nfn MyInt64::lor(self : MyInt64, other : MyInt64) -> MyInt64 {\n  { hi: self.hi | other.hi, lo: self.lo | other.lo }\n}\n\n///|\nfn MyInt64::lxor(self : MyInt64, other : MyInt64) -> MyInt64 {\n  { hi: self.hi ^ other.hi, lo: self.lo ^ other.lo }\n}\n\n///|\nfn MyInt64::lsl(self : MyInt64, shift : Int) -> MyInt64 {\n  let shift = shift & 63\n  if shift == 0 {\n    self\n  } else if shift < 32 {\n    let { hi, lo } = self\n    let hi = hi.reinterpret_as_uint()\n    let lo = lo.reinterpret_as_uint()\n    let hi = (hi << shift) | (lo >> (32 - shift))\n    let lo = lo << shift\n    { hi: hi.reinterpret_as_int(), lo: lo.reinterpret_as_int() }\n  } else {\n    { hi: self.lo << (shift - 32), lo: 0 }\n  }\n}\n\n///|\nfn MyInt64::lsr(self : MyInt64, shift : Int) -> MyInt64 {\n  let shift = shift & 63\n  if shift == 0 {\n    self\n  } else if shift < 32 {\n    {\n      hi: (self.hi.reinterpret_as_uint() >> shift).reinterpret_as_int(),\n      lo: (self.lo.reinterpret_as_uint() >> shift).reinterpret_as_int() |\n      (self.hi << (32 - shift)),\n    }\n  } else {\n    {\n      hi: 0,\n      lo: (self.hi.reinterpret_as_uint() >> (shift - 32)).reinterpret_as_int(),\n    }\n  }\n}\n\n///|\nfn MyInt64::asr(self : MyInt64, shift : Int) -> MyInt64 {\n  let shift = shift & 63\n  if shift == 0 {\n    self\n  } else if shift < 32 {\n    {\n      hi: self.hi >> shift,\n      lo: (self.lo.reinterpret_as_uint() >> shift).reinterpret_as_int() |\n      (self.hi << (32 - shift)),\n    }\n  } else {\n    { hi: self.hi >> 31, lo: self.hi >> (shift - 32) }\n  }\n}\n\n///|\nfn MyInt64::clz(self : MyInt64) -> Int {\n  if self.hi != 0 {\n    self.hi.clz()\n  } else {\n    32 + self.lo.clz()\n  }\n}\n\n///|\nfn MyInt64::ctz(self : MyInt64) -> Int {\n  if self.lo != 0 {\n    self.lo.ctz()\n  } else {\n    32 + self.hi.ctz()\n  }\n}\n\n///|\nfn MyInt64::popcnt(self : MyInt64) -> Int {\n  self.hi.popcnt() + self.lo.popcnt()\n}\n\n///|\nimpl Eq for MyInt64 with equal(self : MyInt64, other : MyInt64) -> Bool {\n  self.hi == other.hi && self.lo == other.lo\n}\n\n// a.lsr(0) is compiled to `(a >>> 0 | 0)` in JavaScript\n// so we can't use moonbit to generate the code\n\n///|\nextern \"js\" fn MyInt64::compare(self : MyInt64, other : MyInt64) -> Int =\n  #|(a, b) => {\n  #|  const ahi = a.hi;\n  #|  const bhi = b.hi;\n  #|  if (ahi < bhi) {\n  #|    return -1;\n  #|  }\n  #|  if (ahi > bhi) {\n  #|    return 1;\n  #|  }\n  #|  const alo = a.lo >>> 0;\n  #|  const blo = b.lo >>> 0;\n  #|  if (alo < blo) {\n  #|    return -1;\n  #|  }\n  #|  if (alo > blo) {\n  #|    return 1;\n  #|  }\n  #|  return 0;\n  #|}\n\n///|\nextern \"js\" fn MyInt64::compare_u(self : MyInt64, other : MyInt64) -> Int =\n  #|(a, b) => {\n  #|  const ahi = a.hi >>> 0;\n  #|  const bhi = b.hi >>> 0;\n  #|  if (ahi < bhi) {\n  #|    return -1;\n  #|  }\n  #|  if (ahi > bhi) {\n  #|    return 1;\n  #|  }\n  #|  const alo = a.lo >>> 0;\n  #|  const blo = b.lo >>> 0;\n  #|  if (alo < blo) {\n  #|    return -1;\n  #|  }\n  #|  if (alo > blo) {\n  #|    return 1;\n  #|  }\n  #|  return 0;\n  #|}\n\n///|\nfn MyInt64::from_int(value : Int) -> MyInt64 {\n  { hi: (value >> 31) & -1, lo: value | 0 }\n}\n\n///|\nfn MyInt64::to_int(self : MyInt64) -> Int {\n  self.lo\n}\n\n///|\nfn MyInt64::to_uint(self : MyInt64) -> UInt {\n  self.lo.reinterpret_as_uint()\n}\n\n///|\nfn MyInt64::extend_i32_u(value : Int) -> MyInt64 {\n  { hi: 0, lo: value }\n}\n\n///|\nextern \"js\" fn MyInt64::reinterpret_as_double(self : MyInt64) -> Double =\n  #|function f(a) {\n  #|  let view = f._view;\n  #|  if (view === undefined) {\n  #|    view = f._view = new DataView(new ArrayBuffer(8));\n  #|  }\n  #|  view.setUint32(0, a.hi);\n  #|  view.setUint32(4, a.lo);\n  #|  return view.getFloat64(0);\n  #|}\n\n///|\nextern \"js\" fn MyInt64::reinterpret_double(value : Double) -> MyInt64 =\n  #|function f(a) {\n  #|  let view = f._view;\n  #|  if (view === undefined) {\n  #|    view = f._view = new DataView(new ArrayBuffer(8));\n  #|  }\n  #|  view.setFloat64(0, a);\n  #|  const hi = view.getInt32(0);\n  #|  const lo = view.getInt32(4);\n  #|  return { hi, lo };\n  #|}\n\n///|\nextern \"js\" fn MyInt64::trunc_double_u(value : Double) -> MyInt64 =\n  #|(a) => {\n  #|  let hi = (a * (1 / 0x100000000)) | 0;\n  #|  let lo = a | 0;\n  #|  return { hi, lo };\n  #|}\n\n///|\nextern \"js\" fn MyInt64::convert_to_double_u(self : MyInt64) -> Double =\n  #|(a) => (a.hi >>> 0) * 4294967296.0 + (a.lo >>> 0)\n\n///|\nextern \"js\" fn MyInt64::convert_to_double(self : MyInt64) -> Double =\n  #|(a) => a.hi * 4294967296.0 + (a.lo >>> 0)\n//endregion\n\n///|\npub impl Neg for Int64 with neg(self : Int64) -> Int64 {\n  (-MyInt64::from_int64(self)).to_int64()\n}\n\n///|\npub impl Add for Int64 with add(self : Int64, other : Int64) -> Int64 {\n  MyInt64::from_int64(self).add(MyInt64::from_int64(other)).to_int64()\n}\n\n///|\npub impl Sub for Int64 with sub(self : Int64, other : Int64) -> Int64 {\n  MyInt64::from_int64(self).sub(MyInt64::from_int64(other)).to_int64()\n}\n\n///|\npub impl Mul for Int64 with mul(self : Int64, other : Int64) -> Int64 {\n  MyInt64::from_int64(self).mul(MyInt64::from_int64(other)).to_int64()\n}\n\n///|\npub impl Div for Int64 with div(self : Int64, other : Int64) -> Int64 {\n  MyInt64::from_int64(self).div(MyInt64::from_int64(other)).to_int64()\n}\n\n///|\npub impl Mod for Int64 with mod(self : Int64, other : Int64) -> Int64 {\n  MyInt64::from_int64(self).mod(MyInt64::from_int64(other)).to_int64()\n}\n\n///|\npub fn Int64::lnot(self : Int64) -> Int64 {\n  MyInt64::from_int64(self).lnot().to_int64()\n}\n\n///|\npub impl BitAnd for Int64 with land(self : Int64, other : Int64) -> Int64 {\n  MyInt64::from_int64(self).land(MyInt64::from_int64(other)).to_int64()\n}\n\n///|\npub impl BitOr for Int64 with lor(self : Int64, other : Int64) -> Int64 {\n  MyInt64::from_int64(self).lor(MyInt64::from_int64(other)).to_int64()\n}\n\n///|\npub impl BitXOr for Int64 with lxor(self : Int64, other : Int64) -> Int64 {\n  MyInt64::from_int64(self).lxor(MyInt64::from_int64(other)).to_int64()\n}\n\n///|\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn Int64::lsl(self : Int64, other : Int) -> Int64 {\n  MyInt64::from_int64(self).lsl(other).to_int64()\n}\n\n///|\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn Int64::shl(self : Int64, other : Int) -> Int64 {\n  MyInt64::from_int64(self).lsl(other).to_int64()\n}\n\n///|\n#deprecated(\"Use UInt64 type and infix operator `>>` instead\")\n#coverage.skip\npub fn Int64::lsr(self : Int64, other : Int) -> Int64 {\n  MyInt64::from_int64(self).lsr(other).to_int64()\n}\n\n///|\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn Int64::shr(self : Int64, other : Int) -> Int64 {\n  MyInt64::from_int64(self).asr(other).to_int64()\n}\n\n///|\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn Int64::asr(self : Int64, other : Int) -> Int64 {\n  MyInt64::from_int64(self).asr(other).to_int64()\n}\n\n///|\npub impl Shr for Int64 with shr(self : Int64, other : Int) -> Int64 {\n  MyInt64::from_int64(self).asr(other).to_int64()\n}\n\n///|\npub impl Shl for Int64 with shl(self : Int64, other : Int) -> Int64 {\n  MyInt64::from_int64(self).lsl(other).to_int64()\n}\n\n///|\npub fn Int64::ctz(self : Int64) -> Int {\n  MyInt64::from_int64(self).ctz()\n}\n\n///|\npub fn Int64::clz(self : Int64) -> Int {\n  MyInt64::from_int64(self).clz()\n}\n\n///|\npub fn Int64::popcnt(self : Int64) -> Int {\n  MyInt64::from_int64(self).popcnt()\n}\n\n///|\npub impl Eq for Int64 with equal(self : Int64, other : Int64) -> Bool {\n  MyInt64::from_int64(self) == MyInt64::from_int64(other)\n}\n\n///|\npub impl Compare for Int64 with compare(self : Int64, other : Int64) -> Int {\n  MyInt64::compare(MyInt64::from_int64(self), MyInt64::from_int64(other))\n}\n\n///|\npub impl Default for Int64 with default() {\n  0L\n}\n\n///|\npub fn Int64::to_int(self : Int64) -> Int {\n  MyInt64::from_int64(self).to_int()\n}\n\n///|\npub fn Int64::to_double(self : Int64) -> Double {\n  Double::convert_int64(self)\n}\n\n///|\npub fn Int64::to_byte(self : Int64) -> Byte {\n  MyInt64::from_int64(self).to_int().to_byte()\n}\n\n///|\npub fn Int64::to_uint16(self : Int64) -> UInt16 {\n  MyInt64::from_int64(self).to_int().to_uint16()\n}\n\n///|\npub fn UInt64::extend_uint(value : UInt) -> UInt64 {\n  MyInt64::extend_i32_u(value.reinterpret_as_int()).to_uint64()\n}\n\n///|\npub fn Int64::reinterpret_as_double(self : Int64) -> Double {\n  MyInt64::reinterpret_as_double(MyInt64::from_int64(self))\n}\n\n///|\npub fn UInt64::reinterpret_as_double(self : UInt64) -> Double {\n  MyInt64::reinterpret_as_double(MyInt64::from_uint64(self))\n}\n\n///|\npub fn Int::to_int64(self : Int) -> Int64 {\n  MyInt64::from_int(self).to_int64()\n}\n\n///|\npub fn UInt16::to_int64(self : UInt16) -> Int64 {\n  MyInt64::from_int(self.to_int()).to_int64()\n}\n\n///|\n#deprecated(\"Use `reinterpret_as_int64` instead\")\n#coverage.skip\npub fn Double::reinterpret_as_i64(self : Double) -> Int64 {\n  MyInt64::reinterpret_double(self).to_int64()\n}\n\n///|\npub fn Double::reinterpret_as_int64(self : Double) -> Int64 {\n  MyInt64::reinterpret_double(self).to_int64()\n}\n\n///|\n#deprecated(\"Use `reinterpret_as_uint64` instead\")\n#coverage.skip\npub fn Double::reinterpret_as_u64(self : Double) -> UInt64 {\n  MyInt64::reinterpret_double(self).to_uint64()\n}\n\n///|\npub fn Double::reinterpret_as_uint64(self : Double) -> UInt64 {\n  MyInt64::reinterpret_double(self).to_uint64()\n}\n\n///|\npub fn Double::convert_uint64(value : UInt64) -> Double {\n  MyInt64::convert_to_double_u(MyInt64::from_uint64(value))\n}\n\n///|\nfn Double::convert_int64(value : Int64) -> Double {\n  MyInt64::convert_to_double(MyInt64::from_int64(value))\n}\n\n///|\nfn MyInt64::to_uint64(self : MyInt64) -> UInt64 = \"%identity\"\n\n///|\nfn MyInt64::from_uint64(value : UInt64) -> MyInt64 = \"%identity\"\n\n///|\n#deprecated(\"Use `reinterpret_as_uint64` instead\")\n#coverage.skip\npub fn Int64::to_uint64(self : Int64) -> UInt64 = \"%identity\"\n\n///|\npub fn Int64::reinterpret_as_uint64(self : Int64) -> UInt64 = \"%identity\"\n\n///|\npub impl Add for UInt64 with add(self : UInt64, other : UInt64) -> UInt64 {\n  MyInt64::from_uint64(self).add(MyInt64::from_uint64(other)).to_uint64()\n}\n\n///|\npub impl Sub for UInt64 with sub(self : UInt64, other : UInt64) -> UInt64 {\n  MyInt64::from_uint64(self).sub(MyInt64::from_uint64(other)).to_uint64()\n}\n\n///|\npub impl Mul for UInt64 with mul(self : UInt64, other : UInt64) -> UInt64 {\n  MyInt64::from_uint64(self).mul(MyInt64::from_uint64(other)).to_uint64()\n}\n\n///|\npub impl Div for UInt64 with div(self : UInt64, other : UInt64) -> UInt64 {\n  MyInt64::from_uint64(self).div_u(MyInt64::from_uint64(other)).to_uint64()\n}\n\n///|\npub impl Mod for UInt64 with mod(self : UInt64, other : UInt64) -> UInt64 {\n  MyInt64::from_uint64(self).mod_u(MyInt64::from_uint64(other)).to_uint64()\n}\n\n///|\n#deprecated(\"Use reinterpret_as_int64 instead\")\n#coverage.skip\npub fn UInt64::to_int64(self : UInt64) -> Int64 = \"%identity\"\n\n///|\npub fn UInt64::reinterpret_as_int64(self : UInt64) -> Int64 = \"%identity\"\n\n///|\npub fn UInt64::to_uint(self : UInt64) -> UInt {\n  MyInt64::from_uint64(self).to_uint()\n}\n\n///|\n/// Converts a 64-bit unsigned integer to a 16-bit unsigned integer by truncating\n/// the value to fit within the range of UInt16 (0 to 65535).\n///\n/// Parameters:\n///\n/// * `value` : The 64-bit unsigned integer to be converted to UInt16.\n///\n/// Returns a 16-bit unsigned integer representing the lower 16 bits of the input\n/// value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(42UL.to_uint16(), content=\"42\")\n///   inspect(18446744073709551615UL.to_uint16(), content=\"65535\") // Wraps around to maximum UInt16 value\n///   inspect(70000UL.to_uint16(), content=\"4464\") // Value is truncated\n/// }\n/// ```\npub fn UInt64::to_uint16(self : UInt64) -> UInt16 {\n  self.reinterpret_as_int64().to_uint16()\n}\n\n///|\npub fn UInt64::to_int(self : UInt64) -> Int {\n  MyInt64::from_uint64(self).to_int()\n}\n\n///|\npub fn UInt64::to_double(self : UInt64) -> Double {\n  Double::convert_uint64(self)\n}\n\n///|\npub impl Compare for UInt64 with compare(self : UInt64, other : UInt64) -> Int {\n  MyInt64::from_uint64(self).compare_u(MyInt64::from_uint64(other))\n}\n\n///|\npub impl Eq for UInt64 with equal(self : UInt64, other : UInt64) -> Bool {\n  MyInt64::from_uint64(self).equal(MyInt64::from_uint64(other))\n}\n\n///|\npub fn UInt64::trunc_double(value : Double) -> UInt64 {\n  MyInt64::trunc_double_u(value).to_uint64()\n}\n\n///|\npub impl BitAnd for UInt64 with land(self : UInt64, other : UInt64) -> UInt64 {\n  MyInt64::land(MyInt64::from_uint64(self), MyInt64::from_uint64(other)).to_uint64()\n}\n\n///|\npub impl BitOr for UInt64 with lor(self : UInt64, other : UInt64) -> UInt64 {\n  MyInt64::lor(MyInt64::from_uint64(self), MyInt64::from_uint64(other)).to_uint64()\n}\n\n///|\npub impl BitXOr for UInt64 with lxor(self : UInt64, other : UInt64) -> UInt64 {\n  MyInt64::lxor(MyInt64::from_uint64(self), MyInt64::from_uint64(other)).to_uint64()\n}\n\n///|\npub fn UInt64::lnot(self : UInt64) -> UInt64 {\n  MyInt64::lnot(MyInt64::from_uint64(self)).to_uint64()\n}\n\n///|\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn UInt64::lsl(self : UInt64, shift : Int) -> UInt64 {\n  MyInt64::lsl(MyInt64::from_uint64(self), shift).to_uint64()\n}\n\n///|\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn UInt64::lsr(self : UInt64, shift : Int) -> UInt64 {\n  MyInt64::lsr(MyInt64::from_uint64(self), shift).to_uint64()\n}\n\n///|\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn UInt64::shl(self : UInt64, shift : Int) -> UInt64 {\n  MyInt64::lsl(MyInt64::from_uint64(self), shift).to_uint64()\n}\n\n///|\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn UInt64::shr(self : UInt64, shift : Int) -> UInt64 {\n  MyInt64::lsr(MyInt64::from_uint64(self), shift).to_uint64()\n}\n\n///|\npub impl Shl for UInt64 with shl(self : UInt64, shift : Int) -> UInt64 {\n  MyInt64::lsl(MyInt64::from_uint64(self), shift).to_uint64()\n}\n\n///|\npub impl Shr for UInt64 with shr(self : UInt64, shift : Int) -> UInt64 {\n  MyInt64::lsr(MyInt64::from_uint64(self), shift).to_uint64()\n}\n\n///|\npub fn UInt64::clz(self : UInt64) -> Int {\n  MyInt64::from_uint64(self).clz()\n}\n\n///|\npub fn UInt64::ctz(self : UInt64) -> Int {\n  MyInt64::from_uint64(self).ctz()\n}\n\n///|\npub fn UInt64::popcnt(self : UInt64) -> Int {\n  MyInt64::from_uint64(self).popcnt()\n}\n\n///|\n#deprecated(\"Use `Float::from_int64` instead\")\npub fn Int64::to_float(self : Int64) -> Float {\n  self.to_double().to_float()\n}\n\n///|\n#deprecated(\"Use `Float::from_uint64` instead\")\npub fn UInt64::to_float(self : UInt64) -> Float {\n  Double::convert_uint64(self).to_float()\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nconst GPRIME1 : UInt = 0x9E3779B1\n\n///|\nconst GPRIMES2 : UInt = 0x85EBCA77\n\n///|\nconst GPRIME3 : UInt = 0xC2B2AE3D\n\n///|\nconst GPRIME4 : UInt = 0x27D4EB2F\n\n///|\nconst GPRIME5 : UInt = 0x165667B1\n\n///|\n/// Represents a hasher that implements the xxHash32 algorithm. The hasher\n/// maintains a mutable accumulator that is updated with each value added to the\n/// hash computation.\n///\n/// This struct provides methods for combining different types of values into a\n/// single hash value, making it suitable for implementing hash functions for\n/// custom types.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_int(42)\n///   hasher.combine_string(\"hello\")\n///   inspect(hasher.finalize(), content=\"860601284\")\n/// }\n/// ```\nstruct Hasher {\n  mut acc : UInt\n}\n\n///|\n/// Creates a new hasher with an optional seed value.\n///\n/// Parameters:\n///\n/// * `seed` : An integer value used to initialize the hasher's internal state.\n/// Defaults to 0.\n///\n/// Returns a new `Hasher` instance initialized with the given seed value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let h1 = Hasher::new(seed=0) // Create a hasher with default seed\n///   let h2 = Hasher::new(seed=42) // Create a hasher with custom seed\n///   let x = 123\n///   h1.combine(x)\n///   h2.combine(x)\n///   inspect(h1.finalize() != h2.finalize(), content=\"true\") // Different seeds produce different hashes\n/// }\n/// ```\npub fn Hasher::new(seed? : Int = seed) -> Hasher {\n  { acc: seed.reinterpret_as_uint() + GPRIME5 }\n}\n\n///|\n#cfg(not(target=\"js\"))\nlet seed : Int = 0\n\n///|\n#cfg(target=\"js\")\nlet seed : Int = random_seed()\n\n///|\n#cfg(target=\"js\")\nextern \"js\" fn random_seed() -> Int =\n  #|() => {\n  #|  if (globalThis.crypto?.getRandomValues) {\n  #|    const array = new Uint32Array(1);\n  #|    globalThis.crypto.getRandomValues(array);\n  #|    return array[0] | 0; // Convert to signed 32\n  #|  } else {\n  #|    return Math.floor(Math.random() * 0x100000000) | 0; // Fallback to Math.random\n  #|  }\n  #|}\n\n///|\n/// Combines a hashable value with the current state of the hasher. This is\n/// typically used to incrementally build a hash value from multiple components.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The value to be combined with the current hash state. Must\n/// implement the `Hash` trait.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine(42)\n///   hasher.combine(\"hello\")\n///   inspect(hasher.finalize(), content=\"860601284\")\n/// }\n/// ```\npub fn[T : Hash] Hasher::combine(self : Hasher, value : T) -> Unit {\n  value.hash_combine(self)\n}\n\n///|\n/// Combines the unit value (i.e., `()`) into the hasher's internal state by\n/// hashing it as an integer value of 0.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to combine the unit value into.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_unit()\n///   inspect(hasher.finalize(), content=\"148298089\")\n/// }\n/// ```\npub fn Hasher::combine_unit(self : Hasher) -> Unit {\n  self.combine_uint(0)\n}\n\n///|\n/// Combines a boolean value into the current hash state. The boolean value is\n/// converted to an integer (1 for true, 0 for false) before being combined with\n/// the hash.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The boolean value to be combined into the hash state.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_bool(true)\n///   inspect(hasher.finalize(), content=\"-205818221\")\n/// }\n/// ```\npub fn Hasher::combine_bool(self : Hasher, value : Bool) -> Unit {\n  self.combine_uint(if value { 1 } else { 0 })\n}\n\n///|\n/// Combines a 32-bit integer value into the hasher's internal state. The value\n/// is processed\n/// as a 4-byte sequence, and the internal accumulator is updated accordingly.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : A 32-bit integer value to be incorporated into the hash.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_int(42)\n///   inspect(hasher.finalize(), content=\"1161967057\")\n/// }\n/// ```\npub fn Hasher::combine_int(self : Hasher, value : Int) -> Unit {\n  self.combine_uint(value.reinterpret_as_uint())\n}\n\n///|\n/// Combines a 64-bit integer value into the hash state by splitting it into two\n/// 32-bit parts and processing them separately. This method is used internally\n/// by the hash implementation to incorporate 64-bit integers into the hash\n/// computation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object whose internal state will be updated.\n/// * `value` : The 64-bit integer value to be incorporated into the hash state.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_int64(42L)\n///   inspect(hasher.finalize(), content=\"-1962516083\")\n/// }\n/// ```\npub fn Hasher::combine_int64(self : Hasher, value : Int64) -> Unit {\n  self.acc += 8\n  self.consume4(value.reinterpret_as_uint64().to_uint())\n  self.consume4((value.reinterpret_as_uint64() >> 32).to_uint())\n}\n\n///|\n/// Combines an unsigned 32-bit integer into the hasher's internal state by\n/// reinterpreting it as a signed integer and incorporating it into the hash\n/// computation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to update.\n/// * `value` : The unsigned 32-bit integer value to be combined into the hash.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_uint(42U)\n///   inspect(hasher.finalize(), content=\"1161967057\")\n/// }\n/// ```\npub fn Hasher::combine_uint(self : Hasher, value : UInt) -> Unit {\n  self.acc += 4\n  self.consume4(value)\n}\n\n///|\n/// Combines a 64-bit unsigned integer into the hasher's internal state. Useful\n/// for hashing `UInt64` values as part of a larger composite structure.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The 64-bit unsigned integer value to be incorporated into the\n/// hash.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_uint64(42UL)\n///   inspect(hasher.finalize(), content=\"-1962516083\")\n/// }\n/// ```\npub fn Hasher::combine_uint64(self : Hasher, value : UInt64) -> Unit {\n  self.combine_int64(value.reinterpret_as_int64())\n}\n\n///|\n/// Combines a double-precision floating-point number into the hasher's internal\n/// state by reinterpreting its bits as a 64-bit integer. Maintains consistent\n/// hashing behavior regardless of the floating-point value's representation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher to combine the value into.\n/// * `value` : The double-precision floating-point number to be combined into\n/// the hash.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_double(3.14)\n///   inspect(hasher.finalize(), content=\"-428265677\")\n/// }\n/// ```\npub fn Hasher::combine_double(self : Hasher, value : Double) -> Unit {\n  self.combine_int64(value.reinterpret_as_int64())\n}\n\n///|\n/// Combines a 32-bit floating-point value into the hasher by reinterpreting its\n/// bit pattern as a 32-bit integer. The operation maintains the same hash result\n/// regardless of the floating-point value's representation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object that maintains the internal state of the\n/// hashing operation.\n/// * `value` : The 32-bit floating-point value to be combined into the hash.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine(3.14F)\n///   inspect(hasher.finalize(), content=\"635116317\") // Hash of the bits of 3.14\n/// }\n/// ```\n#deprecated\npub fn Hasher::combine_float(self : Hasher, value : Float) -> Unit {\n  self.combine_uint(value.reinterpret_as_uint())\n}\n\n///|\nfn Float::reinterpret_as_uint(self : Float) -> UInt = \"%f32.to_i32_reinterpret\"\n\n///|\n/// Combines a byte value into the hash state.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to update with the byte value.\n/// * `byte` : The byte value to be combined into the hash.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_byte(b'\\xFF')\n///   inspect(hasher.finalize(), content=\"1955036104\")\n/// }\n/// ```\npub fn Hasher::combine_byte(self : Hasher, value : Byte) -> Unit {\n  self.consume1(value)\n}\n\n///|\n/// Combines a byte sequence into the hasher's internal state using xxHash32\n/// algorithm. Processes the input bytes in chunks of 4 bytes for efficiency,\n/// with remaining bytes processed individually.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to update with the byte sequence.\n/// * `bytes` : The byte sequence to be combined into the hash.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_bytes(b\"\\xFF\\x00\\xFF\\x00\")\n///   inspect(hasher.finalize(), content=\"-686861102\")\n/// }\n/// ```\npub fn Hasher::combine_bytes(self : Hasher, value : Bytes) -> Unit {\n  let mut remain = value.length()\n  let mut cur = 0\n  while remain >= 4 {\n    self.consume4(endian32(value, cur))\n    cur += 4\n    remain -= 4\n  }\n  while remain >= 1 {\n    self.consume1(value[cur])\n    cur += 1\n    remain -= 1\n  }\n}\n\n///|\n/// Combines a string value into the current hash state by processing each\n/// character in the string sequentially.\n///\n/// Parameters:\n///\n/// * `self` : The hasher object whose state will be updated.\n/// * `value` : The string value to be combined into the hash state.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_string(\"hello\")\n///   inspect(hasher.finalize(), content=\"-655549713\")\n/// }\n/// ```\npub fn Hasher::combine_string(self : Hasher, value : String) -> Unit {\n  for i in 0..<value.length() {\n    self.combine_uint(value.unsafe_get(i).to_int().reinterpret_as_uint())\n  }\n}\n\n///|\n/// Combines a character value into the hasher's internal state. The character is\n/// first converted to its Unicode code point (as an integer) before being\n/// combined.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The character value to be combined into the hash state.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_char('A')\n///   inspect(hasher.finalize(), content=\"-1625495534\")\n/// }\n/// ```\npub fn Hasher::combine_char(self : Hasher, value : Char) -> Unit {\n  self.combine_uint(value.to_uint())\n}\n\n///|\n/// Finalizes the hashing process and returns the computed hash value. Applies an\n/// avalanche function to improve the distribution of the hash value.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object containing the accumulated hash state.\n///\n/// Returns a 32-bit integer representing the final hash value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_byte(b'\\xFF')\n///   inspect(hasher.finalize(), content=\"1955036104\")\n/// }\n/// ```\npub fn Hasher::finalize(self : Hasher) -> Int {\n  self.avalanche().reinterpret_as_int()\n}\n\n///|\nfn Hasher::avalanche(self : Hasher) -> UInt {\n  let mut acc = self.acc\n  acc = acc ^ (acc >> 15)\n  acc *= GPRIMES2\n  acc = acc ^ (acc >> 13)\n  acc *= GPRIME3\n  acc = acc ^ (acc >> 16)\n  acc\n}\n\n///|\nfn Hasher::consume4(self : Hasher, input : UInt) -> Unit {\n  self.acc = rotl(self.acc + input * GPRIME3, 17) * GPRIME4\n}\n\n///|\nfn Hasher::consume1(self : Hasher, input : Byte) -> Unit {\n  self.acc = rotl(self.acc + input.to_uint() * GPRIME5, 11) * GPRIME1\n}\n\n///|\nfn rotl(x : UInt, r : Int) -> UInt {\n  (x << r) | (x >> (32 - r))\n}\n\n///|\nfn endian32(input : Bytes, cur : Int) -> UInt {\n  input[cur + 0].to_uint() |\n  (\n    (input[cur + 1].to_uint() << 8) |\n    (input[cur + 2].to_uint() << 16) |\n    (input[cur + 3].to_uint() << 24)\n  )\n}\n\n///|\n/// Implements the `Hash` trait for `String` type, providing a method to combine\n/// a string's hash value with a hasher's state.\n///\n/// Parameters:\n///\n/// * `self` : The string value to be hashed.\n/// * `hasher` : The hasher object that will be updated with the string's hash\n/// value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let s1 = \"hello\"\n///   let s2 = \"hello\"\n///   let s3 = \"world\"\n///   inspect(Hash::hash(s1) == Hash::hash(s2), content=\"true\")\n///   inspect(Hash::hash(s1) == Hash::hash(s3), content=\"false\")\n/// }\n/// ```\npub impl Hash for String with hash_combine(self, hasher) {\n  hasher.combine_string(self)\n}\n\n///|\npub impl Hash for StringView with hash_combine(\n  self : StringView,\n  hasher : Hasher,\n) -> Unit {\n  let str = self.str()\n  for i in self.start()..<self.end() {\n    hasher.combine_uint(str.unsafe_get(i).to_int().reinterpret_as_uint())\n  }\n}\n\n///|\n/// Implements hash combination for integers by combining the integer value with\n/// a hasher. This implementation ensures that integers can be used as keys in\n/// hash-based collections like hash maps and hash sets.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be hashed.\n/// * `hasher` : A `Hasher` object that accumulates the hash value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_int(42)\n///   inspect(hasher.finalize(), content=\"1161967057\")\n/// }\n/// ```\npub impl Hash for Int with hash_combine(self, hasher) {\n  hasher.combine_int(self)\n}\n\n///|\n/// Combines the hash value of an unsigned integer with a hasher object. This is\n/// useful when you need to hash a data structure that contains unsigned\n/// integers.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned integer to be combined with the hasher.\n/// * `hasher` : The hasher object that will incorporate the hash value of the\n/// unsigned integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_uint(42U)\n///   inspect(hasher.finalize(), content=\"1161967057\")\n/// }\n/// ```\npub impl Hash for UInt with hash_combine(self, hasher) {\n  hasher.combine_uint(self)\n}\n\n///|\n/// Implements the `Hash` trait for `UInt64` by combining the hash value of an\n/// unsigned 64-bit integer into a hasher.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 64-bit integer value to be hashed.\n/// * `hasher` : The hasher object used to compute the combined hash value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_uint64(42UL)\n///   inspect(hasher.finalize(), content=\"-1962516083\")\n/// }\n/// ```\npub impl Hash for UInt64 with hash_combine(self, hasher) {\n  hasher.combine_uint64(self)\n}\n\n///|\n/// Implements the `Hash` trait for `Option` types, allowing them to be used as\n/// keys in hash-based collections.\n///\n/// Parameters:\n///\n/// * `self` : The `Option` value to be hashed.\n/// * `hasher` : The hasher object that accumulates the hash state.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   let some_value : Int? = Some(42)\n///   let none_value : Int? = None\n///   hasher.combine(some_value)\n///   inspect(hasher.finalize(), content=\"2103260413\")\n///   let hasher2 = Hasher::new(seed=0)\n///   hasher2.combine(none_value)\n///   inspect(hasher2.finalize(), content=\"148298089\")\n/// }\n/// ```\npub impl[X : Hash] Hash for X? with hash_combine(self, hasher) {\n  match self {\n    None => hasher.combine_int(0)\n    Some(x) => {\n      hasher.combine_int(1)\n      hasher.combine(x)\n    }\n  }\n}\n\n///|\n/// Implements the `Hash` trait for `Result` type, allowing `Result` values to be\n/// used in hash-based collections.\n///\n/// Parameters:\n///\n/// * `self` : The `Result` value to be hashed.\n/// * `hasher` : The hasher object to which the hash value will be combined.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   let ok_result : Result[Int, String] = Ok(42)\n///   let err_result : Result[Int, String] = Err(\"error\")\n///   hasher.combine(ok_result)\n///   inspect(hasher.finalize(), content=\"-1948635851\")\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine(err_result)\n///   inspect(hasher.finalize(), content=\"1953766574\")\n/// }\n/// ```\npub impl[T : Hash, E : Hash] Hash for Result[T, E] with hash_combine(\n  self,\n  hasher,\n) {\n  match self {\n    Ok(x) => {\n      hasher.combine_int(0)\n      hasher.combine(x)\n    }\n    Err(x) => {\n      hasher.combine_int(1)\n      hasher.combine(x)\n    }\n  }\n}\n\n///|\npub impl Hash for BytesView with hash_combine(self : BytesView, hasher : Hasher) {\n  let mut start = self.start()\n  let data = self.bytes()\n  let mut rest = self.len()\n  while rest >= 4 {\n    let mut result : UInt = 0\n    for i in 0..<=3 {\n      result = result | (data.unsafe_get(i + start).to_uint() << (8 * i))\n    }\n    hasher.combine_uint(result)\n    rest -= 4\n    start += 4\n  }\n  while rest >= 1 {\n    hasher.combine_byte(data.unsafe_get(start))\n    rest -= 1\n    start += 1\n  }\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Aborts the program with an error message. Always causes a panic, regardless\n/// of the message provided.\n///\n/// Parameters:\n///\n/// * `message` : A string containing the error message to be displayed when\n/// aborting.\n///\n/// Returns a value of type `T`. However, this function never actually returns a\n/// value as it always causes a panic.\n#cfg(not(target=\"native\"))\npub fn[T] abort(msg : String) -> T {\n  let _ = msg\n  panic_impl()\n}\n\n///|\n#cfg(target=\"native\")\nfn println(s : String) -> Unit = \"%println\"\n\n///|\n/// Aborts the program with an error message. Always causes a panic, regardless\n/// of the message provided.\n///\n/// Parameters:\n///\n/// * `message` : A string containing the error message to be displayed when\n/// aborting.\n///\n/// Returns a value of type `T`. However, this function never actually returns a\n/// value as it always causes a panic.\n#cfg(target=\"native\")\npub fn[T] abort(msg : String) -> T {\n  println(msg)\n  panic_impl()\n}\n\n///|\nfn[T] panic_impl() -> T = \"%panic\"\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Evaluates an expression and discards its result. This is useful when you want\n/// to execute an expression for its side effects but don't care about its return\n/// value, or when you want to explicitly indicate that a value is intentionally\n/// unused.\n///\n/// Parameters:\n///\n/// * `value` : The value to be ignored. Can be of any type.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 42\n///   ignore(x) // Explicitly ignore the value\n///   let mut sum = 0\n///   ignore([1, 2, 3].iter().each(x => sum = sum + x)) // Ignore the Unit return value of each()\n/// }\n/// ```\npub fn[T] ignore(t : T) -> Unit = \"%ignore\"\n\n///|\n/// Tests if two values are physically equal (i.e., point to the same memory\n/// location). Unlike structural equality testing (`==`), this function checks if\n/// two references point to exactly the same object in memory.\n///\n/// Parameters:\n///\n/// * `first` : The first value to compare.\n/// * `second` : The second value to compare.\n/// * `T` : The type parameter representing the type of values being compared.\n///\n/// Returns `true` if both values refer to the same object in memory, `false`\n/// otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr1 = [1, 2, 3]\n///   let arr2 = arr1\n///   let arr3 = [1, 2, 3]\n///   inspect(physical_equal(arr1, arr2), content=\"true\") // Same object\n///   inspect(physical_equal(arr1, arr3), content=\"false\") // Different objects with same content\n/// }\n/// ```\npub fn[T] physical_equal(a : T, b : T) -> Bool = \"%refeq\"\n\n///|\n#callsite(autofill(loc))\npub fn[T] abort(string : String, loc~ : SourceLoc) -> T {\n  @abort.abort(\n    (\n      $|\\{string}\n      $|  at \\{loc}\n      $|\n    ),\n  )\n}\n\n///|\npub fn[T] panic() -> T = \"%panic\"\n\n// Bool primitive ops\n\n///|\n/// Performs logical negation on a boolean value.\n///\n/// Parameters:\n///\n/// * `value` : The boolean value to negate.\n///\n/// Returns the logical NOT of the input value: `true` if the input is `false`,\n/// and `false` if the input is `true`.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(not(true), content=\"false\")\n///   inspect(not(false), content=\"true\")\n/// }\n/// ```\npub fn not(x : Bool) -> Bool = \"%bool_not\"\n\n///|\n/// Compares two boolean values for equality.\n///\n/// Parameters:\n///\n/// * `self` : The first boolean value to compare.\n/// * `other` : The second boolean value to compare.\n///\n/// Returns `true` if both boolean values are equal (either both `true` or both\n/// `false`), `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(true == true, content=\"true\")\n///   inspect(false == true, content=\"false\")\n///   inspect(true == false, content=\"false\")\n///   inspect(false == false, content=\"true\")\n/// }\n/// ```\npub impl Eq for Bool with equal(self : Bool, other : Bool) -> Bool = \"%bool_eq\"\n\n///|\n/// Compares two boolean values and returns their relative order. This is a\n/// deprecated method and users should use `compare` instead.\n///\n/// Parameters:\n///\n/// * `self` : The first boolean value to compare.\n/// * `other` : The second boolean value to compare against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other` (i.e., `self` is `false`\n/// and `other` is `true`)\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other` (i.e., `self` is `true`\n/// and `other` is `false`)\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let t = true\n///   let f = false\n///   // This usage is deprecated, use compare() instead\n///   inspect(t.compare(f), content=\"1\")\n///   inspect(f.compare(t), content=\"-1\")\n///   inspect(t.compare(t), content=\"0\")\n/// }\n/// ```\n///\n#deprecated(\"Use `compare` instead\")\n#coverage.skip\npub fn Bool::op_compare(self : Bool, other : Bool) -> Int = \"%bool_compare\"\n\n///|\n/// Compares two boolean values and returns their relative order. The comparison\n/// follows the rule that `false` is less than `true`.\n///\n/// Parameters:\n///\n/// * `self` : The first boolean value to compare.\n/// * `other` : The second boolean value to compare against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is `false` and `other` is `true`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is `true` and `other` is `false`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(true.compare(false), content=\"1\") // true > false\n///   inspect(false.compare(true), content=\"-1\") // false < true\n///   inspect(true.compare(true), content=\"0\") // true = true\n/// }\n/// ```\npub impl Compare for Bool with compare(self, other) = \"%bool_compare\"\n\n///|\n/// Returns the default value for the `Bool` type, which is `false`.\n///\n/// Returns a `Bool` value that represents the default state of a boolean value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let b : Bool = Bool::default()\n///   inspect(b, content=\"false\")\n/// }\n/// ```\npub impl Default for Bool with default() = \"%bool_default\"\n\n// int32 primitive ops\n\n///|\n/// Performs arithmetic negation on an integer value, returning its additive\n/// inverse.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to negate.\n///\n/// Returns the negation of the input value. For all inputs except\n/// `Int::min_value()`, returns the value with opposite sign. When the input is\n/// `Int::min_value()`, returns `Int::min_value()` due to two's complement\n/// representation.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(-42, content=\"-42\")\n///   inspect(42, content=\"42\")\n///   inspect(2147483647, content=\"2147483647\") // negating near min value\n/// }\n/// ```\npub impl Neg for Int with neg(self) = \"%i32_neg\"\n\n///|\n/// Adds two 32-bit signed integers. Performs two's complement arithmetic, which\n/// means the operation will wrap around if the result exceeds the range of a\n/// 32-bit integer.\n///\n/// Parameters:\n///\n/// * `self` : The first integer operand.\n/// * `other` : The second integer operand.\n///\n/// Returns a new integer that is the sum of the two operands. If the\n/// mathematical sum exceeds the range of a 32-bit integer (-2,147,483,648 to\n/// 2,147,483,647), the result wraps around according to two's complement rules.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(42 + 1, content=\"43\")\n///   inspect(2147483647 + 1, content=\"-2147483648\") // Overflow wraps around to minimum value\n/// }\n/// ```\npub impl Add for Int with add(self, other) = \"%i32_add\"\n\n///|\n/// Performs subtraction between two 32-bit integers, following standard two's\n/// complement arithmetic rules. When the result overflows or underflows, it\n/// wraps around within the 32-bit integer range.\n///\n/// Parameters:\n///\n/// * `self` : The minuend (the number being subtracted from).\n/// * `other` : The subtrahend (the number to subtract).\n///\n/// Returns the difference between `self` and `other`.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 42\n///   let b = 10\n///   inspect(a - b, content=\"32\")\n///   let max = 2147483647 // Int maximum value\n///   inspect(max - -1, content=\"-2147483648\") // Overflow case\n/// }\n/// ```\npub impl Sub for Int with sub(self, other) = \"%i32_sub\"\n\n///|\n/// Multiplies two 32-bit integers. This is the implementation of the `*`\n/// operator for `Int`.\n///\n/// Parameters:\n///\n/// * `self` : The first integer operand.\n/// * `other` : The second integer operand.\n///\n/// Returns the product of the two integers. If the result overflows the range of\n/// `Int`, it wraps around according to two's complement arithmetic.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(42 * 2, content=\"84\")\n///   inspect(-10 * 3, content=\"-30\")\n///   let max = 2147483647 // Int.max_value\n///   inspect(max * 2, content=\"-2\") // Overflow wraps around\n/// }\n/// ```\npub impl Mul for Int with mul(self, other) = \"%i32_mul\"\n\n///|\n/// Performs integer division between two 32-bit integers. The result is\n/// truncated towards zero (rounds down for positive numbers and up for negative\n/// numbers).\n///\n/// Parameters:\n///\n/// * `dividend` : The first integer operand to be divided.\n/// * `divisor` : The second integer operand that divides the dividend.\n///\n/// Returns the quotient of the division operation.\n///\n/// Throws a panic if `divisor` is zero.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(10 / 3, content=\"3\") // truncates towards zero\n///   inspect(-10 / 3, content=\"-3\")\n///   inspect(10 / -3, content=\"-3\")\n/// }\n/// ```\npub impl Div for Int with div(self, other) = \"%i32_div\"\n\n///|\n/// Calculates the remainder of dividing one integer by another. The result\n/// follows the formula `dividend - (dividend / divisor) * divisor`, maintaining\n/// the same sign as the dividend.\n///\n/// Parameters:\n///\n/// * `self` : The dividend (the number being divided).\n/// * `other` : The divisor (the number to divide by).\n///\n/// Returns the remainder of the division. If `other` is 0, the behavior is\n/// undefined.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(7 % 3, content=\"1\")\n///   inspect(-7 % 3, content=\"-1\")\n///   inspect(7 % -3, content=\"1\")\n/// }\n/// ```\npub impl Mod for Int with mod(self, other) = \"%i32_mod\"\n\n///|\n/// Performs a bitwise NOT operation on a 32-bit integer. Flips each bit in the\n/// integer's binary representation (0 becomes 1 and 1 becomes 0).\n///\n/// Parameters:\n///\n/// * `value` : The 32-bit integer on which to perform the bitwise NOT operation.\n///\n/// Returns a new integer with all bits flipped from the input value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = -1 // All bits are 1\n///   let b = 0 // All bits are 0\n///   inspect(a.lnot(), content=\"0\")\n///   inspect(b.lnot(), content=\"-1\")\n/// }\n/// ```\npub fn Int::lnot(self : Int) -> Int = \"%i32_lnot\"\n\n///|\n/// Performs a bitwise AND operation between two 32-bit integers. Each bit in the\n/// result is set to 1 only if the corresponding bits in both operands are 1.\n///\n/// Parameters:\n///\n/// * `self` : The first 32-bit integer operand.\n/// * `other` : The second 32-bit integer operand.\n///\n/// Returns the result of the bitwise AND operation. The resulting value has a\n/// bit set to 1 at each position where both input integers have a bit set to 1.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0xF0 // 11110000\n///   let y = 0xAA // 10101010\n///   inspect(x & y, content=\"160\") // 10100000 = 160\n/// }\n/// ```\npub impl BitAnd for Int with land(self : Int, other : Int) -> Int = \"%i32_land\"\n\n///|\n/// Performs a bitwise OR operation between two 32-bit integers. For each bit\n/// position, the result is 1 if at least one of the corresponding bits in either\n/// operand is 1.\n///\n/// Parameters:\n///\n/// * `self` : The first integer operand.\n/// * `other` : The second integer operand.\n///\n/// Returns a new integer where each bit is set to 1 if at least one of the\n/// corresponding bits in either operand is 1, and 0 otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0xF0F0 // 1111_0000_1111_0000\n///   let y = 0x0F0F // 0000_1111_0000_1111\n///   inspect(x | y, content=\"65535\") // 1111_1111_1111_1111 = 65535\n/// }\n/// ```\npub impl BitOr for Int with lor(self : Int, other : Int) -> Int = \"%i32_lor\"\n\n///|\n/// Performs a bitwise XOR operation between two integers.\n///\n/// Parameters:\n///\n/// * `self` : The first integer operand.\n/// * `other` : The second integer operand.\n///\n/// Returns a new integer where each bit is set to 1 if the corresponding bits in\n/// the operands are different, and 0 if they are the same.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0xF0F0 // 1111_0000_1111_0000\n///   let y = 0x0F0F // 0000_1111_0000_1111\n///   inspect(x ^ y, content=\"65535\") // 1111_1111_1111_1111\n///   inspect(x ^ x, content=\"0\") // XOR with self gives 0\n/// }\n/// ```\npub impl BitXOr for Int with lxor(self : Int, other : Int) -> Int = \"%i32_lxor\"\n\n///|\n/// Performs a left shift operation on a 32-bit integer. Shifts each bit in the\n/// integer to the left by the specified number of positions, filling the\n/// rightmost positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift. Must be a non-negative value\n/// less than 32. Values outside this range will be masked with `& 31`.\n///\n/// Returns a new integer with bits shifted left by the specified number of\n/// positions. For each position shifted, the rightmost bit is filled with 0, and\n/// the leftmost bit is discarded.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 1\n///   inspect(x << 3, content=\"8\") // Binary: 1 -> 1000\n///   let y = -4\n///   inspect(y << 2, content=\"-16\") // Binary: 100 -> 10000\n/// }\n/// ```\npub impl Shl for Int with shl(self, other) = \"%i32_shl\"\n\n///|\n/// Performs an arithmetic right shift operation on an integer value. Shifts the\n/// bits of the first operand to the right by the number of positions specified\n/// by the second operand. The sign bit is preserved and copied to the leftmost\n/// positions.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift the bits to the right. Must be\n/// non-negative.\n///\n/// Returns an integer representing the result of the arithmetic right shift\n/// operation.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = -16\n///   inspect(n >> 2, content=\"-4\") // Sign bit is preserved during shift\n///   let p = 16\n///   inspect(p >> 2, content=\"4\") // Regular right shift for positive numbers\n/// }\n/// ```\npub impl Shr for Int with shr(self, other) = \"%i32_shr\"\n\n///|\n/// Performs a left shift operation on a 32-bit integer. Shifts each bit in the\n/// integer to the left by the specified number of positions, filling the vacated\n/// bit positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift the bits to the left.\n///\n/// Returns an integer containing the result of shifting `self` left by `shift`\n/// positions.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 1\n///   inspect(x << 3, content=\"8\") // Binary: 1 -> 1000\n///   let y = 42\n///   inspect(y << 2, content=\"168\") // Binary: 101010 -> 10101000\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn Int::lsl(self : Int, other : Int) -> Int = \"%i32_shl\"\n\n///|\n/// Performs a left shift operation on a 32-bit integer. Shifts the bits of the\n/// first operand to the left by the specified number of positions. The rightmost\n/// positions are filled with zeros.\n///\n/// Parameters:\n///\n/// * `value` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift left. Must be non-negative and\n/// less than 32.\n///\n/// Returns a new integer value after performing the left shift operation. The\n/// value is equal to multiplying the input by 2 raised to the power of the shift\n/// count.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 1\n///   inspect(x << 3, content=\"8\") // Equivalent to x << 3\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn Int::shl(self : Int, other : Int) -> Int = \"%i32_shl\"\n\n///|\n/// Performs a logical right shift operation on a signed 32-bit integer. In a\n/// logical right shift, zeros are shifted in from the left, regardless of the\n/// sign bit. This function is DEPRECATED and users should use `UInt` type with\n/// the infix operator `>>` instead.\n///\n/// Parameters:\n///\n/// * `self` : The signed 32-bit integer value to be shifted.\n/// * `shift` : The number of positions to shift right. Must be non-negative.\n///\n/// Returns a signed 32-bit integer containing the same bits as if the input were\n/// treated as an unsigned integer and shifted right logically.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = -4 // Binary: 11111...11100\n///   let unsigned = x.reinterpret_as_uint() // Convert to UInt first\n///   inspect(unsigned >> 1, content=\"2147483646\") // Using the recommended operator\n/// }\n/// ```\n///\n#deprecated(\"Use UInt type and infix operator `>>` instead\")\n#coverage.skip\npub fn Int::lsr(self : Int, other : Int) -> Int {\n  (self.reinterpret_as_uint() >> other).reinterpret_as_int()\n}\n\n///|\n/// Performs an arithmetic right shift operation on a 32-bit integer value,\n/// preserving the sign bit by replicating it into the positions vacated by the\n/// shift. This is a deprecated function; use the infix operator `>>` instead.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift right. Must be non-negative.\n///\n/// Returns a new integer value that is the result of arithmetically shifting\n/// `self` right by `shift` positions.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = -16\n///   inspect(x >> 2, content=\"-4\") // Right shift preserves sign bit\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn Int::asr(self : Int, other : Int) -> Int = \"%i32_shr\"\n\n///|\n/// Performs an arithmetic right shift operation on a 32-bit integer by the\n/// specified number of positions. The operation preserves the sign bit,\n/// replicating it into the positions vacated by the shift.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift right.\n///\n/// Returns a new integer representing the result of shifting `self` right by\n/// `shift` positions.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = -1024\n///   inspect(n >> 3, content=\"-128\") // Preserves sign bit during right shift\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn Int::shr(self : Int, other : Int) -> Int = \"%i32_shr\"\n\n///|\n/// Counts the number of consecutive zero bits at the least significant end of\n/// the integer's binary representation.\n///\n/// Parameters:\n///\n/// * `self` : The integer value whose trailing zeros are to be counted.\n///\n/// Returns the number of trailing zero bits (0 to 32). For example, returns 0 if\n/// the value is odd (least significant bit is 1), returns 32 if the value is 0\n/// (all bits are zeros).\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0\n///   inspect(x.ctz(), content=\"32\") // All bits are zero\n///   let y = 1\n///   inspect(y.ctz(), content=\"0\") // No trailing zeros\n///   let z = 16\n///   inspect(z.ctz(), content=\"4\") // Binary: ...10000\n/// }\n/// ```\npub fn Int::ctz(self : Int) -> Int = \"%i32_ctz\"\n\n///|\npub fn Int::clz(self : Int) -> Int = \"%i32_clz\"\n\n///|\n/// Counts the number of set bits (1s) in the binary representation of a 32-bit\n/// integer.\n///\n/// Parameters:\n///\n/// * `self` : The 32-bit integer whose bits are to be counted.\n///\n/// Returns the number of bits set to 1 in the binary representation of the input\n/// integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0b1011 // Binary: 1011 (3 bits set)\n///   inspect(x.popcnt(), content=\"3\")\n///   let y = -1 // All bits set in two's complement\n///   inspect(y.popcnt(), content=\"32\")\n/// }\n/// ```\npub fn Int::popcnt(self : Int) -> Int = \"%i32_popcnt\"\n\n///|\n/// Compares two integers for equality.\n///\n/// Parameters:\n///\n/// * `self` : The first integer to compare.\n/// * `other` : The second integer to compare.\n///\n/// Returns `true` if both integers have the same value, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(42 == 42, content=\"true\")\n///   inspect(42 == -42, content=\"false\")\n/// }\n/// ```\npub impl Eq for Int with equal(self : Int, other : Int) -> Bool = \"%i32_eq\"\n\n///|\n/// Compares two integers for inequality.\n///\n/// Parameters:\n///\n/// * `self` : The first integer to compare.\n/// * `other` : The second integer to compare.\n///\n/// Returns `true` if the integers have different values, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(42 != 42, content=\"false\")\n///   inspect(42 != -42, content=\"true\")\n/// }\n/// ```\npub impl Eq for Int with not_equal(self : Int, other : Int) -> Bool = \"%i32_ne\"\n\n///|\n/// Compares two integers and returns their relative order.\n///\n/// Parameters:\n///\n/// * `self` : The first integer to compare.\n/// * `other` : The second integer to compare against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 42\n///   let b = 24\n///   inspect(a.compare(b), content=\"1\") // 42 > 24\n///   inspect(b.compare(a), content=\"-1\") // 24 < 42\n///   inspect(a.compare(a), content=\"0\") // 42 = 42\n/// }\n/// ```\npub impl Compare for Int with compare(self, other) = \"%i32_compare\"\n\n///|\npub impl Compare for Int with op_lt(x, y) = \"%i32.lt\"\n\n///|\npub impl Compare for Int with op_le(x, y) = \"%i32.le\"\n\n///|\npub impl Compare for Int with op_gt(x, y) = \"%i32.gt\"\n\n///|\npub impl Compare for Int with op_ge(x, y) = \"%i32.ge\"\n\n///|\npub fn Int::is_pos(self : Int) -> Bool = \"%i32_is_pos\"\n\n///|\n/// Tests whether an integer is negative.\n///\n/// Parameters:\n///\n/// * `self` : The integer to test.\n///\n/// Returns `true` if the integer is negative, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let neg = -42\n///   let zero = 0\n///   let pos = 42\n///   inspect(neg.is_neg(), content=\"true\")\n///   inspect(zero.is_neg(), content=\"false\")\n///   inspect(pos.is_neg(), content=\"false\")\n/// }\n/// ```\npub fn Int::is_neg(self : Int) -> Bool = \"%i32_is_neg\"\n\n///|\npub fn Int::is_non_pos(self : Int) -> Bool = \"%i32_is_non_pos\"\n\n///|\npub fn Int::is_non_neg(self : Int) -> Bool = \"%i32_is_non_neg\"\n\n///|\n/// Returns the default value for integers, which is 0.\n///\n/// Returns an integer value of 0.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x : Int = Int::default()\n///   inspect(x, content=\"0\")\n/// }\n/// ```\npub impl Default for Int with default() = \"%i32_default\"\n\n///|\n/// Converts a 32-bit integer to a double-precision floating-point number. The\n/// conversion preserves the exact value since all integers in the range of `Int`\n/// can be represented exactly as `Double` values.\n///\n/// Parameters:\n///\n/// * `self` : The 32-bit integer to be converted.\n///\n/// Returns a double-precision floating-point number that represents the same\n/// numerical value as the input integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 42\n///   inspect(n.to_double(), content=\"42\")\n///   let neg = -42\n///   inspect(neg.to_double(), content=\"-42\")\n/// }\n/// ```\npub fn Int::to_double(self : Int) -> Double = \"%i32_to_f64\"\n\n///|\n/// Converts a double-precision floating-point number to an unsigned 32-bit\n/// integer by truncating the decimal part. When the input is NaN or negative,\n/// returns 0. When the input exceeds the maximum value of UInt (4294967295),\n/// returns 4294967295.\n///\n/// Parameters:\n///\n/// * `value` : The double-precision floating-point number to be converted.\n///\n/// Returns an unsigned 32-bit integer representing the truncated value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(UInt::trunc_double(42.75), content=\"42\")\n/// }\n/// ```\npub fn UInt::trunc_double(val : Double) -> UInt = \"%f64.to_u32\"\n\n///|\n/// reinterpret the signed int as unsigned int, when the value is\n/// non-negative, i.e, 0..=2^31-1, the value is the same. When the\n/// value is negative, it turns into a large number,\n/// for example, -1 turns into 2^32-1\npub fn Int::reinterpret_as_uint(self : Int) -> UInt = \"%i32.to_u32_reinterpret\"\n\n///|\n/// Reinterprets a signed 32-bit integer as an unsigned 32-bit integer. For\n/// numbers within the range \\[0, 2^31-1], the value remains the same. For\n/// negative numbers, they are reinterpreted as large positive numbers in the\n/// range \\[2^31, 2^32-1].\n///\n/// Parameters:\n///\n/// * `value` : The signed 32-bit integer to be reinterpreted.\n///\n/// Returns an unsigned 32-bit integer that has the same bit pattern as the\n/// input.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let pos = 42\n///   let neg = -1\n///   inspect(pos.reinterpret_as_uint(), content=\"42\")\n///   inspect(neg.reinterpret_as_uint(), content=\"4294967295\") // 2^32 - 1\n/// }\n/// ```\n///\n#deprecated(\"Use `reinterpret_as_uint` instead\")\n#coverage.skip\npub fn Int::to_uint(self : Int) -> UInt = \"%i32.to_u32_reinterpret\"\n// Double primitive ops\n\n///|\n/// Converts a 32-bit signed integer to an unsigned 64-bit integer by first\n/// converting it to a signed 64-bit integer and then reinterpreting the bits as\n/// an unsigned value.\n///\n/// Parameters:\n///\n/// * `value` : The 32-bit signed integer to be converted.\n///\n/// Returns an unsigned 64-bit integer representing the same bit pattern as the\n/// input value when extended to 64 bits.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let pos = 42\n///   inspect(pos.to_uint64(), content=\"42\")\n///   let neg = -1\n///   inspect(neg.to_uint64(), content=\"18446744073709551615\") // 2^64 - 1\n/// }\n/// ```\npub fn Int::to_uint64(self : Int) -> UInt64 {\n  self.to_int64().reinterpret_as_uint64()\n}\n\n///|\n/// Negates a double-precision floating-point number. For non-NaN inputs, changes\n/// the sign of the number. For NaN inputs, returns NaN.\n///\n/// Parameters:\n///\n/// * `number` : The double-precision floating-point number to negate.\n///\n/// Returns a new double-precision floating-point number that is the negation of\n/// the input number.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(-42.0, content=\"-42\")\n///   inspect(42.0, content=\"42\")\n///   inspect(-(0.0 / 0.0), content=\"NaN\") // Negating NaN returns NaN\n/// }\n/// ```\npub impl Neg for Double with neg(self) = \"%f64_neg\"\n\n///|\n/// Adds two double-precision floating-point numbers together following IEEE 754\n/// standards.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point number.\n/// * `other` : The second double-precision floating-point number to add.\n///\n/// Returns the sum of the two numbers. Special cases follow IEEE 754 rules:\n///\n/// * If either operand is NaN, returns NaN\n/// * If adding + and -, returns NaN\n/// * If adding  with any finite number, returns \n/// * If adding +0.0 and -0.0, returns +0.0\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(2.5 + 3.7, content=\"6.2\")\n///   inspect(1.0 / 0.0 + -1.0 / 0.0, content=\"NaN\") // Infinity + -Infinity = NaN\n/// }\n/// ```\npub impl Add for Double with add(self, other) = \"%f64_add\"\n\n///|\n/// Performs subtraction between two double-precision floating-point numbers.\n///\n/// Parameters:\n///\n/// * `self` : The first operand (minuend).\n/// * `other` : The second operand (subtrahend).\n///\n/// Returns the difference between the two numbers according to IEEE 754\n/// double-precision arithmetic rules.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 5.0\n///   let b = 3.0\n///   inspect(a - b, content=\"2\")\n///   inspect(0.0 / 0.0 - 1.0, content=\"NaN\") // NaN - anything = NaN\n/// }\n/// ```\npub impl Sub for Double with sub(self, other) = \"%f64_sub\"\n\n///|\n/// Multiplies two double-precision floating-point numbers. This is the\n/// implementation of the `*` operator for `Double` type.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point operand.\n/// * `other` : The second double-precision floating-point operand.\n///\n/// Returns a new double-precision floating-point number representing the product\n/// of the two operands. Special cases follow IEEE 754 standard:\n///\n/// * If either operand is NaN, returns NaN\n/// * If one operand is infinity and the other is zero, returns NaN\n/// * If one operand is infinity and the other is a non-zero finite number,\n/// returns infinity with the appropriate sign\n/// * If both operands are infinity, returns infinity with the appropriate sign\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(2.5 * 2.0, content=\"5\")\n///   inspect(-2.0 * 3.0, content=\"-6\")\n///   let nan = 0.0 / 0.0 // NaN\n///   inspect(nan * 1.0, content=\"NaN\")\n/// }\n/// ```\npub impl Mul for Double with mul(self, other) = \"%f64_mul\"\n\n///|\n/// Performs division between two double-precision floating-point numbers.\n/// Follows IEEE 754 standard for floating-point arithmetic, including handling\n/// of special cases like division by zero (returns infinity) and operations\n/// involving NaN.\n///\n/// Parameters:\n///\n/// * `self` : The dividend (numerator) in the division operation.\n/// * `other` : The divisor (denominator) in the division operation.\n///\n/// Returns the result of dividing `self` by `other`. Special cases follow IEEE\n/// 754:\n///\n/// * Division by zero returns positive or negative infinity based on the\n/// dividend's sign\n/// * Operations involving NaN return NaN\n/// * Division of infinity by infinity returns NaN\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(6.0 / 2.0, content=\"3\")\n///   inspect(-6.0 / 2.0, content=\"-3\")\n///   inspect(1.0 / 0.0, content=\"Infinity\")\n/// }\n/// ```\npub impl Div for Double with div(self, other) = \"%f64_div\"\n\n///|\n/// Calculates the square root of a double-precision floating-point number. For\n/// non-negative numbers, returns the positive square root. For negative numbers\n/// or NaN, returns NaN.\n///\n/// Parameters:\n///\n/// * `self` : The double-precision floating-point number whose square root is to\n/// be calculated.\n///\n/// Returns the square root of the input number, or NaN if the input is negative\n/// or NaN.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(4.0.sqrt(), content=\"2\")\n///   inspect(0.0.sqrt(), content=\"0\")\n///   inspect((-1.0).sqrt(), content=\"NaN\")\n/// }\n/// ```\npub fn Double::sqrt(self : Double) -> Double = \"%f64_sqrt\"\n\n///|\n/// Compares two double-precision floating-point numbers for equality following\n/// IEEE 754 rules. Returns `true` if both numbers are equal, including when both\n/// are `NaN`. Note that this differs from the standard IEEE 754 behavior where\n/// `NaN` is not equal to any value, including itself.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point number to compare.\n/// * `other` : The second double-precision floating-point number to compare.\n///\n/// Returns `true` if both numbers are equal, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 3.14\n///   let b = 3.14\n///   let c = 2.718\n///   inspect(a == b, content=\"true\")\n///   inspect(a == c, content=\"false\")\n///   let nan = 0.0 / 0.0 // NaN\n///   inspect(nan == nan, content=\"false\") // NaN != NaN\n/// }\n/// ```\npub impl Eq for Double with equal(self : Double, other : Double) -> Bool = \"%f64_eq\"\n\n///|\n/// Compares two double-precision floating-point numbers for inequality following\n/// IEEE 754 rules. Returns `true` if the numbers are not equal.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point number to compare.\n/// * `other` : The second double-precision floating-point number to compare.\n///\n/// Returns `true` if the numbers are not equal, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 3.14\n///   let b = 3.14\n///   let c = 2.718\n///   inspect(a != b, content=\"false\")\n///   inspect(a != c, content=\"true\")\n///   let nan = 0.0 / 0.0 // NaN\n///   inspect(nan != nan, content=\"true\") // NaN != NaN is true\n/// }\n/// ```\npub impl Eq for Double with not_equal(self : Double, other : Double) -> Bool = \"%f64_ne\"\n\n///|\n#deprecated(\"Use `a != b` instead\")\n#doc(hidden)\npub fn Double::op_neq(self : Double, other : Double) -> Bool = \"%f64_ne\"\n\n///|\n/// Compares two double-precision floating-point numbers and returns their\n/// relative order. Follows IEEE 754 rules for floating-point comparisons,\n/// including handling of special values like NaN.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point number to compare.\n/// * `other` : The second double-precision floating-point number to compare\n/// against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n/// * If either value is NaN, returns an implementation-defined value that is\n/// consistent with total ordering\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 3.14\n///   let b = 2.718\n///   inspect(a.compare(b), content=\"1\") // 3.14 > 2.718\n///   inspect(b.compare(a), content=\"-1\") // 2.718 < 3.14\n///   inspect(a.compare(a), content=\"0\") // 3.14 = 3.14\n/// }\n/// ```\npub impl Compare for Double with compare(self, other) = \"%f64_compare\"\n\n///|\npub impl Compare for Double with op_lt(x, y) = \"%f64.lt\"\n\n///|\npub impl Compare for Double with op_le(x, y) = \"%f64.le\"\n\n///|\npub impl Compare for Double with op_gt(x, y) = \"%f64.gt\"\n\n///|\npub impl Compare for Double with op_ge(x, y) = \"%f64.ge\"\n\n///|\n/// Returns the default value for double-precision floating-point numbers (0.0).\n///\n/// Returns a `Double` value initialized to 0.0.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(Double::default(), content=\"0\")\n/// }\n/// ```\npub impl Default for Double with default() = \"%f64_default\"\n\n///|\n/// Converts an unsigned 32-bit integer to a double-precision floating-point\n/// number. Since the range of unsigned 32-bit integers is smaller than what can\n/// be precisely represented by a double-precision floating-point number, this\n/// conversion is guaranteed to be exact.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned 32-bit integer to be converted.\n///\n/// Returns a double-precision floating-point number that exactly represents the\n/// input value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 42U\n///   inspect(Double::convert_uint(n), content=\"42\")\n///   let max = 4294967295U // maximum value of UInt\n///   inspect(Double::convert_uint(max), content=\"4294967295\")\n/// }\n/// ```\npub fn Double::convert_uint(val : UInt) -> Double = \"%u32.to_f64\"\n\n// Char primitive ops\n\n///|\n/// Converts a character to its Unicode code point value as an integer.\n///\n/// Parameters:\n///\n/// * `self` : The character to be converted.\n///\n/// Returns an integer representing the Unicode code point value of the\n/// character.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect('A'.to_int(), content=\"65\") // ASCII value of 'A'\n///   inspect(''.to_int(), content=\"12354\") // Unicode code point of ''\n/// }\n/// ```\npub fn Char::to_int(self : Char) -> Int = \"%char_to_int\"\n\n///|\n/// Converts a Unicode character to its unsigned 32-bit integer code point\n/// representation. The character's code point value is first converted to a\n/// signed integer and then reinterpreted as an unsigned integer.\n///\n/// Parameters:\n///\n/// * `character` : The Unicode character to be converted.\n///\n/// Returns an unsigned 32-bit integer representing the character's Unicode code\n/// point.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let c = 'A'\n///   inspect(c.to_uint(), content=\"65\") // ASCII value of 'A'\n///   let emoji = ''\n///   inspect(emoji.to_uint(), content=\"129315\") // Unicode code point U+1F923\n/// }\n/// ```\npub fn Char::to_uint(self : Char) -> UInt {\n  self.to_int().reinterpret_as_uint()\n}\n\n///|\n#deprecated(\"Use `Int::unsafe_to_char` instead, and use `Int::to_char` for safe conversion\")\npub fn Char::from_int(val : Int) -> Char = \"%char_from_int\"\n\n///|\n/// Compares two characters for equality.\n///\n/// Parameters:\n///\n/// * `self` : The first character to compare.\n/// * `other` : The second character to compare.\n///\n/// Returns `true` if both characters represent the same Unicode code point,\n/// `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 'A'\n///   let b = 'A'\n///   let c = 'B'\n///   inspect(a == b, content=\"true\")\n///   inspect(a == c, content=\"false\")\n/// }\n/// ```\npub impl Eq for Char with equal(self : Char, other : Char) -> Bool = \"%char_eq\"\n\n///|\n/// Compares two characters for inequality.\n///\n/// Parameters:\n///\n/// * `self` : The first character to compare.\n/// * `other` : The second character to compare.\n///\n/// Returns `true` if the characters represent different Unicode code points,\n/// `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 'A'\n///   let b = 'A'\n///   let c = 'B'\n///   inspect(a != b, content=\"false\")\n///   inspect(a != c, content=\"true\")\n/// }\n/// ```\npub impl Eq for Char with not_equal(self : Char, other : Char) -> Bool = \"%i32_ne\"\n\n///|\n/// Compares two characters based on their Unicode code points. Returns a\n/// negative value if the first character comes before the second, zero if they\n/// are equal, and a positive value if the first character comes after the\n/// second.\n///\n/// Parameters:\n///\n/// * `self` : The first character to compare.\n/// * `other` : The second character to compare against.\n///\n/// Returns an integer indicating the relative ordering:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect('a'.compare('b'), content=\"-1\")\n///   inspect('b'.compare('a'), content=\"1\")\n///   inspect('a'.compare('a'), content=\"0\")\n/// }\n/// ```\npub impl Compare for Char with compare(self, other) = \"%char_compare\"\n\n///|\npub impl Compare for Char with op_lt(x, y) = \"%i32.lt\"\n\n///|\npub impl Compare for Char with op_le(x, y) = \"%i32.le\"\n\n///|\npub impl Compare for Char with op_gt(x, y) = \"%i32.gt\"\n\n///|\npub impl Compare for Char with op_ge(x, y) = \"%i32.ge\"\n\n///|\n/// Returns the default value for the `Char` type, which is the null character\n/// (`'\\x00'`).\n///\n/// Returns a `Char` value representing the null character.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   assert_true(Char::default().to_string() == \"\\u0000\")\n/// }\n/// ```\npub impl Default for Char with default() = \"%char_default\"\n\n// Bytes primitive ops\n\n///|\n/// Retrieves a byte at the specified index from a byte sequence.\n///\n/// Parameters:\n///\n/// * `bytes` : The byte sequence to access.\n/// * `index` : The position in the byte sequence from which to retrieve the\n/// byte.\n///\n/// Returns a byte value from the specified position in the sequence.\n///\n/// Throws a panic if the index is negative or greater than or equal to the\n/// length of the byte sequence.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x01\\x02\\x03\"\n///   inspect(bytes[1], content=\"b'\\\\x02'\")\n/// }\n/// ```\n#alias(\"_[_]\")\npub fn Bytes::at(self : Bytes, idx : Int) -> Byte = \"%bytes_get\"\n\n///|\n/// Retrieves a byte at the specified index from a byte sequence without\n/// performing bounds checking. This is a low-level operation that should be used\n/// with caution.\n///\n/// Parameters:\n///\n/// * `bytes` : The byte sequence to retrieve the byte from.\n/// * `index` : The position in the byte sequence from which to retrieve the\n/// byte.\n///\n/// Returns a single byte from the specified position in the byte sequence.\n///\n/// Throws a panic if the index is negative or greater than or equal to the\n/// length of the byte sequence.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x01\\x02\\x03\"\n///   inspect(bytes.unsafe_get(1), content=\"b'\\\\x02'\")\n/// }\n/// ```\n///\n#internal(unsafe, \"Panic if index is out of bounds\")\n#doc(hidden)\npub fn Bytes::unsafe_get(self : Bytes, idx : Int) -> Byte = \"%bytes.unsafe_get\"\n\n///|\n/// Returns the number of bytes in a byte sequence.\n///\n/// Parameters:\n///\n/// * `bytes` : The byte sequence whose length is to be determined.\n///\n/// Returns an integer representing the length (number of bytes) of the sequence.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x01\\x02\\x03\"\n///   inspect(bytes.length(), content=\"3\")\n///   let empty = b\"\"\n///   inspect(empty.length(), content=\"0\")\n/// }\n/// ```\npub fn Bytes::length(self : Bytes) -> Int = \"%bytes_length\"\n\n///|\n/// Creates a new byte sequence of the specified length, where each byte is\n/// initialized to the given value. Returns an empty byte sequence if the\n/// length is negative.\n///\n/// Parameters:\n///\n/// * `length` : The length of the byte sequence to create. Must be non-negative.\n/// * `initial_value` : The byte value used to initialize each position in the\n/// sequence.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = Bytes::make(3, b'\\xFF')\n///   inspect(\n///     bytes,\n///     content=(\n///       #|b\"\\xff\\xff\\xff\"\n///     ),\n///   )\n///   let empty = Bytes::make(0, b'\\x00')\n///   inspect(empty, content=\"b\\\"\\\"\")\n/// }\n/// ```\npub fn Bytes::make(len : Int, init : Byte) -> Bytes {\n  if len < 0 {\n    return []\n  }\n  Bytes::unsafe_make(len, init)\n}\n\n///|\nfn Bytes::unsafe_make(len : Int, init : Byte) -> Bytes = \"%bytes_make\"\n\n///|\n/// Creates a new byte sequence filled with zero bytes.\n///\n/// Parameters:\n///\n/// * `length` : The length of the byte sequence to create. Must be a\n/// non-negative integer.\n///\n/// Returns a new byte sequence of the specified length, with all bytes\n/// initialized to zero.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = Bytes::new(3)\n///   inspect(bytes, content=\"b\\\"\\\\x00\\\\x00\\\\x00\\\"\")\n///   let bytes = Bytes::new(0)\n///   inspect(bytes, content=\"b\\\"\\\"\")\n/// }\n/// ```\npub fn Bytes::new(len : Int) -> Bytes {\n  Bytes::make(len, b'\\x00')\n}\n\n///|\n/// Converts a 32-bit signed integer to a byte by taking its least significant 8\n/// bits. Any bits beyond the first 8 bits are truncated.\n///\n/// Parameters:\n///\n/// * `value` : The 32-bit signed integer to be converted. Only the least\n/// significant 8 bits will be used.\n///\n/// Returns a byte containing the least significant 8 bits of the input integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 258 // In binary: 100000010\n///   inspect(n.to_byte(), content=\"b'\\\\x02'\") // Only keeps 00000010\n///   let neg = -1 // In binary: all 1's\n///   inspect(neg.to_byte(), content=\"b'\\\\xFF'\") // Only keeps 11111111\n/// }\n/// ```\npub fn Int::to_byte(self : Int) -> Byte = \"%i32_to_byte\"\n\n///|\npub fn Int::unsafe_to_char(self : Int) -> Char = \"%char_from_int\"\n\n///|\npub fn Int::to_char(self : Int) -> Char? {\n  if self is (0..=0xD7FF) || self is (0xE000..=0x10FFFF) {\n    Some(self.unsafe_to_char())\n  } else {\n    None\n  }\n}\n\n///|\n/// Converts an unsigned 64-bit integer to a byte by truncating it to fit within\n/// the byte range (0 to 255).\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 64-bit integer to be converted.\n///\n/// Returns a byte containing the least significant 8 bits of the input integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 258UL // In binary: 100000010\n///   inspect(n.to_byte(), content=\"b'\\\\x02'\") // Only keeps 00000010\n/// }\n/// ```\npub fn UInt64::to_byte(self : UInt64) -> Byte {\n  self.to_int().to_byte()\n}\n\n// FixedArray primitive ops\n\n///|\n/// Retrieves an element at the specified index from a fixed-size array. This\n/// function implements the array indexing operator `[]`.\n///\n/// Parameters:\n///\n/// * `array` : The fixed-size array to access.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns the element at the specified index.\n///\n/// Panics if the index is out of bounds.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = FixedArray::make(3, 42)\n///   inspect(arr[1], content=\"42\")\n/// }\n/// ```\n#alias(\"_[_]\")\npub fn[T] FixedArray::at(self : FixedArray[T], idx : Int) -> T = \"%fixedarray.get\"\n\n///|\n/// Retrieves an element from a fixed-size array at the specified index without\n/// performing bounds checking. This is an unsafe operation that may cause\n/// undefined behavior if used incorrectly.\n///\n/// Parameters:\n///\n/// * `array` : The fixed-size array to retrieve the element from.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns the element at the specified index in the array.\n///\n/// Throws a panic if the index is out of bounds (negative or greater than or\n/// equal to the array's length).\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = FixedArray::make(3, 42)\n///   inspect(arr.unsafe_get(1), content=\"42\")\n/// }\n/// ```\n///\n#internal(unsafe, \"Panic if index is out of bounds\")\n#doc(hidden)\npub fn[T] FixedArray::unsafe_get(self : FixedArray[T], idx : Int) -> T = \"%fixedarray.unsafe_get\"\n\n///|\n#internal(unsafe, \"Panic if index is out of bounds\")\n#doc(hidden)\npub fn[T] FixedArray::unsafe_set(\n  self : FixedArray[T],\n  idx : Int,\n  val : T,\n) -> Unit = \"%fixedarray.unsafe_set\"\n\n///|\n/// Sets the value at the specified index in a fixed-size array.\n///\n/// Parameters:\n///\n/// * `array` : The fixed-size array to be modified.\n/// * `index` : The index at which to set the value. Must be non-negative and\n/// less than the array's length.\n/// * `value` : The value to be set at the specified index.\n///\n/// Throws a runtime error if the index is out of bounds (less than 0 or greater\n/// than or equal to the array's length).\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = FixedArray::make(3, 0)\n///   arr.set(1, 42)\n///   inspect(arr[1], content=\"42\")\n/// }\n/// ```\n#alias(\"_[_]=_\")\npub fn[T] FixedArray::set(self : FixedArray[T], idx : Int, val : T) -> Unit = \"%fixedarray.set\"\n\n///|\n/// Returns the number of elements in a fixed-size array.\n///\n/// Parameters:\n///\n/// * `array` : The fixed-size array whose length is to be determined.\n///\n/// Returns an integer representing the number of elements in the array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = FixedArray::make(3, 42)\n///   inspect(arr.length(), content=\"3\")\n/// }\n/// ```\npub fn[T] FixedArray::length(self : FixedArray[T]) -> Int = \"%fixedarray.length\"\n\n///|\n/// Creates a new fixed-size array with the specified length, initializing all\n/// elements with the given value.\n///\n/// Parameters:\n///\n/// * `length` : The length of the array to create. Must be non-negative.\n/// * `initial_value` : The value used to initialize all elements in the array.\n///\n/// Returns a new fixed-size array of type `FixedArray[T]` with `length`\n/// elements, where each element is initialized to `initial_value`.\n///\n/// Throws a panic if `length` is negative.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = FixedArray::make(3, 42)\n///   inspect(arr[0], content=\"42\")\n///   inspect(arr.length(), content=\"3\")\n/// }\n/// ```\n/// \n/// WARNING: A common pitfall is creating with the same initial value, for example:\n/// ```mbt check\n/// test {\n///   let two_dimension_array = FixedArray::make(10, FixedArray::make(10, 0))\n///   two_dimension_array[0][5] = 10\n///   assert_eq(two_dimension_array[5][5], 10)\n/// }\n/// ```\n/// This is because all the cells reference to the same object (the FixedArray[Int] in this case). \n/// One should use makei() instead which creates an object for each index.\npub fn[T] FixedArray::make(len : Int, init : T) -> FixedArray[T] = \"%fixedarray.make\"\n\n// String primitive ops\n\n///|\n/// Returns the number of UTF-16 code units in the string. Note that this is not\n/// necessarily equal to the number of Unicode characters (code points) in the\n/// string, as some characters may be represented by multiple UTF-16 code units.\n///\n/// Parameters:\n///\n/// * `string` : The string whose length is to be determined.\n///\n/// Returns the number of UTF-16 code units in the string.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(\"hello\".length(), content=\"5\")\n///   inspect(\"\".length(), content=\"2\") // Emoji uses two UTF-16 code units\n///   inspect(\"\".length(), content=\"0\") // Empty string\n/// }\n/// ```\n#alias(charcode_length, deprecated)\npub fn String::length(self : String) -> Int = \"%string_length\"\n\n///|\n/// Returns the UTF-16 code unit at the given index.\n/// \n/// This method has O(1) complexity.\n/// Panics if the index is out of bounds.\n#alias(\"_[_]\")\n#alias(code_unit_at)\npub fn String::at(self : String, idx : Int) -> UInt16 = \"%string_get\"\n\n///|\n#internal(unsafe, \"Undefined behavior if index is out of bounds.\")\n#doc(hidden)\npub fn String::unsafe_get(self : String, idx : Int) -> UInt16 = \"%string.unsafe_get\"\n\n///|\n/// Returns the UTF-16 code unit at a given position in the string without\n/// performing bounds checking. This is a low-level function that provides direct\n/// access to the internal representation of the string.\n///\n/// Parameters:\n///\n/// * `string` : The string from which to retrieve the code unit.\n/// * `index` : The position of the code unit to retrieve.\n///\n/// Returns the UTF-16 code unit at the specified position as an integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let str = \"BC\"\n///   inspect(str.unsafe_get(0), content=\"66\") // 'B'\n///   inspect(str.unsafe_get(1), content=\"55358\") // First surrogate of \n///   inspect(str.unsafe_get(2), content=\"56611\") // Second surrogate of \n///   inspect(str.unsafe_get(3), content=\"55358\") // First surrogate of \n///   inspect(str.unsafe_get(4), content=\"56611\") // Second surrogate of \n///   inspect(str.unsafe_get(5), content=\"67\") // 'C'\n/// }\n/// ```\n/// TODO: rename to `unsafe_get`\n#internal(unsafe, \"Panic if index is out of bounds.\")\n#doc(hidden)\n#deprecated(\"Use `String::unsafe_get` instead\")\npub fn String::unsafe_charcode_at(self : String, idx : Int) -> Int = \"%string.unsafe_get\"\n\n///|\n/// Concatenates two strings, creating a new string that contains all characters\n/// from the first string followed by all characters from the second string.\n///\n/// Parameters:\n///\n/// * `self` : The first string to concatenate.\n/// * `other` : The second string to concatenate.\n///\n/// Returns a new string containing the concatenation of both input strings.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hello = \"Hello\"\n///   let world = \" World!\"\n///   inspect(hello + world, content=\"Hello World!\")\n///   inspect(\"\" + \"abc\", content=\"abc\") // concatenating with empty string\n/// }\n/// ```\npub impl Add for String with add(self, other) = \"%string_add\"\n\n///|\n/// Tests whether two strings are equal by comparing their characters.\n///\n/// Parameters:\n///\n/// * `self` : The first string to compare.\n/// * `other` : The second string to compare.\n///\n/// Returns `true` if both strings contain exactly the same sequence of\n/// characters, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let str1 = \"hello\"\n///   let str2 = \"hello\"\n///   let str3 = \"world\"\n///   inspect(str1 == str2, content=\"true\")\n///   inspect(str1 == str3, content=\"false\")\n/// }\n/// ```\npub impl Eq for String with equal(self : String, other : String) -> Bool = \"%string_eq\"\n\n///|\n/// Returns the string itself without any modifications. This method is primarily\n/// used to implement the `Show` trait, which requires a `to_string` function.\n///\n/// Parameters:\n///\n/// * `string` : The string value to be returned.\n///\n/// Returns the same string that was passed in.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let s = \"hello\"\n///   inspect(s.to_string(), content=\"hello\")\n/// }\n/// ```\npub fn String::to_string(self : String) -> String = \"%string_to_string\"\n\n// For internal use only\n\n///|\npriv type UnsafeMaybeUninit[_]\n\n///|\n/// Converts a byte value to a 32-bit signed integer. The resulting integer will\n/// have the same binary representation as the byte value, preserving the\n/// numerical value in the range \\[0, 255].\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted to an integer.\n///\n/// Returns a 32-bit signed integer representing the same numerical value as the\n/// input byte.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let b = b'\\xFF' // byte with value 255\n///   inspect(b.to_int(), content=\"255\")\n///   let zero = b'\\x00'\n///   inspect(zero.to_int(), content=\"0\")\n/// }\n/// ```\npub fn Byte::to_int(self : Byte) -> Int = \"%byte_to_int\"\n\n///|\n/// Converts a byte value to a character.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted.\n///\n/// Returns the character corresponding to the byte value.\npub fn Byte::to_char(self : Byte) -> Char {\n  self.to_int().unsafe_to_char()\n}\n\n///|\n/// Converts a byte value to a 64-bit signed integer by first converting it to a\n/// 32-bit integer and then extending it to a 64-bit integer.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted.\n///\n/// Returns a 64-bit signed integer representing the same numerical value as the\n/// input byte.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let b = b'\\xFF'\n///   inspect(b.to_int64(), content=\"255\")\n/// }\n/// ```\npub fn Byte::to_int64(self : Byte) -> Int64 {\n  self.to_int().to_int64()\n}\n\n///|\n/// reinterpret the unsigned int as signed int\n/// For number within the range of 0..=2^31-1,\n/// the value is the same. For number within the range of 2^31..=2^32-1,\n/// the value is negative\npub fn UInt::reinterpret_as_int(self : UInt) -> Int = \"%u32.to_i32_reinterpret\"\n\n///|\n/// Reinterprets an unsigned 32-bit integer as a signed 32-bit integer. For\n/// values within the range of 0 to 2^31-1, the value remains the same. For\n/// values within the range of 2^31 to 2^32-1, the value becomes negative due to\n/// two's complement representation.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be reinterpreted.\n///\n/// Returns a signed 32-bit integer that has the same bit pattern as the input\n/// unsigned integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 42U\n///   inspect(a.reinterpret_as_int(), content=\"42\")\n///   let b = 4294967295U // maximum value of UInt (2^32 - 1)\n///   inspect(b.reinterpret_as_int(), content=\"-1\") // becomes -1 when reinterpreted as Int\n/// }\n/// ```\n///\n#deprecated(\"Use `reinterpret_as_int` instead\")\n#coverage.skip\npub fn UInt::to_int(self : UInt) -> Int = \"%u32.to_i32_reinterpret\"\n\n///|\n/// Performs addition between two unsigned 32-bit integers. If the result\n/// overflows, it wraps around according to the rules of modular arithmetic\n/// (2^32).\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer operand.\n/// * `other` : The second unsigned 32-bit integer operand to be added.\n///\n/// Returns the sum of the two unsigned integers, wrapped around if necessary.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 42U\n///   let b = 100U\n///   inspect(a + b, content=\"142\")\n///\n///   // Demonstrate overflow behavior\n///   let max = 4294967295U // UInt::max_value\n///   inspect(max + 1U, content=\"0\")\n/// }\n/// ```\npub impl Add for UInt with add(self, other) = \"%u32.add\"\n\n///|\n/// Performs subtraction between two unsigned 32-bit integers. When the result\n/// would be negative, the function wraps around using modular arithmetic (2^32).\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer (minuend).\n/// * `other` : The second unsigned 32-bit integer to subtract from the first\n/// (subtrahend).\n///\n/// Returns a new unsigned 32-bit integer representing the difference between the\n/// two numbers. If the result would be negative, it wraps around to a positive\n/// number by adding 2^32 repeatedly until the result is in range.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 5U\n///   let b = 3U\n///   inspect(a - b, content=\"2\")\n///   let c = 3U\n///   let d = 5U\n///   inspect(c - d, content=\"4294967294\") // wraps around to 2^32 - 2\n/// }\n/// ```\npub impl Sub for UInt with sub(self, other) = \"%u32.sub\"\n\n///|\n/// Performs multiplication between two unsigned 32-bit integers. The result\n/// wraps around if it exceeds the maximum value of `UInt`.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned integer operand.\n/// * `other` : The second unsigned integer operand.\n///\n/// Returns the product of the two unsigned integers. If the result exceeds the\n/// maximum value of `UInt` (4294967295), it wraps around to the corresponding\n/// value modulo 2^32.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 3U\n///   let b = 4U\n///   inspect(a * b, content=\"12\")\n///   let max = 4294967295U\n///   inspect(max * 2U, content=\"4294967294\") // Wraps around to max * 2 % 2^32\n/// }\n/// ```\npub impl Mul for UInt with mul(self, other) = \"%u32.mul\"\n\n///|\n/// Performs division between two unsigned 32-bit integers. The operation follows\n/// standard unsigned integer division rules, where the result is truncated\n/// towards zero.\n///\n/// Parameters:\n///\n/// * `self` : The dividend (the number to be divided).\n/// * `other` : The divisor (the number to divide by).\n///\n/// Returns an unsigned 32-bit integer representing the quotient of the division.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 42U\n///   let b = 5U\n///   inspect(a / b, content=\"8\") // Using infix operator\n/// }\n/// ```\npub impl Div for UInt with div(self, other) = \"%u32.div\"\n\n///|\n/// Calculates the remainder of dividing one unsigned integer by another.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned integer dividend.\n/// * `other` : The unsigned integer divisor.\n///\n/// Returns the remainder of the division operation.\n///\n/// Throws a panic if `other` is zero.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 17U\n///   let b = 5U\n///   inspect(a % b, content=\"2\") // 17 divided by 5 gives quotient 3 and remainder 2\n///   inspect(7U % 4U, content=\"3\")\n/// }\n/// ```\npub impl Mod for UInt with mod(self, other) = \"%u32.mod\"\n\n///|\n/// Compares two unsigned 32-bit integers for equality.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned integer operand.\n/// * `other` : The second unsigned integer operand to compare with.\n///\n/// Returns `true` if both integers have the same value, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 42U\n///   let b = 42U\n///   let c = 24U\n///   inspect(a == b, content=\"true\")\n///   inspect(a == c, content=\"false\")\n/// }\n/// ```\npub impl Eq for UInt with equal(self : UInt, other : UInt) -> Bool = \"%u32.eq\"\n\n///|\n/// Compares two unsigned 32-bit integers for inequality.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned integer operand.\n/// * `other` : The second unsigned integer operand to compare with.\n///\n/// Returns `true` if the integers have different values, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 42U\n///   let b = 42U\n///   let c = 24U\n///   inspect(a != b, content=\"false\")\n///   inspect(a != c, content=\"true\")\n/// }\n/// ```\npub impl Eq for UInt with not_equal(self : UInt, other : UInt) -> Bool = \"%u32.ne\"\n\n///|\n#deprecated(\"Use `a != b` instead\")\n#doc(hidden)\npub fn UInt::op_neq(self : UInt, other : UInt) -> Bool = \"%u32.ne\"\n\n///|\n/// Compares two unsigned 32-bit integers and returns their relative order.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned integer to compare.\n/// * `other` : The second unsigned integer to compare against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 42U\n///   let b = 24U\n///   inspect(a.compare(b), content=\"1\") // 42 > 24\n///   inspect(b.compare(a), content=\"-1\") // 24 < 42\n///   inspect(a.compare(a), content=\"0\") // 42 = 42\n/// }\n/// ```\npub impl Compare for UInt with compare(self, other) = \"%u32.compare\"\n\n///|\npub impl Compare for UInt with op_lt(x, y) = \"%u32.lt\"\n\n///|\npub impl Compare for UInt with op_le(x, y) = \"%u32.le\"\n\n///|\npub impl Compare for UInt with op_gt(x, y) = \"%u32.gt\"\n\n///|\npub impl Compare for UInt with op_ge(x, y) = \"%u32.ge\"\n\n///|\n/// Performs a bitwise AND operation between two unsigned 32-bit integers. For\n/// each bit position, the result is 1 if the bits at that position in both\n/// operands are 1, and 0 otherwise.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer operand.\n/// * `other` : The second unsigned 32-bit integer operand.\n///\n/// Returns an unsigned 32-bit integer representing the result of the bitwise AND\n/// operation.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 0xF0F0U // 1111_0000_1111_0000\n///   let b = 0xFF00U // 1111_1111_0000_0000\n///   inspect(a & b, content=\"61440\") // 1111_0000_0000_0000 = 61440\n/// }\n/// ```\npub impl BitAnd for UInt with land(self : UInt, other : UInt) -> UInt = \"%u32.bitand\"\n\n///|\n/// Performs a bitwise OR operation between two unsigned 32-bit integers. For\n/// each bit position, the result is 1 if at least one of the corresponding bits\n/// in either operand is 1.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer operand.\n/// * `other` : The second unsigned 32-bit integer operand.\n///\n/// Returns the result of the bitwise OR operation as an unsigned 32-bit integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 0xF0F0U // Binary: 1111_0000_1111_0000\n///   let b = 0x0F0FU // Binary: 0000_1111_0000_1111\n///   inspect(a | b, content=\"65535\") // Binary: 1111_1111_1111_1111\n/// }\n/// ```\npub impl BitOr for UInt with lor(self : UInt, other : UInt) -> UInt = \"%u32.bitor\"\n\n///|\n/// Performs a bitwise XOR (exclusive OR) operation between two unsigned 32-bit\n/// integers. Each bit in the result is set to 1 if the corresponding bits in the\n/// operands are different, and 0 if they are the same.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer operand.\n/// * `other` : The second unsigned 32-bit integer operand.\n///\n/// Returns the result of the bitwise XOR operation.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 0xFF00U // Binary: 1111_1111_0000_0000\n///   let b = 0x0F0FU // Binary: 0000_1111_0000_1111\n///   inspect(a ^ b, content=\"61455\") // Binary: 1111_0000_0000_1111\n/// }\n/// ```\npub impl BitXOr for UInt with lxor(self : UInt, other : UInt) -> UInt = \"%u32.bitxor\"\n\n///|\n/// Performs a bitwise NOT operation on an unsigned 32-bit integer. Flips all\n/// bits in the number (changes each 0 to 1 and each 1 to 0).\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer value on which to perform the bitwise\n/// NOT operation.\n///\n/// Returns a new unsigned 32-bit integer where each bit is inverted from the\n/// input value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0xFF00U // Binary: 1111_1111_0000_0000\n///   inspect(x.lnot(), content=\"4294902015\") // Binary: ...0000_0000_1111_1111\n/// }\n/// ```\npub fn UInt::lnot(self : UInt) -> UInt = \"%u32.bitnot\"\n\n///|\n/// Performs a left shift operation on an unsigned 32-bit integer. Shifts each\n/// bit in the number to the left by the specified number of positions, filling\n/// the rightmost positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift the bits. Must be non-negative\n/// and less than 32. Values outside this range are wrapped to fit within it\n/// (i.e., `shift & 31`).\n///\n/// Returns a new `UInt` value representing the result of shifting the bits left\n/// by the specified number of positions. Each position shifted multiplies the\n/// number by 2.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 1U\n///   inspect(x << 3, content=\"8\") // Using the recommended operator\n///   let y = 8U\n///   inspect(y << 1, content=\"16\") // Using the recommended operator\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn UInt::lsl(self : UInt, shift : Int) -> UInt = \"%u32.shl\"\n\n///|\n/// Performs a left shift operation on an unsigned 32-bit integer. Shifts each\n/// bit in the integer to the left by the specified number of positions, filling\n/// the rightmost positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift left. Must be between 0 and 31\n/// inclusive. Values outside this range will be masked with `& 31`.\n///\n/// Returns a new `UInt` value containing the result of the left shift operation.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 1U\n///   inspect(x << 3, content=\"8\") // Binary: 1 -> 1000\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn UInt::shl(self : UInt, shift : Int) -> UInt = \"%u32.shl\"\n\n///|\n/// Performs a logical right shift on an unsigned 32-bit integer. Each bit in the\n/// input value is shifted right by the specified number of positions, with zeros\n/// shifted in from the left. DEPRECATED: Use the `>>` operator instead.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift right. Must be non-negative.\n///\n/// Returns a new `UInt` value representing the result of the logical right shift\n/// operation.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0xF0000000U\n///   inspect(x >> 4, content=\"251658240\") // Using the recommended operator\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn UInt::lsr(self : UInt, shift : Int) -> UInt = \"%u32.shr\"\n\n///|\n/// Performs a logical right shift operation on an unsigned 32-bit integer by a\n/// specified number of positions. All bits shifted in from the left are zeros.\n///\n/// Parameters:\n///\n/// * `number` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift right. Must be non-negative.\n///\n/// Returns a new `UInt` value that represents the result of shifting all bits in\n/// `number` to the right by `shift` positions.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0xFF000000U\n///   inspect(x >> 8, content=\"16711680\") // 0x00FF0000\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn UInt::shr(self : UInt, shift : Int) -> UInt = \"%u32.shr\"\n\n///|\n/// Performs a left shift operation on an unsigned 32-bit integer. Each bit in\n/// the integer is shifted left by the specified number of positions, and zeros\n/// are filled in from the right.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift. Only the least significant 5\n/// bits are used, effectively making the shift count always between 0 and 31.\n///\n/// Returns a new unsigned 32-bit integer that is the result of shifting `self`\n/// left by `shift` positions.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 1U\n///   inspect(x << 3, content=\"8\") // Binary: 1 -> 1000\n///   let y = 0xFFFFFFFFU\n///   inspect(y << 16, content=\"4294901760\") // All bits after position 16 are discarded\n/// }\n/// ```\npub impl Shl for UInt with shl(self, shift) = \"%u32.shl\"\n\n///|\n/// Performs a logical right shift operation on an unsigned 32-bit integer. The\n/// operation shifts all bits to the right by a specified number of positions,\n/// filling the leftmost positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift right. If this value is\n/// negative, the behavior is undefined. Values larger than 31 are masked with `&\n/// 31`.\n///\n/// Returns a new unsigned 32-bit integer containing the result of the right\n/// shift operation.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0xFF000000U\n///   inspect(x >> 8, content=\"16711680\") // 0x00FF0000\n///   inspect(x >> 24, content=\"255\") // 0x000000FF\n///   let x = 0xFF000000U\n///   inspect(x >> 32, content=\"4278190080\") // Same as x >> 0 due to masking\n/// }\n/// ```\npub impl Shr for UInt with shr(self, shift) = \"%u32.shr\"\n\n///|\n/// Counts the number of leading zero bits in an unsigned 32-bit integer,\n/// starting from the most significant bit.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned 32-bit integer whose leading zeros are to be\n/// counted.\n///\n/// Returns the number of consecutive zeros starting from the most significant\n/// bit. For a zero value, returns 32.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(0U.clz(), content=\"32\")\n///   inspect(1U.clz(), content=\"31\")\n///   inspect(0x80000000U.clz(), content=\"0\")\n/// }\n/// ```\npub fn UInt::clz(self : UInt) -> Int = \"%u32.clz\"\n\n///|\n/// Counts the number of trailing zero bits in an unsigned 32-bit integer,\n/// starting from the least significant bit. For a zero input, returns 32.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer whose trailing zeros are to be\n/// counted.\n///\n/// Returns the number of consecutive zeros at the least significant end of the\n/// binary representation. Returns 32 if the input is zero.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 24U // Binary: ...011000\n///   inspect(x.ctz(), content=\"3\") // 3 trailing zeros\n///   let y = 0U\n///   inspect(y.ctz(), content=\"32\") // All bits are zero\n/// }\n/// ```\npub fn UInt::ctz(self : UInt) -> Int = \"%u32.ctz\"\n\n///|\n/// Counts the number of 1 bits (population count) in the binary representation\n/// of an unsigned 32-bit integer.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer whose bits are to be counted.\n///\n/// Returns an integer representing the count of set bits (1s) in the binary\n/// representation.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0xF0F0U // Binary: 1111 0000 1111 0000\n///   inspect(x.popcnt(), content=\"8\") // Has 8 bits set to 1\n/// }\n/// ```\npub fn UInt::popcnt(self : UInt) -> Int = \"%u32.popcnt\"\n\n///|\n/// Converts an unsigned 32-bit integer to an unsigned 64-bit integer by\n/// zero-extending it. The resulting value preserves the original number's\n/// magnitude while using 64 bits to represent it.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer (`UInt`) to be converted.\n///\n/// Returns an unsigned 64-bit integer (`UInt64`) representing the same numerical\n/// value as the input.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 42U\n///   inspect(n.to_uint64(), content=\"42\")\n///   let max = 4294967295U // Maximum value of UInt\n///   inspect(max.to_uint64(), content=\"4294967295\")\n/// }\n/// ```\npub fn UInt::to_uint64(self : UInt) -> UInt64 {\n  UInt64::extend_uint(self)\n}\n\n///|\n/// Converts an unsigned 32-bit integer to a byte by taking its least significant\n/// 8 bits. Any bits beyond the first 8 bits are truncated.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be converted. Only the least\n/// significant 8 bits will be used.\n///\n/// Returns a byte containing the least significant 8 bits of the input integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 258U // In binary: 100000010\n///   inspect(n.to_byte(), content=\"b'\\\\x02'\") // Only keeps 00000010\n///   let big = 4294967295U // Maximum value of UInt\n///   inspect(big.to_byte(), content=\"b'\\\\xFF'\") // Only keeps 11111111\n/// }\n/// ```\npub fn UInt::to_byte(self : UInt) -> Byte {\n  self.reinterpret_as_int().to_byte()\n}\n\n///|\n/// Converts an unsigned 32-bit integer to a double-precision floating-point\n/// number. Since the range of unsigned 32-bit integers is smaller than what can\n/// be precisely represented by a double-precision floating-point number, this\n/// conversion is guaranteed to be exact.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned 32-bit integer to be converted.\n///\n/// Returns a double-precision floating-point number that exactly represents the\n/// input value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 42U\n///   inspect(n.to_double(), content=\"42\")\n///   let max = 4294967295U // maximum value of UInt\n///   inspect(max.to_double(), content=\"4294967295\")\n/// }\n/// ```\npub fn UInt::to_double(self : UInt) -> Double = \"%u32.to_f64\"\n\n///|\n#deprecated(\"Use `Float::from_int` instead\")\npub fn Int::to_float(self : Int) -> Float = \"%i32.to_f32\"\n\n///|\n#deprecated(\"Use `Float::reinterpret_from_int` instead\")\npub fn Int::reinterpret_as_float(self : Int) -> Float = \"%i32.to_f32_reinterpret\"\n\n///|\n#deprecated(\"Use `Float::reinterpret_from_uint` instead\")\npub fn UInt::reinterpret_as_float(self : UInt) -> Float = \"%i32.to_f32_reinterpret\"\n\n///|\n#deprecated(\"Use `Float::from_byte` instead\")\npub fn Byte::to_float(self : Byte) -> Float = \"%byte.to_f32\"\n\n///|\n/// TODO: use intrinsics implement this\npub fn Byte::to_double(self : Byte) -> Double {\n  self.to_int().to_double()\n}\n\n///|\n/// TODO: enable skip_current_package=false\n#deprecated(\"Use `Float::from_double` instead\", skip_current_package=true)\npub fn Double::to_float(self : Double) -> Float = \"%f64.to_f32\"\n\n///|\n#deprecated(\"Use `Float::from_uint` instead\")\npub fn UInt::to_float(self : UInt) -> Float = \"%u32.to_f32\"\n\n///|\n#deprecated(\"Use `Int16::from_int` instead\")\npub fn Int::to_int16(self : Int) -> Int16 = \"%i32_to_i16\"\n\n///|\n/// Converts a byte value to a 16-bit signed integer. The byte value is\n/// sign-extended to 16 bits during the conversion.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted to an `Int16`.\n///\n/// Returns a 16-bit signed integer representing the same value as the input\n/// byte.\n#deprecated(\"Use `Int16::from_byte` instead\")\npub fn Byte::to_int16(self : Byte) -> Int16 = \"%byte_to_i16\"\n\n///|\n/// Converts an unsigned 16-bit integer to a 32-bit signed integer. The value is\n/// zero-extended to fill the higher bits.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned 16-bit integer to be converted.\n///\n/// Returns a 32-bit signed integer. Since the input value is always non-negative\n/// and less than 65536, the conversion never results in overflow.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = Int::to_uint16(42)\n///   inspect(x.to_int(), content=\"42\")\n///   let max = Int::to_uint16(65535) // maximum value of UInt16\n///   inspect(max.to_int(), content=\"65535\")\n/// }\n/// ```\npub fn UInt16::to_int(self : UInt16) -> Int = \"%u16_to_i32\"\n\n///|\n/// Converts a 16-bit unsigned integer to an 8-bit byte by truncating the higher\n/// bits.\n///\n/// Parameters:\n///\n/// * `value` : The 16-bit unsigned integer to be converted.\n///\n/// Returns a byte containing the least significant 8 bits of the input value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = Int::to_uint16(258) // Binary: 0000_0001_0000_0010\n///   inspect(x.to_byte(), content=\"b'\\\\x02'\") // Only keeps 0000_0010\n/// }\n/// ```\npub fn UInt16::to_byte(self : UInt16) -> Byte = \"%u16_to_byte\"\n\n///|\n/// Converts a 32-bit unsigned integer to a 16-bit unsigned integer by truncating\n/// its value to fit within the range of 0 to 65535.\n///\n/// Parameters:\n///\n/// * `integer` : The 32-bit unsigned integer to be converted. Values outside the\n/// range of UInt16 will be truncated to fit.\n///\n/// Returns a 16-bit unsigned integer containing the lower 16 bits of the input\n/// value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 42U\n///   inspect(n.to_uint16(), content=\"42\")\n///   let max = 4294967295U\n///   inspect(max.to_uint16(), content=\"65535\") // -1 becomes max value of UInt16\n///   let large = 65536U\n///   inspect(large.to_uint16(), content=\"0\") // Values wrap around\n/// }\n/// ```\npub fn UInt::to_uint16(self : UInt) -> UInt16 {\n  self.reinterpret_as_int().to_uint16()\n}\n\n///|\n/// Converts a 32-bit signed integer to a 16-bit unsigned integer by truncating\n/// its value to fit within the range of 0 to 65535.\n///\n/// Parameters:\n///\n/// * `integer` : The 32-bit signed integer to be converted. Values outside the\n/// range of UInt16 will be truncated to fit.\n///\n/// Returns a 16-bit unsigned integer containing the lower 16 bits of the input\n/// value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 42\n///   inspect(n.to_uint16(), content=\"42\")\n///   let neg = -1\n///   inspect(neg.to_uint16(), content=\"65535\") // -1 becomes max value of UInt16\n///   let large = 65536\n///   inspect(large.to_uint16(), content=\"0\") // Values wrap around\n/// }\n/// ```\npub fn Int::to_uint16(self : Int) -> UInt16 = \"%i32_to_u16\"\n\n///|\n/// Converts a byte value to a 16-bit unsigned integer by zero-extending it.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted.\n///\n/// Returns a 16-bit unsigned integer (`UInt16`) representing the same value as\n/// the input byte.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let b = b'\\xFF' // byte with value 255\n///   inspect(b.to_uint16(), content=\"255\")\n///   let zero = b'\\x00'\n///   inspect(zero.to_uint16(), content=\"0\")\n/// }\n/// ```\npub fn Byte::to_uint16(self : Byte) -> UInt16 = \"%byte_to_u16\"\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Copies a slice of elements from one fixed array to another.\n///\n/// This function copies `len` elements from `src` starting at `src_offset` to `dst` starting at `dst_offset`.\n/// The arrays may overlap, in which case the copy is performed in a way that preserves the data.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let src = FixedArray::from_array([1, 2, 3, 4, 5])\n///   let dst = FixedArray::from_array([0, 0, 0, 0, 0])\n///   FixedArray::unsafe_blit(dst, 0, src, 0, 3)\n///   assert_eq(dst, FixedArray::from_array([1, 2, 3, 0, 0]))\n/// }\n/// ```\n///\n/// The behavior is undefined and platform-specific if:\n/// - `len < 0`\n/// - `src_offset < 0`\n/// - `dst_offset < 0`\n/// - `dst_offset + len > dst.length()`\n/// - `src_offset + len > src.length()`\n///\n#intrinsic(\"%fixedarray.copy\")\n#coverage.skip\npub fn[A] FixedArray::unsafe_blit(\n  dst : FixedArray[A],\n  dst_offset : Int,\n  src : FixedArray[A],\n  src_offset : Int,\n  len : Int,\n) -> Unit {\n  if physical_equal(dst, src) && dst_offset < src_offset {\n    for i in 0..<len {\n      dst[dst_offset + i] = src[src_offset + i]\n    }\n  } else {\n    for i = len - 1; i >= 0; i = i - 1 {\n      dst[dst_offset + i] = src[src_offset + i]\n    }\n  }\n}\n\n///|\n/// This is the same as `unsafe_blit`, but it is used when the source array is\n/// FixedArray[T] instead of UninitializedArray[T].\n#intrinsic(\"%fixedarray.copy\")\n#coverage.skip\nfn[T] UninitializedArray::unsafe_blit_fixed(\n  dst : UninitializedArray[T],\n  dst_offset : Int,\n  src : FixedArray[T],\n  src_offset : Int,\n  len : Int,\n) -> Unit {\n  for i = len - 1; i >= 0; i = i - 1 {\n    dst[dst_offset + i] = src[src_offset + i]\n  }\n}\n\n///|\n/// Copies a sequence of elements from the source fixed array to a destination\n/// fixed array. The arrays may overlap, in which case the copy is performed in a\n/// way that preserves the data.\n///\n/// Parameters:\n///\n/// * `self` : The source fixed array from which elements will be copied.\n/// * `dst` : The destination fixed array where elements will be copied to.\n/// * `len` : The number of elements to copy.\n/// * `src_offset` : The starting position in the source array. Defaults to 0.\n/// * `dst_offset` : The starting position in the destination array. Defaults to\n/// 0.\n///\n/// Throws a panic if:\n///\n/// * `src_offset + len` exceeds the length of the source array\n/// * `dst_offset + len` exceeds the length of the destination array\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let src = FixedArray::make(5, 1)\n///   let dst = FixedArray::make(5, 0)\n///   src.blit_to(dst, len=3, src_offset=1, dst_offset=2)\n///   inspect(dst, content=\"[0, 0, 1, 1, 1]\")\n/// }\n/// ```\npub fn[A] FixedArray::blit_to(\n  self : FixedArray[A],\n  dst : FixedArray[A],\n  len~ : Int,\n  src_offset? : Int = 0,\n  dst_offset? : Int = 0,\n) -> Unit {\n  guard dst_offset >= 0 &&\n    src_offset >= 0 &&\n    dst_offset + len <= dst.length() &&\n    src_offset + len <= self.length() else {\n    abort(\n      \"bounds check failed: dst_offset = \\{dst_offset}, src_offset = \\{src_offset}, len = \\{len}, dst.length = \\{dst.length()}, self.length = \\{self.length()}\",\n    )\n  }\n  FixedArray::unsafe_blit(dst, dst_offset, self, src_offset, len)\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nstruct UninitializedArray[T](FixedArray[UnsafeMaybeUninit[T]])\n\n///|\n/// Creates an uninitialized array of the specified size.\n///\n/// Parameters:\n///\n/// - `size` : The number of elements the array should hold.\n///\n/// Returns an uninitialized array of type `T` with the specified size.\npub fn[T] UninitializedArray::make(size : Int) -> UninitializedArray[T] = \"%fixedarray.make_uninit\"\n\n///|\n/// Retrieves the element at the specified index from an uninitialized array.\n///\n/// Parameters:\n///\n/// - `array` : The uninitialized array from which to retrieve the element.\n/// - `index` : The index of the element to retrieve.\n///\n/// Returns the element at the specified index.\n#alias(\"_[_]\")\npub fn[T] UninitializedArray::at(\n  self : UninitializedArray[T],\n  index : Int,\n) -> T = \"%fixedarray.get\"\n\n///|\n/// Sets the value at the specified index in an uninitialized array.\n///\n/// Parameters:\n///\n/// - `array` : The uninitialized array where the value will be set.\n/// - `index` : The position in the array where the value will be set.\n/// - `value` : The value to be set at the specified index.\n#alias(\"_[_]=_\")\npub fn[T] UninitializedArray::set(\n  self : UninitializedArray[T],\n  index : Int,\n  value : T,\n) = \"%fixedarray.set\"\n\n///|\n/// Creates a view into a portion of the uninitialized array.\n///\n/// Parameters:\n///\n/// * `array` : The uninitialized array to create a view from.\n/// * `start` : The starting index of the view (inclusive). Defaults to 0.\n/// * `end` : The ending index of the view (exclusive). If not provided, defaults\n/// to the length of the array.\n///\n/// Returns an `ArrayView` that provides a window into the specified portion of\n/// the array.\n///\n/// Throws an error if the indices are out of bounds or if `start` is greater\n/// than `end`.\n#alias(\"_[_:_]\")\npub fn[T] UninitializedArray::sub(\n  self : UninitializedArray[T],\n  start? : Int = 0,\n  end? : Int,\n) -> ArrayView[T] {\n  let len = self.length()\n  let end = match end {\n    None => len\n    Some(end) => end\n  }\n  guard start >= 0 && start <= end && end <= len else {\n    abort(\"View start index out of bounds\")\n  }\n  ArrayView::make(self, start, end - start)\n}\n\n///|\n/// Returns the length of an uninitialized array.\n///\n/// Parameters:\n///\n/// - `array` : The uninitialized array whose length is to be determined.\n///\n/// Returns the length of the uninitialized array as an integer.\npub fn[A] UninitializedArray::length(self : UninitializedArray[A]) -> Int {\n  self.0.length()\n}\n\n///|\n#internal(unsafe, \"For internal use only.\")\n#doc(hidden)\npub fn[T] UninitializedArray::unsafe_blit(\n  dst : UninitializedArray[T],\n  dst_offset : Int,\n  src : UninitializedArray[T],\n  src_offset : Int,\n  len : Int,\n) -> Unit {\n  FixedArray::unsafe_blit(dst.0, dst_offset, src.0, src_offset, len)\n}\n\n///|\ntest \"as_view with valid_range\" {\n  let arr : UninitializedArray[Int] = UninitializedArray::make(5)\n  let view = arr[1:4]\n  inspect(view.start(), content=\"1\")\n  inspect(view.len(), content=\"3\")\n}\n\n///|\ntest \"panic as_view with invalid_start\" {\n  let arr : UninitializedArray[Int] = UninitializedArray::make(5)\n  ignore(arr[-1:])\n}\n\n///|\ntest \"panic as_view with invalid_end\" {\n  let arr : UninitializedArray[Int] = UninitializedArray::make(5)\n  ignore(arr[2:10])\n}\n\n///|\n#coverage.skip\n#intrinsic(\"%fixedarray.fill\")\n#cfg(not(target=\"js\"))\nfn[T] UninitializedArray::unchecked_fill(\n  self : UninitializedArray[T],\n  start : Int,\n  value : T,\n  len : Int,\n) -> Unit {\n  for i in start..<(start + len) {\n    self[i] = value\n  }\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nstruct StringBuilder(Ref[String])\n\n///|\n/// Creates a new string builder with an optional initial capacity hint.\n///\n/// Parameters:\n///\n/// * `size_hint` : An optional initial capacity hint for the internal buffer. If\n/// less than 1, a minimum capacity of 1 is used. Defaults to 0. It is the size of bytes, \n/// not the size of characters. `size_hint` may be ignored on some platforms, JS for example.\n///\n/// Returns a new `StringBuilder` instance with the specified initial capacity.\n///\npub fn StringBuilder::new(size_hint? : Int = 0) -> StringBuilder {\n  ignore(size_hint)\n  { val: \"\" }\n}\n\n///|\n/// Return whether the given buffer is empty.\npub fn StringBuilder::is_empty(self : StringBuilder) -> Bool {\n  self.val == \"\"\n}\n\n///|\n/// Writes a string to the StringBuilder.\npub impl Logger for StringBuilder with write_string(self, str) {\n  self.val += str\n}\n\n///|\n/// Writes a character to the StringBuilder.\npub impl Logger for StringBuilder with write_char(self, ch) {\n  self.val += char_to_string(ch)\n}\n\n///|\n/// Writes a part of the given string to the StringBuilder.\n/// \n/// Parameters:\n///\n/// * `self` : The StringBuilder to write to.\n/// * `str` : The given string.\n/// * `start` : The start index of the substring to write.\n/// * `len` : The length of the substring to write.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let sb = StringBuilder::new()\n///   sb.write_view(\"Hello, world!\"[:5])\n///   assert_eq(sb.to_string(), \"Hello\")\n/// }\n/// ```\npub impl Logger for StringBuilder with write_view(\n  self : StringBuilder,\n  str : StringView,\n) -> Unit {\n  self.val += str.to_string()\n}\n\n///|\npub impl Show for StringBuilder with output(self, logger) {\n  logger.write_string(self.val)\n}\n\n///|\n/// Returns the current content of the StringBuilder as a string.\npub fn StringBuilder::to_string(self : StringBuilder) -> String {\n  self.val\n}\n\n///|\n/// Resets the string builder to an empty state.\npub fn StringBuilder::reset(self : StringBuilder) -> Unit {\n  self.val = \"\"\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Checks if the integer value represents a UTF-16 leading surrogate.\n/// Leading surrogates are in the range 0xD800 to 0xDBFF.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   inspect((0xD800 : UInt16).is_leading_surrogate(), content=\"true\")\n///   inspect((0xDBFF : UInt16).is_leading_surrogate(), content=\"true\")\n///   inspect((0xDC00 : UInt16).is_leading_surrogate(), content=\"false\")\n///   inspect((0x41 : UInt16).is_leading_surrogate(), content=\"false\") // 'A'\n/// }\n/// ```\npub fn UInt16::is_leading_surrogate(self : Self) -> Bool {\n  self >= 0xD800 && self <= 0xDBFF\n}\n\n///|\n/// Checks if the integer value represents a UTF-16 trailing surrogate.\n/// Trailing surrogates are in the range 0xDC00 to 0xDFFF.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   inspect((0xDC00 : UInt16).is_trailing_surrogate(), content=\"true\")\n///   inspect((0xDFFF : UInt16).is_trailing_surrogate(), content=\"true\")\n///   inspect((0xD800 : UInt16).is_trailing_surrogate(), content=\"false\")\n///   inspect((0x41 : UInt16).is_trailing_surrogate(), content=\"false\") // 'A'\n/// }\n/// ```\npub fn UInt16::is_trailing_surrogate(self : Self) -> Bool {\n  self >= 0xDC00 && self <= 0xDFFF\n}\n\n///|\n/// Checks if the integer value represents any UTF-16 surrogate (leading or trailing).\n/// Surrogates are in the range 0xD800 to 0xDFFF.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   inspect((0xD800 : UInt16).is_surrogate(), content=\"true\") // leading surrogate\n///   inspect((0xDC00 : UInt16).is_surrogate(), content=\"true\") // trailing surrogate\n///   inspect((0xDFFF : UInt16).is_surrogate(), content=\"true\") // trailing surrogate\n///   inspect((0x41 : UInt16).is_surrogate(), content=\"false\") // 'A'\n/// }\n/// ```\npub fn UInt16::is_surrogate(self : Self) -> Bool {\n  self >= 0xD800 && self <= 0xDFFF\n}\n\n///|\npub fn UInt16::unsafe_to_char(self : UInt16) -> Char {\n  self.to_int().unsafe_to_char()\n}\n\n///|\npub fn UInt16::to_char(self : UInt16) -> Char? {\n  if self is (0..=0xD7FF) || self is (0xE000..<_) {\n    Some(self.unsafe_to_char())\n  } else {\n    None\n  }\n}\n\n///|\npub impl Add for UInt16 with add(self : UInt16, that : UInt16) -> UInt16 {\n  (self.to_int() + that.to_int()).to_uint16()\n}\n\n///|\npub impl Sub for UInt16 with sub(self : UInt16, that : UInt16) -> UInt16 {\n  (self.to_int() - that.to_int()).to_uint16()\n}\n\n///|\npub impl Mul for UInt16 with mul(self : UInt16, that : UInt16) -> UInt16 {\n  (self.to_int() * that.to_int()).to_uint16()\n}\n\n///|\npub impl Div for UInt16 with div(self : UInt16, that : UInt16) -> UInt16 {\n  (self.to_int() / that.to_int()).to_uint16()\n}\n\n///|\npub impl Mod for UInt16 with mod(self : UInt16, that : UInt16) -> UInt16 {\n  (self.to_int() % that.to_int()).to_uint16()\n}\n\n///|\npub impl Eq for UInt16 with equal(self, that) {\n  self.to_int() == that.to_int()\n}\n\n///|\npub impl Eq for UInt16 with not_equal(self, that) {\n  self.to_int() != that.to_int()\n}\n\n///|\npub impl Compare for UInt16 with compare(self, that) {\n  self.to_int().compare(that.to_int())\n}\n\n///|\npub impl Hash for UInt16 with hash_combine(self, hasher) {\n  hasher.combine_int(self.to_int())\n}\n\n///|\npub impl Shl for UInt16 with shl(self : UInt16, that : Int) -> UInt16 {\n  (self.to_int() << that).to_uint16()\n}\n\n///|\npub impl Shr for UInt16 with shr(self : UInt16, that : Int) -> UInt16 {\n  (self.to_int() >> that).to_uint16()\n}\n\n///|\npub impl BitOr for UInt16 with lor(self : UInt16, that : UInt16) -> UInt16 {\n  (self.to_int() | that.to_int()).to_uint16()\n}\n\n///|\npub impl BitAnd for UInt16 with land(self : UInt16, that : UInt16) -> UInt16 {\n  (self.to_int() & that.to_int()).to_uint16()\n}\n\n///|\npub impl BitXOr for UInt16 with lxor(self : UInt16, that : UInt16) -> UInt16 {\n  (self.to_int() ^ that.to_int()).to_uint16()\n}\n\n///|\npub impl Default for UInt16 with default() {\n  0\n}\n\n///|\npub impl ToJson for UInt16 with to_json(self : UInt16) -> Json {\n  Json::number(self.to_int().to_double())\n}\n\n///|\npub fn UInt16::to_uint(self : UInt16) -> UInt {\n  self.to_int().reinterpret_as_uint()\n}\n\n///|\npub fn UInt16::to_uint64(self : UInt16) -> UInt64 {\n  self.to_int().to_uint64()\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn unsafe_make_string(length : Int, value : Char) -> String = \"$moonbit.unsafe_make_string\"\n\n///|\n/// Create new string of `length`, where each character is `value`\n///\n/// ```mbt check\n/// test {\n///   assert_eq(String::make(5, 'S'), \"SSSSS\")\n/// }\n/// ```\npub fn String::make(length : Int, value : Char) -> String {\n  guard length >= 0 else { abort(\"invalid length\") }\n  if value.to_int() <= 0xFFFF {\n    unsafe_make_string(length, value)\n  } else {\n    let buf = StringBuilder::new(size_hint=2 * length)\n    for _ in 0..<length {\n      buf.write_char(value)\n    }\n    buf.to_string()\n  }\n}\n\n///|\nfn code_point_of_surrogate_pair(leading : Int, trailing : Int) -> Char {\n  ((leading - 0xD800) * 0x400 + trailing - 0xDC00 + 0x10000).unsafe_to_char()\n}\n\n///|\n/// Returns the number of Unicode code points (characters) in the string.\n///\n/// This method counts actual Unicode characters, properly handling surrogate pairs\n/// that represent single characters like emojis. For the raw UTF-16 code unit count,\n/// use `length()` instead.\n///\n/// # Examples\n///\n/// ```mbt check\n/// test {\n///   let s = \"Hello\"\n///   inspect(s.char_length(), content=\"6\") // 6 actual characters\n///   inspect(s.length(), content=\"7\")\n/// } // 5 ASCII chars + 2 surrogate pairs\n/// ```\n#alias(codepoint_length, deprecated)\npub fn String::char_length(\n  self : String,\n  start_offset? : Int = 0,\n  end_offset? : Int,\n) -> Int {\n  let end_offset = if end_offset is Some(o) { o } else { self.length() }\n  guard start_offset >= 0 &&\n    start_offset <= end_offset &&\n    end_offset <= self.length() else {\n    abort(\"invalid start or end index for String::codepoint_length\")\n  }\n  for utf16_index = start_offset, char_count = 0\n      utf16_index < end_offset\n      utf16_index = utf16_index + 1, char_count = char_count + 1 {\n    let c1 = self.unsafe_get(utf16_index)\n    if c1.is_leading_surrogate() && utf16_index + 1 < end_offset {\n      let c2 = self.unsafe_get(utf16_index + 1)\n      if c2.is_trailing_surrogate() {\n        continue utf16_index + 2, char_count + 1\n      } else {\n        abort(\"invalid surrogate pair\")\n      }\n    }\n  } else {\n    char_count\n  }\n}\n\n///|\n#intrinsic(\"%string.substring\")\npub fn String::unsafe_substring(\n  str : String,\n  start~ : Int,\n  end~ : Int,\n) -> String {\n  if start == 0 && end == str.length() {\n    return str\n  }\n  let len = end - start\n  let bytes = FixedArray::make(len * 2, Byte::default())\n  bytes.blit_from_string(0, str, start, len)\n  bytes.unsafe_reinterpret_as_bytes().to_unchecked_string()\n}\n\n///|\n/// Returns a new string containing characters from the original string starting\n/// at `start` index up to (but not including) `end` index.\n///\n/// Parameters:\n///\n/// * `string` : The source string from which to extract the substring.\n/// * `start` : The starting index of the substring (inclusive). Defaults to 0.\n/// * `end` : The ending index of the substring (exclusive). Defaults to the\n/// length of the string.\n///\n/// Returns a new string containing the specified substring.\n///\n#deprecated(\"Use `str[:]` or `str[:].to_string()` instead\", skip_current_package=true)\npub fn String::substring(self : String, start? : Int = 0, end? : Int) -> String {\n  let len = self.length()\n  let end = match end {\n    Some(end) => end\n    None => len\n  }\n  guard start >= 0 && start <= end && end <= len\n  self.unsafe_substring(start~, end~)\n}\n\n///|\n/// Iterates over all suffixes of the string as views that reuse the\n/// original storage. Surrogate pairs stay intact while advancing.\npub fn String::suffixes(\n  self : String,\n  include_empty? : Bool = false,\n) -> Iter[StringView] {\n  self[:].suffixes(include_empty~)\n}\n\n///|\ntest \"substring/empty\" {\n  let s = \"test\"\n  inspect(s.substring(start=2, end=2), content=\"\")\n  inspect(s.substring(start=4, end=4), content=\"\")\n  inspect(\"\".substring(), content=\"\")\n}\n\n///|\ntest \"panic substring/invalid_range\" {\n  let s = \"test\"\n  ignore(s.substring(start=-1))\n  ignore(s.substring(end=5))\n  ignore(s.substring(start=3, end=2))\n}\n\n///|\ntest \"substring/basic\" {\n  inspect(\"Hello world\".substring(start=0, end=5), content=\"Hello\")\n  inspect(\"Hello world\".substring(start=6, end=11), content=\"world\")\n  inspect(\"Hello world\".substring(start=0), content=\"Hello world\")\n  inspect(\"Hello world\".substring(start=6), content=\"world\")\n}\n\n///|\ntest \"substring/boundary\" {\n  inspect(\"\".substring(start=0, end=0), content=\"\")\n  inspect(\"a\".substring(start=0, end=1), content=\"a\")\n  inspect(\"abc\".substring(start=0), content=\"abc\")\n  inspect(\"abc\".substring(start=1), content=\"bc\")\n  inspect(\"abc\".substring(start=0, end=3), content=\"abc\")\n}\n\n///|\ntest \"panic substring/out_of_bounds\" {\n  ignore(\"hello\".substring(start=-1, end=4))\n  ignore(\"hello\".substring(start=6, end=4))\n  ignore(\"hello\".substring(start=0, end=6))\n}\n\n///|\n/// Strings are ordered based on shortlex order by their charcodes (code units). This \n/// orders Unicode characters based on their positions in the code charts. This is\n/// not necessarily the same as \"alphabetical\" order, which varies by language\n/// and locale.\npub impl Compare for String with compare(self, other) {\n  let len = self.length()\n  match len.compare(other.length()) {\n    0 => {\n      for i in 0..<len {\n        let order = self.unsafe_get(i).compare(other.unsafe_get(i))\n        if order != 0 {\n          return order\n        }\n      }\n      0\n    }\n    order => order\n  }\n}\n\n///|\n/// The empty string\npub impl Default for String with default() {\n  \"\"\n}\n\n///|\n/// `String` holds a sequence of UTF-16 code units encoded in little endian format\n#deprecated(\"Check `@encoding/utf8.encode`\")\npub fn String::to_bytes(self : String) -> Bytes {\n  let array = FixedArray::make(self.length() * 2, Byte::default())\n  array.blit_from_string(0, self, 0, self.length())\n  array |> unsafe_to_bytes\n}\n\n///|\nfn unsafe_to_bytes(array : FixedArray[Byte]) -> Bytes = \"%identity\"\n\n///|\n/// Converts the String into an array of Chars.\npub fn String::to_array(self : String) -> Array[Char] {\n  self\n  .iter()\n  .fold(init=Array::new(capacity=self.length()), (rv, c) => {\n    rv.push(c)\n    rv\n  })\n}\n\n///|\n/// Returns an iterator over the Unicode characters in the string.\n///\n/// Note: This iterator yields Unicode characters, not Utf16 code units.\n/// As a result, the count of characters returned by `iterator().count()` may not be equal to the length of the string returned by `length()`.\n///\n/// ```mbt check\n/// test {\n///   let s = \"Hello, World!\"\n///   assert_eq(s.iter().count(), 14) // Unicode characters\n///   assert_eq(s.length(), 15)\n/// } // Utf16 code units\n/// ```\n#alias(iterator, deprecated)\npub fn String::iter(self : String) -> Iter[Char] {\n  let len = self.length()\n  let mut index = 0\n  Iter::new(fn() {\n    guard index < len else { None }\n    let c1 = self.unsafe_get(index)\n    if c1.is_leading_surrogate() && index + 1 < len {\n      let c2 = self.unsafe_get(index + 1)\n      if c2.is_trailing_surrogate() {\n        let c = code_point_of_surrogate_pair(c1.to_int(), c2.to_int())\n        index += 2\n        return Some(c)\n      }\n    }\n    index += 1\n    //TODO: handle garbage input\n    Some(c1.unsafe_to_char())\n  })\n}\n\n///|\n#alias(iterator2, deprecated)\npub fn String::iter2(self : String) -> Iter2[Int, Char] {\n  self.iter().iter2()\n}\n\n///|\n/// Returns an iterator that yields characters from the end to the start of the string. This function handles\n/// Unicode surrogate pairs correctly, ensuring that characters are not split across surrogate pairs.\n///\n/// # Parameters\n///\n/// - `self` : The input `String` to be iterated in reverse.\n///\n/// # Returns\n///\n/// - An `Iter[Char]` that yields characters from the end to the start of the string.\n///\n/// # Behavior\n///\n/// - The function iterates over the string in reverse order.\n/// - If a trailing surrogate is encountered, it checks for a preceding leading surrogate to form a complete Unicode code point.\n/// - Yields each character or combined code point to the iterator.\n/// - Stops iteration if the `yield_` function returns `IterEnd`.\n///\n/// # Examples\n///\n/// ```mbt check\n/// test {\n///   let input = \"Hello, World!\"\n///   let reversed = input.rev_iter().collect()\n///   assert_eq(reversed, [\n///     '!', 'd', 'l', 'r', 'o', 'W', ' ', ',', 'o', 'l', 'l', 'e', 'H',\n///   ])\n/// }\n/// ```\n#alias(rev_iterator, deprecated)\npub fn String::rev_iter(self : String) -> Iter[Char] {\n  let len = self.length()\n  let mut index = len\n  Iter::new(fn() {\n    guard index > 0 else { None }\n    index -= 1\n    let c1 = self.unsafe_get(index)\n    if c1.is_trailing_surrogate() && index - 1 >= 0 {\n      let c2 = self.unsafe_get(index - 1)\n      if c2.is_leading_surrogate() {\n        index -= 1\n        return Some(code_point_of_surrogate_pair(c2.to_int(), c1.to_int()))\n      }\n    }\n    Some(c1.unsafe_to_char())\n  })\n}\n\n///|\n/// Returns the index of the n-th (zero-indexed) character within the range [start, end).\nfn String::offset_of_nth_char_forward(\n  self : String,\n  n : Int,\n  start_offset~ : Int,\n  end_offset~ : Int,\n) -> Int? {\n  guard start_offset >= 0 && start_offset <= end_offset else {\n    abort(\"Invalid start index\")\n  }\n  let mut utf16_offset = start_offset\n  let mut char_count = 0\n  while utf16_offset < end_offset && char_count < n {\n    let c = self.unsafe_get(utf16_offset)\n    // check if this is a surrogate pair\n    if c.is_leading_surrogate() {\n      utf16_offset = utf16_offset + 2\n    } else {\n      utf16_offset = utf16_offset + 1\n    }\n    char_count = char_count + 1\n  }\n  // Return None if either:\n  // 1. We couldn't reach the requested character offset\n  // 2. The resulting offset is beyond the end of the string\n  // This handles the empty string case correctly.\n  if char_count < n || utf16_offset >= end_offset {\n    None\n  } else {\n    Some(utf16_offset)\n  }\n}\n\n///|\n/// Returns the index of the n-th (zero-indexed) character within the range [start, end).\n/// self[end] is counted as the 0-th character (though it might not exist if end = self.length()).\nfn String::offset_of_nth_char_backward(\n  self : String,\n  n : Int,\n  start_offset~ : Int,\n  end_offset~ : Int,\n) -> Int? {\n  let mut char_count = 0\n  let mut utf16_offset = end_offset\n  // Iterating backwards from the end of the string. \n  // Invariant: utf16_offset always points to the previous character\n  while utf16_offset - 1 >= start_offset && char_count < n {\n    let c = self.unsafe_get(utf16_offset - 1)\n    if c.is_trailing_surrogate() {\n      utf16_offset = utf16_offset - 2\n    } else {\n      utf16_offset = utf16_offset - 1\n    }\n    char_count = char_count + 1\n  }\n  if char_count < n || utf16_offset < start_offset {\n    None\n  } else {\n    Some(utf16_offset)\n  }\n}\n\n///|\n/// Returns the UTF-16 index of the i-th (zero-indexed) Unicode character \n/// within the range [start, end). If i is negative, it returns the index of \n/// the (n + i)-th character where n is the number of Unicode characters \n/// in the range [start, end).\n/// \n/// This functions assumes that the string is valid UTF-16.\npub fn String::offset_of_nth_char(\n  self : String,\n  i : Int,\n  start_offset? : Int = 0,\n  end_offset? : Int,\n) -> Int? {\n  let end_offset = if end_offset is Some(o) { o } else { self.length() }\n  if i >= 0 {\n    // forward case\n    self.offset_of_nth_char_forward(i, start_offset~, end_offset~)\n  } else {\n    // backward case\n    self.offset_of_nth_char_backward(-i, start_offset~, end_offset~)\n  }\n}\n\n///|\n/// Test if the length of the string is equal to the given length.\n///\n/// This has O(n) complexity where n is the length in the parameter.\npub fn String::char_length_eq(\n  self : String,\n  len : Int,\n  start_offset? : Int = 0,\n  end_offset? : Int,\n) -> Bool {\n  let end_offset = if end_offset is Some(o) { o } else { self.length() }\n  for index = start_offset, count = 0\n      index < end_offset && count < len\n      index = index + 1, count = count + 1 {\n    let c1 = self.unsafe_get(index)\n    if c1.is_leading_surrogate() && index + 1 < end_offset {\n      let c2 = self.unsafe_get(index + 1)\n      if c2.is_trailing_surrogate() {\n        continue index + 2, count + 1\n      } else {\n        abort(\"invalid surrogate pair\")\n      }\n    }\n  } else {\n    count == len && index == end_offset\n  }\n}\n\n///|\n/// Test if the length of the string is greater than or equal to the given length.\n///\n/// This has O(n) complexity where n is the length in the parameter.\npub fn String::char_length_ge(\n  self : String,\n  len : Int,\n  start_offset? : Int = 0,\n  end_offset? : Int,\n) -> Bool {\n  let end_offset = if end_offset is Some(o) { o } else { self.length() }\n  for index = start_offset, count = 0\n      index < end_offset && count < len\n      index = index + 1, count = count + 1 {\n    let c1 = self.unsafe_get(index)\n    if c1.is_leading_surrogate() && index + 1 < end_offset {\n      let c2 = self.unsafe_get(index + 1)\n      if c2.is_trailing_surrogate() {\n        continue index + 2, count + 1\n      } else {\n        abort(\"invalid surrogate pair\")\n      }\n    }\n  } else {\n    count >= len\n  }\n}\n\n///|\n/// Performs a lexicographical comparison of two strings.\n///\n/// This method compares the strings character by character (UTF-16 code unit by code unit),\n/// similar to Java's `String.compareTo()`. Unlike the `Compare` trait implementation which\n/// uses shortlex order (shorter strings come first), this method compares based purely on\n/// character values until a difference is found or one string is exhausted.\n///\n/// # Returns\n///\n/// - A negative integer if `self` is lexicographically less than `other`\n/// - Zero if `self` is lexicographically equal to `other`\n/// - A positive integer if `self` is lexicographically greater than `other`\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   inspect(\"ab\".lexical_compare(\"abc\"), content=\"-1\")\n///   inspect(\"abc\".lexical_compare(\"ab\"), content=\"1\")\n///   inspect(\"abc\".lexical_compare(\"abc\"), content=\"0\")\n///   inspect(\"abc\".lexical_compare(\"abd\"), content=\"-1\")\n/// }\n/// ```\n///\n/// # Note\n///\n/// Since MoonBit strings are UTF-16 encoded (like Java), this comparison operates on\n/// UTF-16 code units, not Unicode code points. Surrogate pairs (used for characters\n/// outside the Basic Multilingual Plane) are compared as individual code units.\npub fn String::lexical_compare(self : String, other : String) -> Int {\n  self[:].lexical_compare(other[:])\n}\n\n///|\n/// Convert char array to string.\n///\n/// ```mbt check\n/// test {\n///   let s = String::from_array(['H', 'e', 'l', 'l', 'o'])\n///   assert_eq(s, \"Hello\")\n/// }\n/// ```\n///\n/// Do not convert large data to `Array[Char]` and build a string with `String::from_array`.\n///\n/// For efficiency considerations, it's recommended to use `Buffer` instead.\npub fn String::from_array(chars : ArrayView[Char]) -> String {\n  let buf = StringBuilder::new(size_hint=chars.length() * 4)\n  for c in chars {\n    buf.write_char(c)\n  }\n  buf.to_string()\n}\n\n///|\n/// Convert char iterator to string,\n#alias(from_iterator, deprecated)\npub fn String::from_iter(iter : Iter[Char]) -> String {\n  let buf = StringBuilder::new()\n  for c in iter {\n    buf.write_char(c)\n  }\n  buf.to_string()\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n#deprecated(\"check `@encoding/utf8.encode`\")\n#coverage.skip\npub fn Bytes::of_string(str : String) -> Bytes {\n  let arr = FixedArray::make(str.length() * 2, Byte::default())\n  arr.blit_from_string(0, str, 0, str.length())\n  arr.unsafe_reinterpret_as_bytes()\n}\n\n///|\n#deprecated(\"Bytes are immutable. Use `FixedArray::blit_from_bytes` if it's really necessary.\")\npub fn Bytes::copy(self : Bytes) -> Bytes {\n  Bytes::makei(self.length(), i => self[i])\n}\n\n///|\n/// positions.\n///\n/// Parameters:\n///\n/// - `byte_value` : The `Byte` value whose bits are to be shifted.\n/// - `shift_count` : The number of bit positions to shift the `byte_value` to\n///   the left.\n///\n/// Returns the resulting `Byte` value after the bitwise left shift operation.\n///\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn Byte::lsl(self : Byte, count : Int) -> Byte {\n  (self.to_int() << count).to_byte()\n}\n\n///|\n/// bits.\n///\n/// Parameters:\n///\n/// - `value` : The `Byte` value to be shifted.\n/// - `count` : The number of bits to shift the `value` to the right.\n///\n/// Returns the result of the logical shift right operation as a `Byte`.\n///\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn Byte::lsr(self : Byte, count : Int) -> Byte {\n  (self.to_uint() >> count).reinterpret_as_int().to_byte()\n}\n\n///|\n/// Prints and returns the value of a given expression for quick and dirty debugging.\n/// This could also be useful to print some logs to trace the progress.\n/// For example, you can put `dump(())` in each line, the execution will print the line number\n/// when it reaches that line.\n#callsite(autofill(loc))\n#deprecated(\"This function is for debugging only and should not be used in production\", skip_current_package=true)\npub fn[T] dump(t : T, name? : String, loc~ : SourceLoc) -> T {\n  let name = match name {\n    Some(name) => name\n    None => \"\"\n  }\n  println(\"dump(\\{name}@\\{loc}) = \\{any_to_string(t)}\")\n  t\n}\n\n///|\ntest \"dump\" {\n  let x = 42\n  if false {\n    dump(()) // never reached here\n    assert_eq(dump(x) + x, 84)\n  }\n}\n\n///|\n/// Returns the Unicode code point at the given index without bounds checking.\n#deprecated(\"Use `s.get_char(i).unwrap()` instead\", skip_current_package=true)\npub fn String::unsafe_char_at(self : String, index : Int) -> Char {\n  let c1 = self.unsafe_get(index)\n  if c1.is_leading_surrogate() {\n    let c2 = self.unsafe_get(index + 1)\n    code_point_of_surrogate_pair(c1.to_int(), c2.to_int())\n  } else {\n    c1.unsafe_to_char()\n  }\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Represents a source code location in a MoonBit program, containing\n/// information about the file path, line number, and column number. Used\n/// internally by the compiler for error reporting and debugging purposes.\n///\n/// This type is public to all packages but its internal representation is\n/// opaque. Users cannot construct values of this type directly; they are\n/// automatically created by the compiler when needed.\n/// TODO: can not make a dummy loc\npub(all) type SourceLoc\n\n///|\n/// Converts a source location to its string representation.\n///\n/// Parameters:\n///\n/// * `source_location` : A source code location containing information about the\n/// file path, line number, and column number.\n///\n/// Returns a string representation of the source location, typically in the\n/// format \"@package:file:start_line:start_column-end_line:end_column\".\n///\n/// Note: This function is primarily used internally by the compiler for error\n/// reporting and debugging purposes. Source locations are automatically created\n/// by the compiler when needed.\nfn SourceLoc::repr(self : Self) -> String = \"%loc_to_string\"\n\n///|\npub impl Show for SourceLoc with output(self, logger) {\n  SourceLocRepr::parse(self.repr()).output(logger)\n}\n\n///|\npriv struct SourceLocRepr {\n  pkg : StringView\n  filename : StringView\n  start_line : StringView\n  start_column : StringView\n  end_line : StringView\n  end_column : StringView\n}\n\n///|\nimpl Show for SourceLocRepr with output(self, logger) {\n  let pkg = self.pkg\n  let (module_name, package_name) = lexmatch pkg {\n    ((\"[^/]*/[^/]*\" as module_name) \"/\" (\".*\" as package_name)) =>\n      (module_name, Some(package_name))\n    _ => (pkg, None)\n  }\n  if package_name is Some(pkg_name) {\n    logger.write_view(pkg_name)\n    logger.write_char('/')\n  }\n  logger.write_view(self.filename)\n  logger.write_char(':')\n  logger.write_view(self.start_line)\n  logger.write_char(':')\n  logger.write_view(self.start_column)\n  logger.write_char('-')\n  logger.write_view(self.end_line)\n  logger.write_char(':')\n  logger.write_view(self.end_column)\n  logger.write_char('@')\n  logger.write_view(module_name)\n}\n\n///|\nfn SourceLocRepr::parse(repr : String) -> SourceLocRepr {\n  lexmatch repr[:] {\n    (\n      \"@\"\n      (\"[^:]*\" as pkg)\n      \":\"\n      (\".+?\" as filename)\n      \":\"\n      (\"[[:digit:]]+\" as start_line)\n      \":\"\n      (\"[[:digit:]]+\" as start_column)\n      \"-\"\n      (\"[[:digit:]]+\" as end_line)\n      \":\"\n      (\"[[:digit:]]+\" as end_column)\n    ) => { pkg, filename, start_line, start_column, end_line, end_column }\n    _ => panic()\n  }\n}\n\n///|\nfn SourceLocRepr::to_json_string(self : SourceLocRepr) -> String {\n  let sb = StringBuilder::new()\n  sb.write_string(\"{\\\"pkg\\\":\\\"\\{self.pkg}\\\"\")\n  sb.write_string(\",\\\"filename\\\":\")\n  sb.write_object(self.filename)\n  sb.write_string(\",\\\"start_line\\\":\\{self.start_line}\")\n  sb.write_string(\",\\\"start_column\\\":\\{self.start_column}\")\n  sb.write_string(\",\\\"end_line\\\":\\{self.end_line}\")\n  sb.write_string(\",\\\"end_column\\\":\\{self.end_column}}\")\n  sb.to_string()\n}\n\n///|\n/// Convert a source location to a JSON string\npub fn SourceLoc::to_json_string(self : SourceLoc) -> String {\n  SourceLocRepr::parse(self.repr()).to_json_string()\n}\n\n///|\n/// Represents a type for storing argument locations in source code. It is an\n/// array of optional source locations, where each element corresponds to an\n/// argument's location in the source code. Used internally by the compiler for\n/// error reporting and debugging purposes.\npub(all) struct ArgsLoc(Array[SourceLoc?]) derive(Show)\n\n///|\n/// Converts an array of optional source locations to its JSON string\n/// representation. Each location in the array is either represented as a string\n/// if present, or \"null\" if absent.\n///\n/// Parameters:\n///\n/// * `self` : The array of optional source locations to be converted.\n///\n/// Returns a JSON array string where each element is either a string\n/// representation of a source location or \"null\".\npub fn ArgsLoc::to_json(self : ArgsLoc) -> String {\n  let buf = StringBuilder::new(size_hint=10)\n  let ArgsLoc(self) = self\n  buf.write_char('[')\n  for i in 0..<self.length() {\n    if i != 0 {\n      buf.write_string(\", \")\n    }\n    let item = self[i]\n    match item {\n      None => buf.write_string(\"null\")\n      Some(loc) => buf.write_string(loc.to_json_string())\n    }\n  }\n  buf.write_char(']')\n  buf.to_string()\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Trait for types whose elements can test for equality\npub(open) trait Eq {\n  equal(Self, Self) -> Bool = _\n  #deprecated(\"use `equal` instead\", skip_current_package=true)\n  op_equal(Self, Self) -> Bool = _\n  not_equal(Self, Self) -> Bool = _\n}\n\n///|\nimpl Eq with not_equal(x, y) {\n  !(x == y)\n}\n\n///|\n/// Trait for types whose elements are ordered\n///\n/// The return value of [compare] is:\n/// - zero, if the two arguments are equal\n/// - negative, if the first argument is smaller\n/// - positive, if the first argument is greater\npub(open) trait Compare: Eq {\n  compare(Self, Self) -> Int\n  op_lt(Self, Self) -> Bool = _\n  op_gt(Self, Self) -> Bool = _\n  op_le(Self, Self) -> Bool = _\n  op_ge(Self, Self) -> Bool = _\n}\n\n///|\nimpl Compare with op_lt(x, y) {\n  x.compare(y).is_neg()\n}\n\n///|\nimpl Compare with op_gt(x, y) {\n  x.compare(y).is_pos()\n}\n\n///|\nimpl Compare with op_le(x, y) {\n  x.compare(y).is_non_pos()\n}\n\n///|\nimpl Compare with op_ge(x, y) {\n  x.compare(y).is_non_neg()\n}\n\n///|\n/// Trait for types that can be hashed\n/// \n/// The `hash` method should return a hash value for the type, which is used in hash tables and other data structures.\n/// The `hash_combine` method is used to combine the hash of the current value with another hash value,\n/// typically used to hash composite types.\n/// \n/// When two values are equal according to the `Eq` trait, they should produce the same hash value.\n/// \n/// The `hash` method does not need to be implemented if `hash_combine` is implemented,\n/// When implemented separately, `hash` **does not need** to produce a hash value that is consistent with `hash_combine`.\npub(open) trait Hash {\n  hash_combine(Self, Hasher) -> Unit\n  hash(Self) -> Int = _\n}\n\n///|\nimpl Hash with hash(self) {\n  let h = Hasher::new()\n  h.combine(self)\n  h.finalize()\n}\n\n///|\n/// Trait for types with a default value\npub(open) trait Default {\n  default() -> Self\n}\n\n///|\n/// Trait for a logger, where debug logs can be written into\npub(open) trait Logger {\n  write_string(Self, String) -> Unit = _\n  #deprecated(\"use `write_view` instead\", skip_current_package=true)\n  write_substring(Self, String, Int, Int) -> Unit = _\n  write_view(Self, StringView) -> Unit = _\n  write_char(Self, Char) -> Unit = _\n}\n\n///|\nimpl Logger with write_substring(self, value, start, len) {\n  self.write_view(try! value[start:start + len])\n}\n\n///|\nimpl Logger with write_string(self, value) {\n  self.write_view(value[:])\n}\n\n///|\n#deprecated(\"replace `impl write_substring` with `impl write_view`\")\nimpl Logger with write_view(self, value) {\n  self.write_substring(value.data(), value.start_offset(), value.length())\n}\n\n///|\nimpl Logger with write_char(self, value) {\n  self.write_string([value])\n}\n\n///|\n/// Trait for types that can be converted to `String`\npub(open) trait Show {\n  // `output` is used for composition of aggregate structure.\n  // `output` writes a string representation of `self` to a logger.\n  // `output` should produce a valid MoonBit-syntax representation if possible.\n  // For example, `Show::output` for `String` should be quoted\n  output(Self, &Logger) -> Unit\n  // `to_string` should be used by end users of `Show`,\n  // for printing, interpolation, etc. only, and should not be used for composition.\n  // By default `to_string` is implemented using `output` and a buffer,\n  // but some types, such as `String`, may override `to_string`,\n  // for different (unescaped) behavior when interpolated/printed directly\n  to_string(Self) -> String = _\n}\n\n///|\n/// Default implementation for `Show::to_string`, uses a `StringBuilder`\nimpl Show with to_string(self) {\n  let logger = StringBuilder::new()\n  self.output(logger)\n  logger.to_string()\n}\n\n///|\npub fn[Obj : Show] &Logger::write_object(self : &Logger, obj : Obj) -> Unit {\n  obj.output(self)\n}\n\n///|\npub fn[T : Show] &Logger::write_iter(\n  self : &Logger,\n  iter : Iter[T],\n  prefix? : String = \"[\",\n  suffix? : String = \"]\",\n  sep? : String = \", \",\n  trailing? : Bool = false,\n) -> Unit {\n  self.write_string(prefix)\n  if trailing {\n    for x in iter {\n      self.write_object(x)\n      self.write_string(sep)\n    }\n  } else if iter.next() is Some(x) {\n    self.write_object(x)\n    for x in iter {\n      self.write_string(sep)\n      self.write_object(x)\n    }\n  }\n  self.write_string(suffix)\n}\n// TODO: Logger::write_double(self:Logger, val:Double) -> Unit\n\n///|\npub fn[T : Show] repr(t : T) -> String {\n  let logger = StringBuilder::new()\n  t.output(logger)\n  logger.to_string()\n}\n\n///|\n#deprecated(\"replace `impl op_equal` with `impl equal`\")\nimpl Eq with equal(self, other) {\n  Eq::op_equal(self, other)\n}\n\n///|\nimpl Eq with op_equal(self, other) {\n  Eq::equal(self, other)\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Returns the source string being viewed.\nfn StringView::str(self : StringView) -> String = \"%stringview.str\"\n\n///|\n/// Returns the starting UTF-16 code unit index into the string.\nfn StringView::start(self : StringView) -> Int = \"%stringview.start\"\n\n///|\n/// Returns the ending UTF-16 code unit index into the string (not included).\nfn StringView::end(self : StringView) -> Int = \"%stringview.end\"\n\n///|\nfn StringView::make_view(str : String, start : Int, end : Int) -> StringView = \"%stringview.make\"\n\n///|\n/// Returns the UTF-16 code unit at the given index.\n/// \n/// This method has O(1) complexity.\n/// Panics if the index is out of bounds.\n/// TODO: make it intrinsic\n#alias(\"_[_]\")\n#alias(code_unit_at)\npub fn StringView::at(self : StringView, index : Int) -> UInt16 {\n  guard index >= 0 && index < self.length() else {\n    abort(\"Index out of bounds\")\n  }\n  self.unsafe_get(index)\n}\n\n///|\n/// Returns the length of the view.\n/// \n/// This method counts the charcodes(code unit) in the view and has O(1) complexity.\npub fn StringView::length(self : StringView) -> Int {\n  self.end() - self.start()\n}\n\n///|\n/// Iterates over all suffixes of the view, advancing by a Unicode character at\n/// a time. Each yielded suffix is itself a view into the original string.\npub fn StringView::suffixes(\n  self : StringView,\n  include_empty? : Bool = false,\n) -> Iter[StringView] {\n  let str = self.str()\n  let end = self.end()\n  let mut next_start = self.start()\n  let mut finished = false\n  Iter::new(fn() -> StringView? {\n    if finished {\n      None\n    } else if next_start == end {\n      finished = true\n      if include_empty {\n        Some(StringView::make_view(str, next_start, end))\n      } else {\n        None\n      }\n    } else {\n      let suffix = StringView::make_view(str, next_start, end)\n      let code = str.unsafe_get(next_start)\n      if code.is_leading_surrogate() &&\n        next_start + 1 < end &&\n        str.unsafe_get(next_start + 1).is_trailing_surrogate() {\n        next_start += 2\n      } else {\n        next_start += 1\n      }\n      Some(suffix)\n    }\n  })\n}\n\n///|\n/// Returns the original string that is being viewed.\npub fn StringView::data(self : StringView) -> String {\n  self.str()\n}\n\n///|\n/// Returns the starting offset (in UTF-16 code units) of this view into its\n/// underlying string.\npub fn StringView::start_offset(self : StringView) -> Int {\n  self.start()\n}\n\n///|\n/// Returns a new view of the view with the given start and end offsets.\npub fn StringView::view(\n  self : StringView,\n  start_offset? : Int = 0,\n  end_offset? : Int,\n) -> StringView {\n  let end_offset = if end_offset is Some(o) { o } else { self.length() }\n  guard start_offset >= 0 &&\n    start_offset <= end_offset &&\n    end_offset <= self.length() else {\n    abort(\"Invalid index for View\")\n  }\n  StringView::make_view(\n    self.str(),\n    self.start() + start_offset,\n    self.start() + end_offset,\n  )\n}\n\n///|\n/// Returns the UTF-16 code unit at the given index without checking if the\n/// index is within bounds.\n///\n/// This method has O(1) complexity.\n#internal(unsafe, \"Undefined behavior if index is out of bounds.\")\npub fn StringView::unsafe_get(self : StringView, index : Int) -> UInt16 {\n  self.str().unsafe_get(self.start() + index)\n}\n\n///|\n/// Returns the charcode(code unit) at the given index without checking if the\n/// index is within bounds.\n/// \n/// This method has O(1) complexity.\n/// #Example\n/// \n/// ```mbt check\n/// test {\n///   let str = \"BC\"\n///   let view = str[:]\n///   inspect(view.unsafe_get(0), content=\"66\")\n///   inspect(view.unsafe_get(1), content=\"55358\")\n///   inspect(view.unsafe_get(2), content=\"56611\")\n///   inspect(view.unsafe_get(3), content=\"55358\")\n///   inspect(view.unsafe_get(4), content=\"56611\")\n///   inspect(view.unsafe_get(5), content=\"67\")\n/// }\n/// ```\n#deprecated(\"Use `StringView::unsafe_get` instead\")\npub fn StringView::unsafe_charcode_at(self : StringView, index : Int) -> Int {\n  self.str().unsafe_get(self.start() + index).to_int()\n}\n\n///|\n/// Returns the number of Unicode characters in this view.\n/// \n/// Note this has O(n) complexity where n is the length of the code points in \n/// the view.\npub fn StringView::char_length(self : StringView) -> Int {\n  self.str().char_length(start_offset=self.start(), end_offset=self.end())\n}\n\n///|\npub impl Show for StringView with output(self, logger) {\n  let substr = self.str().unsafe_substring(start=self.start(), end=self.end())\n  String::output(substr, logger)\n}\n\n///|\n/// Returns a new String containing a copy of the characters in this view.\n/// \n/// # Examples\n/// \n/// ```mbt check\n/// test {\n///   let str = \"Hello World\"\n///   let view = str.view(\n///     start_offset=str.offset_of_nth_char(0).unwrap(),\n///     end_offset=str.offset_of_nth_char(5).unwrap(),\n///   ) // \"Hello\"\n///   inspect(view.to_string(), content=\"Hello\")\n/// }\n/// ```\npub impl Show for StringView with to_string(self) {\n  // when `self == self.str()`, `String::unsafe_substring` would return original string, which doesn't create a new copy.\n  self.str().unsafe_substring(start=self.start(), end=self.end())\n}\n\n///|\n/// Returns an iterator over the Unicode characters in the string view.\n#alias(iterator, deprecated)\npub fn StringView::iter(self : StringView) -> Iter[Char] {\n  let start = self.start()\n  let end = self.end()\n  let mut index = start\n  Iter::new(fn() {\n    guard index < end else { None }\n    let c1 = self.str().unsafe_get(index)\n    if c1.is_leading_surrogate() && index + 1 < self.end() {\n      let c2 = self.str().unsafe_get(index + 1)\n      if c2.is_trailing_surrogate() {\n        index += 2\n        return Some(code_point_of_surrogate_pair(c1.to_int(), c2.to_int()))\n      }\n    }\n    index += 1\n    Some(c1.unsafe_to_char())\n  })\n}\n\n///|\n/// Returns an iterator over the Unicode characters in the string view,\n/// yielding pairs of (character index, character).\n#alias(iterator2, deprecated)\npub fn StringView::iter2(self : StringView) -> Iter2[Int, Char] {\n  let start = self.start()\n  let end = self.end()\n  let mut index = start\n  let mut char_index = 0\n  Iter2::new(fn() {\n    guard index < end else { None }\n    let c1 = self.str().unsafe_get(index)\n    if c1.is_leading_surrogate() && index + 1 < self.end() {\n      let c2 = self.str().unsafe_get(index + 1)\n      if c2.is_trailing_surrogate() {\n        let result = (\n          char_index,\n          code_point_of_surrogate_pair(c1.to_int(), c2.to_int()),\n        )\n        index += 2\n        char_index += 1\n        return Some(result)\n      }\n    }\n    let result = (char_index, c1.unsafe_to_char())\n    index += 1\n    char_index += 1\n    Some(result)\n  })\n}\n\n///|\n/// Returns an iterator over the Unicode characters in the string view in reverse order.\n#alias(rev_iterator, deprecated)\npub fn StringView::rev_iter(self : StringView) -> Iter[Char] {\n  let start = self.start()\n  let end = self.end()\n  let mut index = end\n  Iter::new(fn() {\n    guard index > start else { None }\n    index -= 1\n    let c1 = self.str().unsafe_get(index)\n    if c1.is_trailing_surrogate() && index - 1 >= 0 {\n      let c2 = self.str().unsafe_get(index - 1)\n      if c2.is_leading_surrogate() {\n        index -= 1\n        return Some(code_point_of_surrogate_pair(c2.to_int(), c1.to_int()))\n      }\n    }\n    Some(c1.unsafe_to_char())\n  })\n}\n\n///|\n/// Compares two views for equality. Returns true only if both views\n/// have the same length and contain identical characters in the same order.\npub impl Eq for StringView with equal(self, other) {\n  let len = self.length()\n  guard len == other.length() else { return false }\n  if physical_equal(self.str(), other.str()) && self.start() == other.start() {\n    return true\n  }\n  for i in 0..<len {\n    guard self.str().unsafe_get(self.start() + i) ==\n      other.str().unsafe_get(other.start() + i) else {\n      return false\n    }\n  }\n  true\n}\n\n///|\n/// Views are ordered based on shortlex order by their charcodes (code units). This \n/// orders Unicode characters based on their positions in the code charts. This is\n/// not necessarily the same as \"alphabetical\" order, which varies by language\n/// and locale.\npub impl Compare for StringView with compare(self, other) {\n  let self_len = self.length()\n  let other_len = other.length()\n  let cmp = self_len.compare(other_len)\n  guard cmp == 0 else { return cmp }\n  if physical_equal(self.str(), other.str()) && self.start() == other.start() {\n    return 0\n  }\n  for i in 0..<self_len {\n    let cmp = self\n      .str()\n      .unsafe_get(self.start() + i)\n      .compare(other.str().unsafe_get(other.start() + i))\n    guard cmp == 0 else { return cmp }\n  }\n  0\n}\n\n///|\n/// Performs a lexicographical comparison of two string views.\n///\n/// This method compares the views character by character (UTF-16 code unit by code unit),\n/// similar to Java's `String.compareTo()`. Unlike the `Compare` trait implementation which\n/// uses shortlex order (shorter strings come first), this method compares based purely on\n/// character values until a difference is found or one view is exhausted.\n///\n/// # Returns\n///\n/// - A negative integer if `self` is lexicographically less than `other`\n/// - Zero if `self` is lexicographically equal to `other`\n/// - A positive integer if `self` is lexicographically greater than `other`\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let str = \"abc\"\n///   inspect(\n///     str\n///     .view(start_offset=0, end_offset=2)\n///     .lexical_compare(str.view(start_offset=0, end_offset=3)),\n///     content=\"-1\",\n///   )\n///   inspect(\n///     str\n///     .view(start_offset=0, end_offset=3)\n///     .lexical_compare(str.view(start_offset=0, end_offset=2)),\n///     content=\"1\",\n///   )\n///   inspect(\n///     str\n///     .view(start_offset=0, end_offset=2)\n///     .lexical_compare(str.view(start_offset=1, end_offset=3)),\n///     content=\"-1\",\n///   )\n/// }\n/// ```\n///\n/// # Note\n///\n/// Since MoonBit strings are UTF-16 encoded (like Java), this comparison operates on\n/// UTF-16 code units, not Unicode code points. Surrogate pairs (used for characters\n/// outside the Basic Multilingual Plane) are compared as individual code units.\npub fn StringView::lexical_compare(\n  self : StringView,\n  other : StringView,\n) -> Int {\n  let self_len = self.length()\n  let other_len = other.length()\n  let min_len = if self_len < other_len { self_len } else { other_len }\n\n  // Compare character by character up to the minimum length\n  for i in 0..<min_len {\n    let self_char = self.str().unsafe_get(self.start() + i)\n    let other_char = other.str().unsafe_get(other.start() + i)\n    let cmp = self_char.compare(other_char)\n    if cmp != 0 {\n      return cmp\n    }\n  }\n\n  // If all characters match up to min_len, the shorter one is lexicographically smaller\n  self_len.compare(other_len)\n}\n\n///|\n/// Creates a `View` into a `String`.\n/// \n/// # Example\n/// \n/// ```mbt check\n/// test {\n///   let str = \"Hello\"\n///   let view1 = str.view()\n///   inspect(view1, content=\"Hello\")\n///   let start_offset = str.offset_of_nth_char(1).unwrap()\n///   let end_offset = str.offset_of_nth_char(6).unwrap() // the second emoji\n///   let view2 = str.view(start_offset~, end_offset~)\n///   inspect(view2, content=\"ello\")\n/// }\n/// ```\npub fn String::view(\n  self : String,\n  start_offset? : Int = 0,\n  end_offset? : Int,\n) -> StringView {\n  let end_offset = if end_offset is Some(o) { o } else { self.length() }\n  guard start_offset >= 0 &&\n    start_offset <= end_offset &&\n    end_offset <= self.length() else {\n    abort(\"Invalid index for View\")\n  }\n  StringView::make_view(self, start_offset, end_offset)\n}\n\n///|\n/// Convert char array to string view.\npub fn StringView::from_array(chars : ArrayView[Char]) -> StringView {\n  String::from_array(chars)\n}\n\n///|\n/// Convert char iterator to string view.\n#alias(from_iterator, deprecated)\npub fn StringView::from_iter(iter : Iter[Char]) -> StringView {\n  String::from_iter(iter)\n}\n\n///|\npub suberror CreatingViewError {\n  IndexOutOfBounds\n  InvalidIndex\n} derive(Show)\n\n///|\n/// Creates a view of a string with proper UTF-16 boundary validation.\n/// \n/// # Parameters\n/// \n/// - `start` : Starting UTF-16 code unit index (default: 0)\n///   - If positive: counts from the beginning of the string\n///   - If negative: counts from the end of the string (e.g., -1 means last position)\n/// - `end` : Ending UTF-16 code unit index (optional)\n///   - If `None`: extends to the end of the string\n///   - If positive: counts from the beginning of the string\n///   - If negative: counts from the end of the string\n/// \n/// # Returns\n/// \n/// - A `View` representing the specified substring range\n/// \n/// # Errors\n/// \n/// - `IndexOutOfBounds` : If start or end indices are out of valid range\n/// - `InvalidIndex` : If start or end position would split a UTF-16 surrogate pair\n/// \n/// This prevents creating views that would split surrogate pairs, which would\n/// result in invalid Unicode characters.\n/// \n/// # Performance\n/// \n/// This function has O(1) complexity as it only performs boundary checks\n/// without scanning the string content.\n/// \n/// # Examples\n/// \n/// ```mbt nocheck\n/// let str = \"HelloWorld\"\n/// let view1 =  str[0:5]\n/// inspect(\n///   view1,\n///   content=(\n///     \"Hello\"\n///   ),\n/// )\n/// let view2 = try? str[-5:]\n/// inspect(\n///   view2,\n///   content=(\n///     #|Ok(\"World\")\n///   ),\n/// )\n/// let view3 = try? str[:6]\n/// inspect(view3, content=\"Err(InvalidIndex)\")\n/// ```\n#alias(\"_[_:_]\")\npub fn String::sub(\n  self : String,\n  start? : Int = 0,\n  end? : Int,\n) -> StringView raise CreatingViewError {\n  let len = self.length()\n  let end = match end {\n    None => len\n    Some(end) => if end < 0 { len + end } else { end }\n  }\n  let start = if start < 0 { len + start } else { start }\n  guard start >= 0 && start <= end && end <= len else { raise IndexOutOfBounds }\n  if start < len && self.unsafe_get(start).is_trailing_surrogate() {\n    raise InvalidIndex\n  }\n  if end < len && self.unsafe_get(end).is_trailing_surrogate() {\n    raise InvalidIndex\n  }\n  StringView::make_view(self, start, end)\n}\n\n///|\n/// Creates a subview of an existing view with proper UTF-16 boundary validation.\n/// \n/// # Parameters\n/// \n/// - `start` : Starting UTF-16 code unit index relative to this view (default: 0)\n///   - If positive: counts from the beginning of this view\n///   - If negative: counts from the end of this view\n/// - `end` : Ending UTF-16 code unit index relative to this view (optional)\n///   - If `None`: extends to the end of this view\n///   - If positive: counts from the beginning of this view\n///   - If negative: counts from the end of this view\n/// \n/// # Returns\n/// \n/// - A `View` representing the specified subrange of this view\n/// \n/// # Errors\n/// \n/// - `IndexOutOfBounds` : If start or end indices are out of this view's range\n/// - `InvalidIndex` : If start or end position would split a UTF-16 surrogate pair\n/// \n/// This prevents creating views that would split surrogate pairs, which would\n/// result in invalid Unicode characters.\n/// \n/// # Performance\n/// \n/// This function has O(1) complexity as it only performs boundary checks\n/// without scanning the string content.\n/// \n/// # Examples\n/// \n/// ```mbt check\n/// test {\n///   let str = \"HelloWorld\"[1:-1] // \"elloWorl\"\n///   let view1 = str[0:6]\n///   inspect(view1, content=\"ello\")\n///   let view2 = str[-2:]\n///   inspect(view2, content=\"rl\")\n///   let view3 = try? str[:5]\n///   inspect(view3, content=\"Err(InvalidIndex)\")\n/// }\n/// ```\n#alias(\"_[_:_]\")\npub fn StringView::sub(\n  self : StringView,\n  start? : Int = 0,\n  end? : Int,\n) -> StringView raise CreatingViewError {\n  let str_len = self.str().length()\n\n  // Calculate absolute positions in the original string\n  let abs_end = match end {\n    None => self.end()\n    Some(end) => if end < 0 { self.end() + end } else { self.start() + end }\n  }\n  let abs_start = if start < 0 {\n    self.end() + start\n  } else {\n    self.start() + start\n  }\n\n  // Validate bounds against the original string\n  guard abs_start >= self.start() &&\n    abs_start <= abs_end &&\n    abs_end <= self.end() else {\n    raise IndexOutOfBounds\n  }\n\n  // Check for surrogate pair boundaries\n  if abs_start < str_len &&\n    self.str().unsafe_get(abs_start).is_trailing_surrogate() {\n    raise InvalidIndex\n  }\n  if abs_end < str_len && self.str().unsafe_get(abs_end).is_trailing_surrogate() {\n    raise InvalidIndex\n  }\n  StringView::make_view(self.str(), abs_start, abs_end)\n}\n\n///|\n/// Test if the length of the view is equal to the given length.\n/// \n/// This has O(n) complexity where n is the length in the parameter.\npub fn StringView::char_length_eq(self : StringView, len : Int) -> Bool {\n  self\n  .str()\n  .char_length_eq(len, start_offset=self.start(), end_offset=self.end())\n}\n\n///|\n/// Test if the length of the view is greater than or equal to the given length.\n/// \n/// This has O(n) complexity where n is the length in the parameter.\npub fn StringView::char_length_ge(self : StringView, len : Int) -> Bool {\n  self\n  .str()\n  .char_length_ge(len, start_offset=self.start(), end_offset=self.end())\n}\n\n///|\n/// Returns the UTF-16 index of the i-th (zero-indexed) Unicode character of\n/// the view. If i is negative, it returns the index of the (n + i)-th character\n/// where n is the total number of Unicode characters in the view.\npub fn StringView::offset_of_nth_char(self : StringView, i : Int) -> Int? {\n  if self\n    .str()\n    .offset_of_nth_char(i, start_offset=self.start(), end_offset=self.end())\n    is Some(index) {\n    Some(index - self.start())\n  } else {\n    None\n  }\n}\n\n///|\n/// The empty view of a string\npub impl Default for StringView with default() {\n  \"\"\n}\n\n///|\n/// Create a new string by repeating the given character `value` `length` times.\npub fn StringView::make(length : Int, value : Char) -> StringView {\n  String::make(length, value)\n}\n\n///|\npub impl ToJson for StringView with to_json(self) {\n  String::to_json(self.to_string())\n}\n\n///|\npub impl Add for StringView with add(self, other) {\n  [..self, ..other]\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// External iterator type.\n/// `Iterator[X]` is a mutable type: iterators internally maintain mutable state\n/// to advance iteration.\n/// All read operations on `Iterator` will advance the iterator,\n/// and would give different result when called multiple times.\n#alias(Iterator, deprecated=\"The name `Iterator` is deprecated, use `Iter` instead. Note that if you have defined `iterator()` method to support `for .. in` loop, you should also rename `iterator()` to `iter()`. See https://github.com/moonbitlang/core/pull/3127 for more details.\")\nstruct Iter[X](() -> X?)\n\n///|\n/// Get the next element from an iterator, or return `None` if no more element exists.\n/// The returned element will be consumed from the iterator.\n/// Calling `next` repeatedly will iterate through all elements in the iterator.\n#alias(peek, deprecated)\n#alias(head)\npub fn[X] Iter::next(self : Iter[X]) -> X? {\n  (self.0)()\n}\n\n///|\n#locals(f)\n#deprecated(\"write a loop instead.\")\npub fn[X] Iter::run(self : Iter[X], f : (X) -> IterResult) -> IterResult {\n  while self.next() is Some(x) {\n    guard f(x) is IterContinue else { break IterEnd }\n  } else {\n    IterContinue\n  }\n}\n\n///|\n#deprecated(\"write a loop instead.\")\npub fn[X] Iter::just_run(self : Iter[X], f : (X) -> IterResult) -> Unit {\n  while self.next() is Some(x) {\n    if f(x) is IterEnd {\n      break\n    }\n  }\n}\n\n///|\npub impl[X : Show] Show for Iter[X] with output(self, logger) {\n  logger.write_string(\"[\")\n  if self.next() is Some(x) {\n    logger.write_object(x)\n    while self.next() is Some(x) {\n      logger.write_string(\", \")\n      logger.write_object(x)\n    }\n  }\n  logger.write_string(\"]\")\n}\n\n///|\npub impl[X : ToJson] ToJson for Iter[X] with to_json(self) {\n  Json::array(self.map(x => x.to_json()).collect())\n}\n\n///|\n/// Iterates over each element in the iterator, applying the function `f` to each element.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// - `self`: The iterator to consume.\n/// - `f`: A function that takes an element of type `X` and returns `Unit`. This function is applied to each element of the iterator.\n#locals(f)\npub fn[X] Iter::each(self : Iter[X], f : (X) -> Unit raise?) -> Unit raise? {\n  while self.next() is Some(x) {\n    f(x)\n  }\n}\n\n///|\n#locals(f)\npub fn[X] Iter::any(self : Iter[X], f : (X) -> Bool) -> Bool {\n  while self.next() is Some(x) {\n    if f(x) {\n      break true\n    }\n  } else {\n    false\n  }\n}\n\n///|\n#locals(f)\npub fn[X] Iter::all(self : Iter[X], f : (X) -> Bool) -> Bool {\n  while self.next() is Some(x) {\n    guard f(x) else { break false }\n  } else {\n    true\n  }\n}\n\n///|\n/// Iterates over each element in the iterator, applying the function `f` to each element with index.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// - `self`: The iterator to consume.\n/// - `f`: A function that takes an index of type `Int` and an element of type `X` and returns `Unit`. This function is applied to each element of the iterator.\n#locals(f)\npub fn[X] Iter::eachi(\n  self : Iter[X],\n  f : (Int, X) -> Unit raise?,\n) -> Unit raise? {\n  let mut i = 0\n  while self.next() is Some(x) {\n    f(i, x)\n    i += 1\n  }\n}\n\n///|\n/// Folds the elements of the iterator using the given function, starting with the given initial value.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n/// - `R`: The type of the accumulator (result) value.\n///\n/// # Arguments\n///\n/// - `self`: The iterator to consume.\n/// - `f`: A function that takes an accumulator of type `R` and an element of type `X`, and returns a new accumulator value.\n/// - `init`: The initial value for the fold operation.\n///\n/// # Returns\n///\n/// Returns the final accumulator value after folding all elements of the iterator.\n#locals(f)\npub fn[X, R] Iter::fold(\n  self : Iter[X],\n  init~ : R,\n  f : (R, X) -> R raise?,\n) -> R raise? {\n  let mut acc = init\n  while self.next() is Some(x) {\n    acc = f(acc, x)\n  }\n  acc\n}\n\n///|\n/// Counts the number of elements in the iterator.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// - `self`: The iterator to consume.\n///\n/// # Returns\n///\n/// Returns the number of elements in the iterator.\npub fn[X] Iter::count(self : Iter[X]) -> Int {\n  self.fold((acc, _) => acc + 1, init=0)\n}\n\n// Producers\n\n///|\n/// Create a new iterator by supplying a `next` function directly.\n/// The supplied function should output the next element being iterated\n/// everytime it is called.\n///\n/// This function is intended for use by data structure authors,\n/// and should not be called by end users in general.\npub fn[X] Iter::new(f : () -> X?) -> Iter[X] {\n  Iter(f)\n}\n\n///|\n/// Creates an empty iterator.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Returns\n///\n/// Returns an empty iterator of type `Iter[X]`.\npub fn[X] Iter::empty() -> Iter[X] {\n  () => None\n}\n\n///|\n/// Creates an iterator that contains a single element.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the element in the iterator.\n///\n/// # Arguments\n///\n/// - `elem`: The single element to be contained in the iterator.\n///\n/// # Returns\n///\n/// Returns an iterator of type `Iter[X]` that contains the single element `a`.\npub fn[X] Iter::singleton(elem : X) -> Iter[X] {\n  let mut consumed = false\n  fn() {\n    if consumed {\n      None\n    } else {\n      consumed = true\n      Some(elem)\n    }\n  }\n}\n\n///|\n/// Creates an iterator that repeats the given element indefinitely.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// - `x`: The element to be repeated.\n///\n/// # Returns\n///\n/// Returns an iterator of type `Iter[X]` that repeats the element `x` indefinitely.\npub fn[X] Iter::repeat(x : X) -> Iter[X] {\n  () => Some(x)\n}\n\n///|\n/// Filters the elements of the iterator based on a predicate function.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `f` - The predicate function that determines whether an element should be included in the filtered iterator.\n///\n/// # Returns\n///\n/// A new iterator that only contains the elements for which the predicate function returns `IterContinue`.\n///\n/// # Note\n/// The old iterator `self` must not be used again after calling `filter`.\npub fn[X] Iter::filter(self : Iter[X], f : (X) -> Bool) -> Iter[X] {\n  fn() {\n    while self.next() is Some(x) {\n      if f(x) {\n        break Some(x)\n      }\n    } else {\n      None\n    }\n  }\n}\n\n///|\n/// Transforms the elements of the iterator using a mapping function.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n/// - `Y`: The type of the transformed elements.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `f` - The mapping function that transforms each element of the iterator.\n///\n/// # Returns\n///\n/// A new iterator that contains the transformed elements.\n///\n/// # Note\n/// The old iterator `self` must not be used again after calling `map`.\npub fn[X, Y] Iter::map(self : Iter[X], f : (X) -> Y) -> Iter[Y] {\n  fn() {\n    match self.next() {\n      Some(x) => Some(f(x))\n      None => None\n    }\n  }\n}\n\n///|\n/// Transforms the elements of the iterator using a mapping function.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n/// - `Y`: The type of the transformed elements.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `f` - The mapping function that transforms each element of the iterator with index.\n///\n/// # Returns\n///\n/// A new iterator that contains the transformed elements.\n///\n/// # Note\n/// The old iterator `self` must not be used again after calling `mapi`.\npub fn[X, Y] Iter::mapi(self : Iter[X], f : (Int, X) -> Y) -> Iter[Y] {\n  let mut i = 0\n  fn() {\n    match self.next() {\n      Some(x) => {\n        let result = f(i, x)\n        i += 1\n        Some(result)\n      }\n      None => None\n    }\n  }\n}\n\n///|\n/// Transforms the elements of the iterator using a mapping function that returns an `Option`.\n/// The elements for which the function returns `None` are filtered out.\n///\n/// The old iterator `self` must not be used again after calling `filter_map`.\npub fn[X, Y] Iter::filter_map(self : Iter[X], f : (X) -> Y?) -> Iter[Y] {\n  fn() {\n    while self.next() is Some(x) {\n      match f(x) {\n        Some(_) as y => break y\n        None => ()\n      }\n    } else {\n      None\n    }\n  }\n}\n\n///|\n/// Transforms each element of the iterator into an iterator and flattens the resulting iterators into a single iterator.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n/// - `Y`: The type of the transformed elements.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `f` - The function that transforms each element of the iterator into an iterator.\n///\n/// # Returns\n///\n/// A new iterator that contains the flattened elements.\n///\n/// # Note\n/// The old iterator `self` and the iterators returned by `f`\n/// must not be used again after calling `flat_map`.\npub fn[X, Y] Iter::flat_map(self : Iter[X], f : (X) -> Iter[Y]) -> Iter[Y] {\n  let mut current_iter = Some(Iter::empty())\n  fn() {\n    guard current_iter is Some(iter) else { None }\n    loop iter.next() {\n      Some(_) as elem => elem\n      None => {\n        guard self.next() is Some(x) else { None }\n        let iter = f(x)\n        current_iter = Some(iter)\n        continue iter.next()\n      }\n    }\n  }\n}\n\n///|\n/// `iter.map(f).flatten() == iter.flat_map(f)`\npub fn[X] Iter::flatten(self : Iter[Iter[X]]) -> Iter[X] {\n  self.flat_map(it => it)\n}\n\n///|\n/// Collects the elements of the iterator into a string.\n/// The old iterator `self` must not be used again after calling `join`.\npub fn Iter::join(self : Iter[String], sep : String) -> String {\n  let result = StringBuilder::new()\n  if self.next() is Some(x) {\n    result.write_string(x)\n    while self.next() is Some(x) {\n      result.write_string(sep)\n      result.write_string(x)\n    }\n  }\n  result.to_string()\n}\n\n///|\n/// Applies a function to each element of the iterator without modifying the iterator.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `f` - The function to apply to each element of the iterator.\n///\n/// # Returns\n///\n/// The same iterator.\n///\n/// # Note\n/// The old iterator `self` must not be used again after calling `tap`.\npub fn[X] Iter::tap(self : Iter[X], f : (X) -> Unit) -> Iter[X] {\n  fn() {\n    let result = self.next()\n    if result is Some(x) {\n      f(x)\n    }\n    result\n  }\n}\n\n///|\n/// Takes the first `n` elements from the iterator.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `n` - The number of elements to take.\n///\n/// # Returns\n///\n/// A new iterator that contains the first `n` elements.\n///\n/// # Note\n/// The old iterator `self` must not be used again after calling `take`.\npub fn[X] Iter::take(self : Iter[X], n : Int) -> Iter[X] {\n  let mut remaining = n\n  fn() {\n    guard remaining > 0 else { None }\n    let result = self.next()\n    if result is Some(_) {\n      remaining -= 1\n    }\n    result\n  }\n}\n\n///|\n/// Takes elements from the iterator as long as the predicate function returns `true`.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `f` - The predicate function that determines whether an element should be taken.\n///\n/// # Returns\n///\n/// A new iterator that contains the elements as long as the predicate function returns `true`.\n///\n/// # Note\n/// The old iterator `self` must not be used again after calling `take_while`.\npub fn[X] Iter::take_while(self : Iter[X], f : (X) -> Bool) -> Iter[X] {\n  let mut still_running = true\n  fn() {\n    guard still_running else { None }\n    let result = self.next()\n    if result is Some(x) && !f(x) {\n      still_running = false\n      None\n    } else {\n      result\n    }\n  }\n}\n\n///|\n/// Transforms the elements of the iterator using a mapping function upto the function returns `None`.\n/// The old iterator `self` must not be used again after calling `map_while`.\npub fn[X, Y] Iter::map_while(self : Iter[X], f : (X) -> Y?) -> Iter[Y] {\n  let mut still_running = true\n  fn() {\n    guard still_running else { None }\n    let src = self.next()\n    guard src is Some(x) else { None }\n    let result = f(x)\n    if result is None {\n      still_running = false\n    }\n    result\n  }\n}\n\n///|\n/// Skips the first `n` elements from the iterator.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `n` - The number of elements to skip.\n///\n/// # Returns\n///\n/// A new iterator that starts after skipping the first `n` elements.\n///\n/// # Note\n/// The old iterator `self` must not be used again after calling `drop`.\npub fn[X] Iter::drop(self : Iter[X], n : Int) -> Iter[X] {\n  let mut remaining = n\n  fn() {\n    while remaining > 0 {\n      guard self.next() is Some(_) else { break None }\n      remaining -= 1\n    } else {\n      self.next()\n    }\n  }\n}\n\n///|\n/// Skips elements from the iterator as long as the predicate function returns `true`.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `f` - The predicate function that determines whether an element should be skipped.\n///\n/// # Returns\n///\n/// A new iterator that starts after skipping the elements as long as the predicate function returns `true`.\n///\n/// # Note\n/// The old iterator `self` must not be used again after calling `drop_while`.\npub fn[X] Iter::drop_while(self : Iter[X], f : (X) -> Bool) -> Iter[X] {\n  let mut dropped = false\n  fn() {\n    if !dropped {\n      dropped = true\n      loop self.next() {\n        Some(x) if f(x) => continue self.next()\n        result => result\n      }\n    } else {\n      self.next()\n    }\n  }\n}\n\n///|\n/// Finds the first element in the iterator that satisfies the predicate function.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterator.\n///\n/// # Arguments\n///\n/// * `self` - The input iterator.\n/// * `f` - The predicate function that determines whether an element is the first element to be found.\n///\n/// # Returns\n///\n/// An `Option` that contains the first element that satisfies the predicate function, or `None` if no such element is found.\n///\n/// # Note\n/// The iterator `self` will advance past the returned element.\npub fn[X] Iter::find_first(self : Iter[X], f : (X) -> Bool) -> X? {\n  while self.next() is Some(x) {\n    if f(x) {\n      break Some(x)\n    }\n  } else {\n    None\n  }\n}\n\n///|\n/// Combines two iterators into one by appending the elements of the second iterator to the first.\n///\n/// # Type Parameters\n///\n/// - `X`: The type of the elements in the iterators.\n///\n/// # Arguments\n///\n/// * `self` - The first input iterator.\n/// * `other` - The second input iterator to be appended to the first.\n///\n/// # Returns\n///\n/// Returns a new iterator that contains the elements of `self` followed by the elements of `other`.\n///\n/// # Note\n/// The old iterator `self` and `other` must not be used again after calling `tap`.\npub fn[X] Iter::concat(self : Iter[X], other : Iter[X]) -> Iter[X] {\n  let mut in_first = true\n  fn() {\n    if in_first {\n      let result = self.next()\n      if result is None {\n        in_first = false\n        other.next()\n      } else {\n        result\n      }\n    } else {\n      other.next()\n    }\n  }\n}\n\n///|\npub impl[T] Add for Iter[T] with add(self, other) {\n  self.concat(other)\n}\n\n///|\n/// Collects the elements of the iterator into an array.\n/// The old iterator `self` must not be used again.\n#alias(collect)\npub fn[X] Iter::to_array(self : Iter[X]) -> Array[X] {\n  let result = []\n  while self.next() is Some(x) {\n    result.push(x)\n  }\n  result\n}\n\n///|\n#alias(iterator)\npub fn[X] Iter::iter(self : Iter[X]) -> Iter[X] {\n  self\n}\n\n///|\n#alias(iterator2)\npub fn[X] Iter::iter2(self : Iter[X]) -> Iter2[Int, X] {\n  let mut i = 0\n  Iter(() => {\n    guard self.next() is Some(elem) else { None }\n    let result = Some((i, elem))\n    i += 1\n    result\n  })\n}\n\n///|\n/// Returns the last element of the iterator, or `None` if the iterator is empty.\n/// The old iterator `self` must not be used again after calling `last`.\npub fn[X] Iter::last(self : Iter[X]) -> X? {\n  loop (None, self.next()) {\n    (last, None) => last\n    (_, Some(_) as x) => continue (x, self.next())\n  }\n}\n\n///|\n/// Inserts a separator element `sep` between each element of the iterator.\n///\n/// # Parameters\n///\n/// - `self` : The iterator to intersperse the separator into.\n/// - `sep` : The separator element to insert between each element of the iterator.\n///\n/// # Examples\n///\n/// ```mbt check\n/// test {\n///   let arr = []\n///   [1, 2, 3].iter().intersperse(0).each(i => arr.push(i))\n///   assert_eq(arr, [1, 0, 2, 0, 3])\n/// }\n/// ```\n///\n/// # Note\n/// The old iterator `self` must not be used again after calling `intersperse`.\npub fn[X] Iter::intersperse(self : Iter[X], sep : X) -> Iter[X] {\n  enum State {\n    Init\n    Output_Elem(X)\n    Output_Sep\n  }\n  let mut state = Init\n  fn() {\n    match state {\n      Init => {\n        let result = self.next()\n        state = Output_Sep\n        result\n      }\n      Output_Elem(x) => {\n        state = Output_Sep\n        Some(x)\n      }\n      Output_Sep =>\n        // make sure we only output the separator when there is remaining element\n        match self.next() {\n          Some(x) => {\n            state = Output_Elem(x)\n            Some(sep)\n          }\n          None => None\n        }\n    }\n  }\n}\n\n///|\n#alias(\"_[_:_]\")\n#alias(sub, deprecated=\"Use _[_:_] instead\")\npub fn[X] Iter::view(self : Iter[X], start? : Int = 0, end? : Int) -> Iter[X] {\n  match (start, end) {\n    (_..=0, None) => self\n    (_..=0, Some(end)) => self.take(end)\n    (start, None) => self.drop(start)\n    (start, Some(end)) => {\n      let mut index = 0\n      fn() {\n        if index >= end {\n          return None\n        }\n        while index < start {\n          guard self.next() is Some(_) else { return None }\n          index += 1\n        }\n        if index >= end {\n          return None\n        }\n        let result = self.next()\n        if result is Some(_) {\n          index += 1\n        }\n        result\n      }\n    }\n  }\n}\n\n///|\n/// Checks if the iterator contains an element equal to the given value.\n///\n/// Parameters:\n///\n/// * `self` : The iterator to search in.\n/// * `value` : The value to search for.\n///\n/// Returns `true` if the iterator contains an element equal to the given value,\n/// `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let iter = [1, 2, 3, 4, 5].iter()\n///   inspect(iter.contains(3), content=\"true\")\n///   inspect(iter.contains(6), content=\"false\")\n///   let iter = Iter::empty()\n///   inspect(iter.contains(1), content=\"false\")\n/// }\n/// ```\n///\n/// # Note\n/// The old iterator `self` will advance past the searched element.\npub fn[X : Eq] Iter::contains(self : Iter[X], value : X) -> Bool {\n  while self.next() is Some(x) {\n    if x == value {\n      break true\n    }\n  } else {\n    false\n  }\n}\n\n///|\n/// Returns the nth element of the iterator, or `None` if the iterator is\n/// shorter than `n` elements.\n/// The iterator `self` will advance past the returned element.\npub fn[X] Iter::nth(self : Iter[X], n : Int) -> X? {\n  guard n >= 0 else { None }\n  for _ in 0..<n {\n    guard self.next() is Some(_) else { break None }\n  } else {\n    self.next()\n  }\n}\n\n///|\npub fn[X : Compare] Iter::maximum(self : Iter[X]) -> X? {\n  guard self.next() is Some(x) else { return None }\n  let mut res = x\n  while self.next() is Some(x) {\n    if x > res {\n      res = x\n    }\n  }\n  Some(res)\n}\n\n///|\npub fn[X : Compare] Iter::minimum(self : Iter[X]) -> X? {\n  guard self.next() is Some(x) else { return None }\n  let mut res = x\n  while self.next() is Some(x) {\n    if x < res {\n      res = x\n    }\n  }\n  Some(res)\n}\n\n///|\n/// This type is used for `for _, _ in ..` loop\n/// (`for .. in` loop with two loop variables),\n/// and should not be used directly in general.\n#alias(Iterator2, deprecated=\"The name `Iterator2` is deprecated, use `Iter2` instead. Note that if you have defined `iterator2()` method to support `for .. in` loop, you should also rename `iterator2()` to `iter2()`. See https://github.com/moonbitlang/core/pull/3127 for more details.\")\npub(all) struct Iter2[X, Y](Iter[(X, Y)])\n\n///|\npub fn[X, Y] Iter2::new(f : () -> (X, Y)?) -> Iter2[X, Y] {\n  Iter2(Iter::new(f))\n}\n\n///|\n#alias(iterator)\npub fn[X, Y] Iter2::iter(self : Iter2[X, Y]) -> Iter[(X, Y)] {\n  self.0\n}\n\n///|\n#alias(iterator2)\npub fn[X, Y] Iter2::iter2(self : Iter2[X, Y]) -> Iter2[X, Y] {\n  self\n}\n\n///|\npub fn[X, Y] Iter2::next(self : Iter2[X, Y]) -> (X, Y)? {\n  self.0.next()\n}\n\n///|\npub impl[X : Show, Y : Show] Show for Iter2[X, Y] with output(self, logger) {\n  self.0.output(logger)\n}\n\n///|\npub fn[X, Y] Iter2::run(\n  self : Iter2[X, Y],\n  f : (X, Y) -> IterResult,\n) -> IterResult {\n  while self.0.next() is Some((x, y)) {\n    guard f(x, y) is IterContinue else { break IterEnd }\n  } else {\n    IterContinue\n  }\n}\n\n///|\npub fn[X, Y] Iter2::each(self : Iter2[X, Y], f : (X, Y) -> Unit) -> Unit {\n  self.0.each(pair => f(pair.0, pair.1))\n}\n\n///|\npub fn[X, Y] Iter2::concat(\n  self : Iter2[X, Y],\n  other : Iter2[X, Y],\n) -> Iter2[X, Y] {\n  Iter2(self.0.concat(other.0))\n}\n\n///|\npub fn[X, Y] Iter2::to_array(self : Iter2[X, Y]) -> Array[(X, Y)] {\n  self.0.to_array()\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n#cfg(not(target=\"js\"))\nconst ALPHABET : String = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n\n///|\n#cfg(not(target=\"js\"))\nfn unsafe_fixedarray_uint16_to_string(buffer : FixedArray[UInt16]) -> String = \"%string.unsafe_from_uint16_fixedarray\"\n\n//==========================================\n// Int and UInt (Non JS)\n//==========================================\n\n///|\n/// Converts an unsigned 32-bit integer to hexadecimal\n#cfg(not(target=\"js\"))\nfn int_to_string_hex(\n  buffer : FixedArray[UInt16],\n  num : UInt,\n  digit_start : Int,\n  total_len : Int,\n) -> Unit {\n  let mut offset = total_len - digit_start\n  let mut n = num\n\n  // Process 2 hex digits (1 byte) at a time\n  while offset >= 2 {\n    offset = offset - 2\n    let byte_val = n.land(0xFFU).reinterpret_as_int()\n    let hi = byte_val / 16\n    let lo = byte_val % 16\n    buffer.unsafe_set(digit_start + offset, ALPHABET.unsafe_get(hi))\n    buffer.unsafe_set(digit_start + offset + 1, ALPHABET.unsafe_get(lo))\n    n = n >> 8\n  }\n\n  // Handle remaining single hex digit\n  if offset == 1 {\n    let nibble = n.land(0xFU).reinterpret_as_int()\n    buffer.unsafe_set(digit_start, ALPHABET.unsafe_get(nibble))\n  }\n}\n\n///|\n/// Generic radix conversion for any base 2-36\n#cfg(not(target=\"js\"))\nfn int_to_string_generic(\n  buffer : FixedArray[UInt16],\n  num : UInt,\n  digit_start : Int,\n  total_len : Int,\n  radix : Int,\n) -> Unit {\n  let mut offset = total_len - digit_start\n  let mut n = num\n  let base = radix.reinterpret_as_uint()\n  if (radix & (radix - 1)) == 0 {\n    // Power-of-two radix: use bit shifts\n    let shift = radix.ctz()\n    let mask = base - 1U\n    while n > 0U {\n      offset = offset - 1\n      let digit = n.land(mask).reinterpret_as_int()\n      buffer.unsafe_set(digit_start + offset, ALPHABET.unsafe_get(digit))\n      n = n >> shift\n    }\n  } else {\n    // General radix: use division\n    while n > 0U {\n      offset = offset - 1\n      let q = n / base\n      let digit = (n - q * base).reinterpret_as_int()\n      buffer.unsafe_set(digit_start + offset, ALPHABET.unsafe_get(digit))\n      n = q\n    }\n  }\n}\n\n///|\n/// Converts an unsigned 32-bit integer to decimal string\n#cfg(not(target=\"js\"))\nfn int_to_string_dec(\n  buffer : FixedArray[UInt16],\n  num : UInt,\n  digit_start : Int,\n  total_len : Int,\n) -> Unit {\n  let mut num = num\n  let mut offset = total_len - digit_start\n\n  // Process digits in groups of 4 (chunks of 10000)\n  while num >= 10000U {\n    let t = num / 10000U\n    let r = (num % 10000U).reinterpret_as_int()\n    num = t\n    let d1 = r / 100\n    let d2 = r % 100\n    offset = offset - 4\n    let d1_hi = (0x30 + d1 / 10).to_uint16()\n    let d1_lo = (0x30 + d1 % 10).to_uint16()\n    let d2_hi = (0x30 + d2 / 10).to_uint16()\n    let d2_lo = (0x30 + d2 % 10).to_uint16()\n    buffer.unsafe_set(digit_start + offset, d1_hi)\n    buffer.unsafe_set(digit_start + offset + 1, d1_lo)\n    buffer.unsafe_set(digit_start + offset + 2, d2_hi)\n    buffer.unsafe_set(digit_start + offset + 3, d2_lo)\n  }\n\n  // Handle remaining digits (< 10000)\n  let mut remaining = num.reinterpret_as_int()\n\n  // Process pairs of digits\n  while remaining >= 100 {\n    let t = remaining / 100\n    let d = remaining % 100\n    remaining = t\n    offset = offset - 2\n    let d_hi = (0x30 + d / 10).to_uint16()\n    let d_lo = (0x30 + d % 10).to_uint16()\n    buffer.unsafe_set(digit_start + offset, d_hi)\n    buffer.unsafe_set(digit_start + offset + 1, d_lo)\n  }\n\n  // Handle final 1 or 2 digits\n  if remaining >= 10 {\n    offset = offset - 2\n    let d_hi = (0x30 + remaining / 10).to_uint16()\n    let d_lo = (0x30 + remaining % 10).to_uint16()\n    buffer.unsafe_set(digit_start + offset, d_hi)\n    buffer.unsafe_set(digit_start + offset + 1, d_lo)\n  } else {\n    offset = offset - 1\n    buffer.unsafe_set(digit_start + offset, (0x30 + remaining).to_uint16())\n  }\n}\n\n///|\n/// Calculates the number of decimal digits in a u32 value\n#cfg(not(target=\"js\"))\nfn dec_count32(value : UInt) -> Int {\n  // Binary search: split 1-10 digits into halves\n  if value >= 100000U { // >= 10^5 means 6+ digits\n    if value >= 10000000U { // >= 10^7 means 8+ digits\n      if value >= 1000000000U { // >= 10^9 means 10 digits\n        10\n      } else if value >= 100000000U { // >= 10^8 means 9 digits\n        9\n      } else {\n        8\n      }\n    } else if value >= 1000000U { // >= 10^6 means 7 digits\n      7\n    } else {\n      6\n    }\n  } else if value >= 1000U { // >= 10^3 means 4+ digits\n    if value >= 10000U { // >= 10^4 means 5 digits\n      5\n    } else {\n      4\n    }\n  } else if value >= 100U { // >= 10^2 means 3 digits\n    3\n  } else if value >= 10U { // >= 10^1 means 2 digits\n    2\n  } else {\n    1\n  }\n}\n\n///|\n/// Calculates the number of hex digits needed for a u32 value\n#cfg(not(target=\"js\"))\nfn hex_count32(value : UInt) -> Int {\n  if value == 0U {\n    1\n  } else {\n    let leading_zeros = value.clz()\n    (31 - leading_zeros) / 4 + 1\n  }\n}\n\n///|\n/// Calculates the number of digits needed for a u32 value in any radix\n#cfg(not(target=\"js\"))\nfn radix_count32(value : UInt, radix : Int) -> Int {\n  if value == 0U {\n    return 1\n  }\n  let mut num = value\n  let base = radix.reinterpret_as_uint()\n  let mut count = 0\n  while num > 0U {\n    count = count + 1\n    num = num / base\n  }\n  count\n}\n\n///|\n/// Converts an integer to its string representation in the specified radix (base).\n/// Example:\n/// ```\n/// inspect((255).to_string(radix=16), content=\"ff\")\n/// inspect((-255).to_string(radix=16), content=\"-ff\")\n/// ```\n#cfg(not(target=\"js\"))\npub fn Int::to_string(self : Int, radix? : Int = 10) -> String {\n  // Validate radix\n  if radix < 2 || radix > 36 {\n    abort(\"radix must be between 2 and 36\")\n  }\n\n  // Special case for zero\n  if self == 0 {\n    return \"0\"\n  }\n\n  // Handle negative numbers\n  let is_negative = self < 0\n  let num : UInt = if is_negative {\n    // Negate and reinterpret as UInt\n    // Works correctly for Int::min_value due to two's complement:\n    // -Int::min_value wraps to itself, then reinterpreting gives 2147483648U\n    (-self).reinterpret_as_uint()\n  } else {\n    self.reinterpret_as_uint()\n  }\n\n  // Calculate length, allocate buffer, and write digits\n  let buffer = match radix {\n    10 => {\n      let digit_len = dec_count32(num)\n      let total_len = digit_len + (if is_negative { 1 } else { 0 })\n      let buffer : FixedArray[UInt16] = FixedArray::make(total_len, 0)\n      let digit_start = if is_negative { 1 } else { 0 }\n      int_to_string_dec(buffer, num, digit_start, total_len)\n      buffer\n    }\n    16 => {\n      let digit_len = hex_count32(num)\n      let total_len = digit_len + (if is_negative { 1 } else { 0 })\n      let buffer : FixedArray[UInt16] = FixedArray::make(total_len, 0)\n      let digit_start = if is_negative { 1 } else { 0 }\n      int_to_string_hex(buffer, num, digit_start, total_len)\n      buffer\n    }\n    _ => {\n      let digit_len = radix_count32(num, radix)\n      let total_len = digit_len + (if is_negative { 1 } else { 0 })\n      let buffer : FixedArray[UInt16] = FixedArray::make(total_len, 0)\n      let digit_start = if is_negative { 1 } else { 0 }\n      int_to_string_generic(buffer, num, digit_start, total_len, radix)\n      buffer\n    }\n  }\n\n  // Write minus sign if negative\n  if is_negative {\n    buffer.unsafe_set(0, 0x002D)\n  }\n  unsafe_fixedarray_uint16_to_string(buffer)\n}\n\n///|\n/// Converts an unsigned integer to its string representation in the specified radix (base).\n#cfg(not(target=\"js\"))\npub fn UInt::to_string(self : UInt, radix? : Int = 10) -> String {\n  // Validate radix\n  if radix < 2 || radix > 36 {\n    abort(\"radix must be between 2 and 36\")\n  }\n\n  // Special case for zero\n  if self == 0U {\n    return \"0\"\n  }\n\n  // Calculate length, allocate buffer, and write digits\n  let buffer = match radix {\n    10 => {\n      let len = dec_count32(self)\n      let buffer : FixedArray[UInt16] = FixedArray::make(len, 0)\n      int_to_string_dec(buffer, self, 0, len)\n      buffer\n    }\n    16 => {\n      let len = hex_count32(self)\n      let buffer : FixedArray[UInt16] = FixedArray::make(len, 0)\n      int_to_string_hex(buffer, self, 0, len)\n      buffer\n    }\n    _ => {\n      let len = radix_count32(self, radix)\n      let buffer : FixedArray[UInt16] = FixedArray::make(len, 0)\n      int_to_string_generic(buffer, self, 0, len, radix)\n      buffer\n    }\n  }\n  unsafe_fixedarray_uint16_to_string(buffer)\n}\n\n//==========================================\n// Int and UInt (JS)\n//==========================================\n\n///|\n/// Converts an integer to its string representation in the specified radix (base).\n#cfg(target=\"js\")\npub fn Int::to_string(self : Int, radix? : Int = 10) -> String {\n  int_to_string_js(self, radix)\n}\n\n///|\n#cfg(target=\"js\")\nextern \"js\" fn int_to_string_js(i : Int, radix : Int) -> String =\n  #|(x, radix) => {\n  #|  return x.toString(radix);\n  #|}\n\n///|\n/// Converts an unsigned integer to its string representation in the specified radix (base).\n#cfg(target=\"js\")\npub fn UInt::to_string(self : UInt, radix? : Int = 10) -> String {\n  uint_to_string_js(self, radix)\n}\n\n///|\n#cfg(target=\"js\")\nextern \"js\" fn uint_to_string_js(i : UInt, radix : Int) -> String =\n  #|(x, radix) => {\n  #|  return (x >>> 0).toString(radix);\n  #|}\n\n//==========================================\n// Int64 and UInt64\n//==========================================\n\n///|\n/// Calculates the number of decimal digits in a u64 value\n#cfg(not(target=\"js\"))\nfn dec_count64(value : UInt64) -> Int {\n  // Binary search: split 1-20 digits into halves\n  if value >= 10000000000UL { // >= 10^10 means 11+ digits\n    if value >= 100000000000000UL { // >= 10^14 means 15+ digits\n      if value >= 10000000000000000UL { // >= 10^16 means 17+ digits\n        if value >= 1000000000000000000UL { // >= 10^18 means 19+ digits\n          if value >= 10000000000000000000UL { // >= 10^19 means 20 digits\n            20\n          } else {\n            19\n          }\n        } else if value >= 100000000000000000UL { // >= 10^17 means 18 digits\n          18\n        } else {\n          17\n        }\n      } else if value >= 1000000000000000UL { // >= 10^15 means 16 digits\n        16\n      } else {\n        15\n      }\n    } else if value >= 1000000000000UL { // >= 10^12 means 13+ digits\n      if value >= 10000000000000UL { // >= 10^13 means 14 digits\n        14\n      } else {\n        13\n      }\n    } else if value >= 100000000000UL { // >= 10^11 means 12 digits\n      12\n    } else {\n      11\n    }\n  } else if value >= 100000UL { // >= 10^5 means 6+ digits\n    if value >= 10000000UL { // >= 10^7 means 8+ digits\n      if value >= 1000000000UL { // >= 10^9 means 10 digits\n        10\n      } else if value >= 100000000UL { // >= 10^8 means 9 digits\n        9\n      } else {\n        8\n      }\n    } else if value >= 1000000UL { // >= 10^6 means 7 digits\n      7\n    } else {\n      6\n    }\n  } else if value >= 1000UL { // >= 10^3 means 4+ digits\n    if value >= 10000UL { // >= 10^4 means 5 digits\n      5\n    } else {\n      4\n    }\n  } else if value >= 100UL { // >= 10^2 means 3 digits\n    3\n  } else if value >= 10UL { // >= 10^1 means 2 digits\n    2\n  } else {\n    1\n  }\n}\n\n///|\n/// Calculates the number of hex digits needed for a u64 value\n#cfg(not(target=\"js\"))\nfn hex_count64(value : UInt64) -> Int {\n  if value == 0UL {\n    1\n  } else {\n    let leading_zeros = value.clz()\n    (63 - leading_zeros) / 4 + 1\n  }\n}\n\n///|\n/// Calculates the number of digits needed for a u64 value in any radix\n#cfg(not(target=\"js\"))\nfn radix_count64(value : UInt64, radix : Int) -> Int {\n  if value == 0UL {\n    return 1\n  }\n  let mut num = value\n  let base = radix.to_uint64()\n  let mut count = 0\n  while num > 0UL {\n    count = count + 1\n    num = num / base\n  }\n  count\n}\n\n///|\n/// Converts an unsigned 64-bit integer to hexadecimal\n#cfg(not(target=\"js\"))\nfn int64_to_string_hex(\n  buffer : FixedArray[UInt16],\n  num : UInt64,\n  digit_start : Int,\n  total_len : Int,\n) -> Unit {\n  let mut offset = total_len - digit_start\n  let mut n = num\n\n  // Process 2 hex digits (1 byte) at a time\n  while offset >= 2 {\n    offset = offset - 2\n    let byte_val = n.land(0xFFUL).to_int()\n    let hi = byte_val / 16\n    let lo = byte_val % 16\n    buffer.unsafe_set(digit_start + offset, ALPHABET.unsafe_get(hi))\n    buffer.unsafe_set(digit_start + offset + 1, ALPHABET.unsafe_get(lo))\n    n = n >> 8\n  }\n\n  // Handle remaining single hex digit\n  if offset == 1 {\n    let nibble = n.land(0xFUL).to_int()\n    buffer.unsafe_set(digit_start, ALPHABET.unsafe_get(nibble))\n  }\n}\n\n///|\n/// Generic radix conversion for any base 2-36 (64-bit)\n#cfg(not(target=\"js\"))\nfn int64_to_string_generic(\n  buffer : FixedArray[UInt16],\n  num : UInt64,\n  digit_start : Int,\n  total_len : Int,\n  radix : Int,\n) -> Unit {\n  let mut offset = total_len - digit_start\n  let mut n = num\n  let base = radix.to_uint64()\n  if (radix & (radix - 1)) == 0 {\n    // Power-of-two radix: use bit shifts\n    let shift = radix.ctz()\n    let mask = base - 1UL\n    while n > 0UL {\n      offset = offset - 1\n      let digit = n.land(mask).to_int()\n      buffer.unsafe_set(digit_start + offset, ALPHABET.unsafe_get(digit))\n      n = n >> shift\n    }\n  } else {\n    // General radix: use division\n    while n > 0UL {\n      offset = offset - 1\n      let q = n / base\n      let digit = (n - q * base).to_int()\n      buffer.unsafe_set(digit_start + offset, ALPHABET.unsafe_get(digit))\n      n = q\n    }\n  }\n}\n\n///|\n/// Converts an unsigned 64-bit integer to decimal string\n#cfg(not(target=\"js\"))\nfn int64_to_string_dec(\n  buffer : FixedArray[UInt16],\n  num : UInt64,\n  digit_start : Int,\n  total_len : Int,\n) -> Unit {\n  let mut num = num\n  let mut offset = total_len - digit_start\n\n  // Process digits in groups of 4 (chunks of 10000)\n  while num >= 10000UL {\n    let t = num / 10000UL\n    let r = (num % 10000UL).to_int()\n    num = t\n    let d1 = r / 100\n    let d2 = r % 100\n    offset = offset - 4\n    let d1_hi = (0x30 + d1 / 10).to_uint16()\n    let d1_lo = (0x30 + d1 % 10).to_uint16()\n    let d2_hi = (0x30 + d2 / 10).to_uint16()\n    let d2_lo = (0x30 + d2 % 10).to_uint16()\n    buffer.unsafe_set(digit_start + offset, d1_hi)\n    buffer.unsafe_set(digit_start + offset + 1, d1_lo)\n    buffer.unsafe_set(digit_start + offset + 2, d2_hi)\n    buffer.unsafe_set(digit_start + offset + 3, d2_lo)\n  }\n\n  // Handle remaining digits (< 10000)\n  let mut remaining = num.to_int()\n\n  // Process pairs of digits\n  while remaining >= 100 {\n    let t = remaining / 100\n    let d = remaining % 100\n    remaining = t\n    offset = offset - 2\n    let d_hi = (0x30 + d / 10).to_uint16()\n    let d_lo = (0x30 + d % 10).to_uint16()\n    buffer.unsafe_set(digit_start + offset, d_hi)\n    buffer.unsafe_set(digit_start + offset + 1, d_lo)\n  }\n\n  // Handle final 1 or 2 digits\n  if remaining >= 10 {\n    offset = offset - 2\n    let d_hi = (0x30 + remaining / 10).to_uint16()\n    let d_lo = (0x30 + remaining % 10).to_uint16()\n    buffer.unsafe_set(digit_start + offset, d_hi)\n    buffer.unsafe_set(digit_start + offset + 1, d_lo)\n  } else {\n    offset = offset - 1\n    buffer.unsafe_set(digit_start + offset, (0x30 + remaining).to_uint16())\n  }\n}\n\n///|\n/// Converts a 64-bit integer to its string representation in the specified radix (base).\n#cfg(not(target=\"js\"))\npub fn Int64::to_string(self : Int64, radix? : Int = 10) -> String {\n  // Validate radix\n  if radix < 2 || radix > 36 {\n    abort(\"radix must be between 2 and 36\")\n  }\n\n  // Special case for zero\n  if self == 0L {\n    return \"0\"\n  }\n\n  // Handle negative numbers\n  let is_negative = self < 0L\n  let num : UInt64 = if is_negative {\n    // Negate and reinterpret as UInt64\n    // Works correctly for Int64::min_value due to two's complement\n    (-self).reinterpret_as_uint64()\n  } else {\n    self.reinterpret_as_uint64()\n  }\n\n  // Calculate length, allocate buffer, and write digits\n  let buffer = match radix {\n    10 => {\n      let digit_len = dec_count64(num)\n      let total_len = digit_len + (if is_negative { 1 } else { 0 })\n      let buffer : FixedArray[UInt16] = FixedArray::make(total_len, 0)\n      let digit_start = if is_negative { 1 } else { 0 }\n      int64_to_string_dec(buffer, num, digit_start, total_len)\n      buffer\n    }\n    16 => {\n      let digit_len = hex_count64(num)\n      let total_len = digit_len + (if is_negative { 1 } else { 0 })\n      let buffer : FixedArray[UInt16] = FixedArray::make(total_len, 0)\n      let digit_start = if is_negative { 1 } else { 0 }\n      int64_to_string_hex(buffer, num, digit_start, total_len)\n      buffer\n    }\n    _ => {\n      let digit_len = radix_count64(num, radix)\n      let total_len = digit_len + (if is_negative { 1 } else { 0 })\n      let buffer : FixedArray[UInt16] = FixedArray::make(total_len, 0)\n      let digit_start = if is_negative { 1 } else { 0 }\n      int64_to_string_generic(buffer, num, digit_start, total_len, radix)\n      buffer\n    }\n  }\n\n  // Write minus sign if negative\n  if is_negative {\n    buffer.unsafe_set(0, 0x002D)\n  }\n  unsafe_fixedarray_uint16_to_string(buffer)\n}\n\n///|\n/// Converts an unsigned 64-bit integer to its string representation in the specified radix (base).\n#cfg(not(target=\"js\"))\npub fn UInt64::to_string(self : UInt64, radix? : Int = 10) -> String {\n  // Validate radix\n  if radix < 2 || radix > 36 {\n    abort(\"radix must be between 2 and 36\")\n  }\n\n  // Special case for zero\n  if self == 0UL {\n    return \"0\"\n  }\n\n  // Calculate length, allocate buffer, and write digits\n  let buffer = match radix {\n    10 => {\n      let len = dec_count64(self)\n      let buffer : FixedArray[UInt16] = FixedArray::make(len, 0)\n      int64_to_string_dec(buffer, self, 0, len)\n      buffer\n    }\n    16 => {\n      let len = hex_count64(self)\n      let buffer : FixedArray[UInt16] = FixedArray::make(len, 0)\n      int64_to_string_hex(buffer, self, 0, len)\n      buffer\n    }\n    _ => {\n      let len = radix_count64(self, radix)\n      let buffer : FixedArray[UInt16] = FixedArray::make(len, 0)\n      int64_to_string_generic(buffer, self, 0, len, radix)\n      buffer\n    }\n  }\n  unsafe_fixedarray_uint16_to_string(buffer)\n}\n\n///|\n/// Converts a 64-bit integer to its string representation in the specified radix (base).\n#cfg(target=\"js\")\npub fn Int64::to_string(self : Int64, radix? : Int = 10) -> String {\n  int64_to_string_js(self, radix)\n}\n\n///|\n#cfg(target=\"js\")\nextern \"js\" fn int64_to_string_js(num : Int64, radix : Int) -> String =\n  #|(num, radix) => {\n  #|  let val = (BigInt(num.hi >>> 0) << 32n) | BigInt(num.lo >>> 0);\n  #|  if (val & (1n << 63n)) {\n  #|    val = val - (1n << 64n);\n  #|  }\n  #|  return val.toString(radix);\n  #|}\n\n///|\n/// Converts an unsigned 64-bit integer to its string representation in the specified radix (base).\n#cfg(target=\"js\")\npub fn UInt64::to_string(self : UInt64, radix? : Int = 10) -> String {\n  uint64_to_string_js(self, radix)\n}\n\n///|\n#cfg(target=\"js\")\nextern \"js\" fn uint64_to_string_js(num : UInt64, radix : Int) -> String =\n  #|(num, radix) => {\n  #|  return (BigInt(num.hi >>> 0) << 32n | BigInt(num.lo >>> 0)).toString(radix);\n  #|}\n\n//==========================================\n// Int16 and UInt16\n//==========================================\n\n///|\npub fn UInt16::to_string(self : UInt16, radix? : Int = 10) -> String {\n  self.to_int().to_string(radix~)\n}\n\n//==========================================\n// Test cases\n//==========================================\n\n///|\ntest \"UInt::to_string\" {\n  inspect(0U, content=\"0\")\n  inspect(17U, content=\"17\")\n  inspect(4294967295U, content=\"4294967295\")\n}\n\n///|\ntest \"to_string\" {\n  assert_eq((0x100).to_string(), \"256\")\n  assert_eq(\"\\{0x100}\", \"256\")\n  assert_eq(0x200U.to_string(), \"512\")\n  assert_eq(\"\\{0x200U}\", \"512\")\n  assert_eq(0x300L.to_string(), \"768\")\n  assert_eq(\"\\{0x300L}\", \"768\")\n  assert_eq(0x400UL.to_string(), \"1024\")\n  assert_eq(\"\\{0x400UL}\", \"1024\")\n}\n\n///|\ntest \"panic to_string_by_radix/illegal_radix\" {\n  ignore((1).to_string(radix=1))\n  ignore((1).to_string(radix=37))\n  ignore(1L.to_string(radix=0))\n  ignore(1L.to_string(radix=42))\n  ignore(1U.to_string(radix=-1))\n  ignore(1U.to_string(radix=73))\n  ignore(1UL.to_string(radix=-100))\n  ignore(1UL.to_string(radix=100))\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Represents a generic test failure type used primarily in test assertions and\n/// validations.\n///\n/// Since this is a type definition using `suberror` syntax, it creates an error\n/// type `Failure` that wraps a `String` value containing the failure message.\n///\n/// Parameters:\n///\n/// * `message` : A string describing the nature of the failure.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let err : Failure = Failure(\"Test assertion failed\")\n///   match err {\n///     Failure(msg) => inspect(msg, content=\"Test assertion failed\")\n///   }\n///   @json.json_inspect(err, content=[\"Failure\", \"Test assertion failed\"])\n/// }\n/// ```\npub(all) suberror Failure {\n  Failure(String)\n} derive(ToJson, Show)\n\n///|\n/// Raises a `Failure` error with a given message and source location.\n///\n/// Parameters:\n///\n/// * `message` : A string containing the error message to be included in the\n/// failure.\n/// * `location` : The source code location where the failure occurred.\n/// Automatically provided by the compiler when not specified.\n///\n/// Returns a value of type `T` wrapped in a `Failure` error type.\n///\n/// Throws an error of type `Failure` with a message that includes both the\n/// source location and the provided error message.\n#callsite(autofill(loc))\npub fn[T] fail(msg : String, loc~ : SourceLoc) -> T raise Failure {\n  raise Failure(\"\\{loc} FAILED: \\{msg}\")\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Returns the offset (charcode index) of the first occurrence of the given\n/// substring. If the substring is not found, it returns None.\npub fn StringView::find(self : StringView, str : StringView) -> Int? {\n  if str.length() <= 4 {\n    brute_force_find(self, str)\n  } else {\n    boyer_moore_horspool_find(self, str)\n  }\n  // TODO: When the pattern string is long (>= 256),\n  // consider using Two-Way algorithm to ensure linear time complexity.\n}\n\n///|\n/// Simple brute force string search algorithm\n/// Scans the haystack left to right, matching the needle at each position\nfn brute_force_find(haystack : StringView, needle : StringView) -> Int? {\n  let haystack_len = haystack.length()\n  let needle_len = needle.length()\n  guard needle_len > 0 else { return Some(0) }\n  guard haystack_len >= needle_len else { return None }\n  let needle_first = needle.unsafe_get(0)\n  let forward_len = haystack_len - needle_len\n  let mut i = 0\n  while i <= forward_len {\n    // Skip positions where first charcode doesn't match\n    while i <= forward_len && haystack.unsafe_get(i) != needle_first {\n      i += 1\n    }\n    if i <= forward_len {\n      // Check remaining charcodes for full match\n      for j in 1..<needle_len {\n        if haystack.unsafe_get(i + j) != needle.unsafe_get(j) {\n          break\n        }\n      } else {\n        return Some(i)\n      }\n      i += 1\n    }\n  }\n  None\n}\n\n///|\n/// Boyer-Moore-Horspool algorithm for string search (left to right)\n/// More efficient than brute force for longer patterns by using bad char heuristic\nfn boyer_moore_horspool_find(\n  haystack : StringView,\n  needle : StringView,\n) -> Int? {\n  let haystack_len = haystack.length()\n  let needle_len = needle.length()\n  guard needle_len > 0 else { return Some(0) }\n  guard haystack_len >= needle_len else { return None }\n  // Build skip table\n  let skip_table = FixedArray::make(1 << 8, needle_len)\n  for i in 0..<(needle_len - 1) {\n    skip_table[needle.unsafe_get(i).to_int() & 0xFF] = needle_len - 1 - i\n  }\n  for i = 0\n      i <= haystack_len - needle_len\n      i = i +\n        skip_table[haystack.unsafe_get(i + needle_len - 1).to_int() & 0xFF] {\n    // Check all charcodes for match at current position\n    for j in 0..<=(needle_len - 1) {\n      if haystack.unsafe_get(i + j) != needle.unsafe_get(j) {\n        break\n      }\n    } else {\n      return Some(i)\n    }\n  }\n  None\n}\n\n///|\ntest \"boyer_moore_horspool_find edge cases\" {\n  inspect(boyer_moore_horspool_find(\"abc\"[:], \"\"[:]), content=\"Some(0)\")\n  inspect(boyer_moore_horspool_find(\"ab\"[:], \"abcd\"[:]), content=\"None\")\n}\n\n///|\ntest \"boyer_moore_horspool_rev_find edge cases\" {\n  inspect(boyer_moore_horspool_rev_find(\"abc\"[:], \"\"[:]), content=\"Some(3)\")\n  inspect(boyer_moore_horspool_rev_find(\"ab\"[:], \"abcd\"[:]), content=\"None\")\n}\n\n///|\n/// Returns the offset of the first occurrence of the given substring. If the\n/// substring is not found, it returns None.\npub fn String::find(self : String, str : StringView) -> Int? {\n  self[:].find(str)\n}\n\n///|\ntest \"find\" {\n  inspect(\"hello\".find(\"o\"), content=\"Some(4)\")\n  inspect(\"hello\".find(\"l\"), content=\"Some(2)\")\n  inspect(\"hello\".find(\"hello\"), content=\"Some(0)\")\n  inspect(\"hello\".find(\"h\"), content=\"Some(0)\")\n  inspect(\"hello\".find(\"\"), content=\"Some(0)\")\n  inspect(\"hello\".find(\"world\"), content=\"None\")\n  inspect(\"\".find(\"\"), content=\"Some(0)\")\n  inspect(\"\".find(\"a\"), content=\"None\")\n  inspect(\"hello hello\".find(\"hello\"), content=\"Some(0)\")\n  inspect(\"aaa\".find(\"aa\"), content=\"Some(0)\")\n  inspect(\"\".find(\"\"), content=\"Some(0)\")\n  inspect(\n    (\"aa\".repeat(20) + \"\").find(\"\"),\n    content=\"Some(120)\",\n  )\n  inspect(\n    (\"\" + \"aa\".repeat(20)).find(\"\"),\n    content=\"Some(0)\",\n  )\n}\n\n///|\n/// Returns the offset of the first character that satisfies the given predicate.\n/// If no such character is found, it returns None.\npub fn StringView::find_by(self : StringView, pred : (Char) -> Bool) -> Int? {\n  for i, c in self {\n    if pred(c) {\n      return Some(i)\n    }\n  }\n  None\n}\n\n///|\n/// Returns the offset of the first character that satisfies the given predicate.\n/// If no such character is found, it returns None.\npub fn String::find_by(self : String, pred : (Char) -> Bool) -> Int? {\n  self[:].find_by(pred)\n}\n\n///|\ntest \"find_by\" {\n  inspect(\"hello\".find_by(c => c == 'o'), content=\"Some(4)\")\n  inspect(\"hello\".find_by(c => c == 'l'), content=\"Some(2)\")\n  inspect(\"hello\".find_by(c => c == 'z'), content=\"None\")\n  inspect(\"\".find_by(c => c == 'a'), content=\"None\")\n  inspect(\"hello\".find_by(c => c is ('0'..='9')), content=\"None\")\n  inspect(\"hello123\".find_by(c => c is ('0'..='9')), content=\"Some(5)\")\n  inspect(\"hello\".find_by(c => c is ('A'..='Z')), content=\"None\")\n  inspect(\"Hello\".find_by(c => c is ('A'..='Z')), content=\"Some(0)\")\n  inspect(\"\".find_by(c => c == ''), content=\"Some(1)\")\n  inspect(\"\".find_by(c => c == ''), content=\"Some(2)\")\n}\n\n///|\n/// Returns the offset of the last occurrence of the given substring. If the\n/// substring is not found, it returns None.\npub fn StringView::rev_find(self : StringView, str : StringView) -> Int? {\n  if str.length() <= 4 {\n    brute_force_rev_find(self, str)\n  } else {\n    boyer_moore_horspool_rev_find(self, str)\n  }\n  // TODO: When the pattern string is long (>= 256),\n  // consider using Two-Way algorithm to ensure linear time complexity.\n}\n\n///|\n/// Simple brute force string search algorithm\n/// Scans the haystack right to left, matching the needle at each position\nfn brute_force_rev_find(haystack : StringView, needle : StringView) -> Int? {\n  let haystack_len = haystack.length()\n  let needle_len = needle.length()\n  guard needle_len > 0 else { return Some(haystack_len) }\n  guard haystack_len >= needle_len else { return None }\n  let needle_first = needle.unsafe_get(0)\n  let mut i = haystack_len - needle_len\n  while i >= 0 {\n    // Skip positions where first charcode doesn't match\n    while i >= 0 && haystack.unsafe_get(i) != needle_first {\n      i -= 1\n    }\n    if i >= 0 {\n      // Check remaining charcodes for full match\n      for j in 1..<needle_len {\n        if haystack.unsafe_get(i + j) != needle.unsafe_get(j) {\n          break\n        }\n      } else {\n        return Some(i)\n      }\n      i -= 1\n    }\n  }\n  None\n}\n\n///|\n/// Boyer-Moore-Horspool algorithm for reverse string search (right to left)\n/// More efficient than brute force for longer patterns by using bad char heuristic\nfn boyer_moore_horspool_rev_find(\n  haystack : StringView,\n  needle : StringView,\n) -> Int? {\n  let haystack_len = haystack.length()\n  let needle_len = needle.length()\n  guard needle_len > 0 else { return Some(haystack_len) }\n  guard haystack_len >= needle_len else { return None }\n  let skip_table = FixedArray::make(1 << 8, needle_len)\n  for i = needle_len - 1; i > 0; i = i - 1 {\n    skip_table[needle.unsafe_get(i).to_int() & 0xFF] = i\n  }\n  for i = haystack_len - needle_len\n      i >= 0\n      i = i - skip_table[haystack.unsafe_get(i).to_int() & 0xFF] {\n    // Check all charcodes for match at current position\n    for j in 0..<needle_len {\n      if haystack.unsafe_get(i + j) != needle.unsafe_get(j) {\n        break\n      }\n    } else {\n      return Some(i)\n    }\n  }\n  None\n}\n\n///|\n/// Returns the offset (charcode index) of the last occurrence of the given\n/// substring. If the substring is not found, it returns None.\npub fn String::rev_find(self : String, str : StringView) -> Int? {\n  self[:].rev_find(str)\n}\n\n///|\ntest \"rev_find\" {\n  inspect(\"hello\".rev_find(\"o\"), content=\"Some(4)\")\n  inspect(\"hello\".rev_find(\"l\"), content=\"Some(3)\")\n  inspect(\"hello\".rev_find(\"hello\"), content=\"Some(0)\")\n  inspect(\"hello\".rev_find(\"h\"), content=\"Some(0)\")\n  inspect(\"hello\".rev_find(\"\"), content=\"Some(5)\")\n  inspect(\"hello\".rev_find(\"world\"), content=\"None\")\n  inspect(\"\".rev_find(\"\"), content=\"Some(0)\")\n  inspect(\"\".rev_find(\"a\"), content=\"None\")\n  inspect(\"hello hello\".rev_find(\"hello\"), content=\"Some(6)\")\n  inspect(\"aaa\".rev_find(\"aa\"), content=\"Some(1)\")\n  inspect(\"\".rev_find(\"\"), content=\"Some(2)\")\n  inspect(\n    (\"aa\".repeat(20) + \"\").rev_find(\"\"),\n    content=\"Some(120)\",\n  )\n  inspect(\n    (\"\" + \"aa\".repeat(20)).rev_find(\"\"),\n    content=\"Some(4)\",\n  )\n}\n\n///|\n/// Returns true if the given substring is suffix of this string.\n#alias(ends_with, deprecated)\npub fn StringView::has_suffix(self : StringView, str : StringView) -> Bool {\n  self.rev_find(str) is Some(i) && i == self.length() - str.length()\n}\n\n///|\n/// Returns true if the given substring is suffix of this string.\n#alias(ends_with, deprecated)\npub fn String::has_suffix(self : String, str : StringView) -> Bool {\n  self[:].has_suffix(str)\n}\n\n///|\ntest \"has_suffix\" {\n  inspect(\"hello\".has_suffix(\"lo\"), content=\"true\")\n  inspect(\"hello\".has_suffix(\"hello\"), content=\"true\")\n  inspect(\"hello\".has_suffix(\"\"), content=\"true\")\n  inspect(\"hello\".has_suffix(\"world\"), content=\"false\")\n  inspect(\"hello\".has_suffix(\"hel\"), content=\"false\")\n  inspect(\"\".has_suffix(\"\"), content=\"true\")\n  inspect(\"\".has_suffix(\"a\"), content=\"false\")\n  inspect(\"hello world\".has_suffix(\"world\"), content=\"true\")\n  inspect(\"\".has_suffix(\"\"), content=\"true\")\n  inspect(\"\".has_suffix(\"\"), content=\"true\")\n}\n\n///|\n/// Returns true if this string starts with the given substring.\n#alias(starts_with, deprecated)\npub fn StringView::has_prefix(self : StringView, str : StringView) -> Bool {\n  self.find(str) is Some(i) && i == 0\n}\n\n///|\n/// Returns true if this string starts with the given substring.\n#alias(starts_with, deprecated)\npub fn String::has_prefix(self : String, str : StringView) -> Bool {\n  self[:].has_prefix(str)\n}\n\n///|\ntest \"has_prefix\" {\n  inspect(\"hello\".has_prefix(\"h\"), content=\"true\")\n  inspect(\"hello\".has_prefix(\"he\"), content=\"true\")\n  inspect(\"hello\".has_prefix(\"\"), content=\"true\")\n  inspect(\"hello\".has_prefix(\"world\"), content=\"false\")\n  inspect(\"hello\".has_prefix(\"lo\"), content=\"false\")\n  inspect(\"\".has_prefix(\"\"), content=\"true\")\n  inspect(\"\".has_prefix(\"a\"), content=\"false\")\n  inspect(\"hello\".has_prefix(\"\"), content=\"true\")\n  inspect(\"hello\".has_prefix(\"\"), content=\"true\")\n  inspect(\"hello\".has_prefix(\"\"), content=\"false\")\n  inspect(\"hello\".has_prefix(\"\"), content=\"false\")\n}\n\n///|\n/// Removes the given suffix from the string if it exists.\n///\n/// Returns `Some(prefix)` if the string ends with the given suffix,\n/// where `prefix` is the string without the suffix.\n/// Returns `None` if the string does not end with the suffix.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   inspect(\"hello world\".strip_suffix(\" world\"), content=\"Some(\\\"hello\\\")\")\n///   inspect(\"hello world\".strip_suffix(\" moon\"), content=\"None\")\n///   inspect(\"hello\".strip_suffix(\"hello\"), content=\"Some(\\\"\\\")\")\n/// }\n/// ```\n#alias(chop_suffix)\npub fn String::strip_suffix(self : String, suffix : StringView) -> StringView? {\n  self[:].strip_suffix(suffix)\n}\n\n///|\ntest \"strip_prefix\" {\n  inspect(\"hello world\".strip_prefix(\"hello \"), content=\"Some(\\\"world\\\")\")\n  inspect(\"hello world\".strip_prefix(\"hi \"), content=\"None\")\n  inspect(\"hello\".strip_prefix(\"hello\"), content=\"Some(\\\"\\\")\")\n  inspect(\"\".strip_prefix(\"\"), content=\"Some(\\\"\\\")\")\n  inspect(\"\".strip_prefix(\"a\"), content=\"None\")\n  inspect(\"abc\".strip_prefix(\"\"), content=\"Some(\\\"abc\\\")\")\n  inspect(\"hello\".strip_prefix(\"\"), content=\"Some(\\\"hello\\\")\")\n  inspect(\"hello\".strip_prefix(\"\"), content=\"Some(\\\"hello\\\")\")\n}\n\n///|\ntest \"strip_suffix\" {\n  inspect(\"hello world\".strip_suffix(\" world\"), content=\"Some(\\\"hello\\\")\")\n  inspect(\"hello world\".strip_suffix(\" moon\"), content=\"None\")\n  inspect(\"hello\".strip_suffix(\"hello\"), content=\"Some(\\\"\\\")\")\n  inspect(\"\".strip_suffix(\"\"), content=\"Some(\\\"\\\")\")\n  inspect(\"\".strip_suffix(\"a\"), content=\"None\")\n  inspect(\"abc\".strip_suffix(\"\"), content=\"Some(\\\"abc\\\")\")\n  inspect(\"hello\".strip_suffix(\"\"), content=\"Some(\\\"hello\\\")\")\n  inspect(\"hello\".strip_suffix(\"\"), content=\"Some(\\\"hello\\\")\")\n}\n\n///|\n/// Removes the given prefix from the string if it exists.\n///\n/// Returns `Some(suffix)` if the string starts with the given prefix,\n/// where `suffix` is the string without the prefix.\n/// Returns `None` if the string does not start with the prefix.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   inspect(\"hello world\".strip_prefix(\"hello \"), content=\"Some(\\\"world\\\")\")\n///   inspect(\"hello world\".strip_prefix(\"hi \"), content=\"None\")\n///   inspect(\"hello\".strip_prefix(\"hello\"), content=\"Some(\\\"\\\")\")\n/// }\n/// ```\n#alias(chop_prefix)\npub fn String::strip_prefix(self : String, prefix : StringView) -> StringView? {\n  self[:].strip_prefix(prefix)\n}\n\n///|\n/// Removes the given prefix from the view if it exists.\n///\n/// Returns `Some(suffix)` if the view starts with the given prefix,\n/// where `suffix` is the view without the prefix.\n/// Returns `None` if the view does not start with the prefix.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let view = \"hello world\"[:]\n///   inspect(view.strip_prefix(\"hello \"), content=\"Some(\\\"world\\\")\")\n///   inspect(view.strip_prefix(\"hi \"), content=\"None\")\n///   inspect(view.strip_prefix(\"hello world\"), content=\"Some(\\\"\\\")\")\n/// }\n/// ```\n#alias(chop_prefix)\npub fn StringView::strip_prefix(\n  self : StringView,\n  prefix : StringView,\n) -> StringView? {\n  let prefix_len = prefix.length()\n  if self.length() >= prefix_len && self.view(end_offset=prefix_len) == prefix {\n    Some(self.view(start_offset=prefix_len))\n  } else {\n    None\n  }\n}\n\n///|\n/// Removes the given suffix from the view if it exists.\n///\n/// Returns `Some(prefix)` if the view ends with the given suffix,\n/// where `prefix` is the view without the suffix.\n/// Returns `None` if the view does not end with the suffix.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let view = \"hello world\"[:]\n///   inspect(view.strip_suffix(\" world\"), content=\"Some(\\\"hello\\\")\")\n///   inspect(view.strip_suffix(\" moon\"), content=\"None\")\n///   inspect(view.strip_suffix(\"hello world\"), content=\"Some(\\\"\\\")\")\n/// }\n/// ```\n#alias(chop_suffix)\npub fn StringView::strip_suffix(\n  self : StringView,\n  suffix : StringView,\n) -> StringView? {\n  let self_len = self.length()\n  let suffix_len = suffix.length()\n  if self_len >= suffix_len &&\n    self.view(start_offset=self_len - suffix_len) == suffix {\n    Some(self.view(end_offset=self_len - suffix_len))\n  } else {\n    None\n  }\n}\n\n///|\n/// Converts the View into an array of Chars.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let view = \"Helloxa\"[1:-1]\n///   let chars = view.to_array()\n///   inspect(chars, content=\"['e', 'l', 'l', 'o', '', 'x']\")\n/// }\n/// ```\npub fn StringView::to_array(self : StringView) -> Array[Char] {\n  self\n  .iter()\n  .fold(init=Array::new(capacity=self.length()), (rv, c) => {\n    rv.push(c)\n    rv\n  })\n}\n\n///|\n#deprecated(\"Check `@encoding/utf8.encode`\")\n#coverage.skip\npub fn StringView::to_bytes(self : StringView) -> Bytes {\n  let array = FixedArray::make(self.length() * 2, Byte::default())\n  array.blit_from_string(0, self.data(), self.start_offset(), self.length())\n  array |> unsafe_to_bytes\n}\n\n///|\ntest \"View::strip_prefix\" {\n  let view = \"hello world\"[:]\n  inspect(view.strip_prefix(\"hello \"), content=\"Some(\\\"world\\\")\")\n  inspect(view.strip_prefix(\"hi \"), content=\"None\")\n  inspect(view.strip_prefix(\"hello world\"), content=\"Some(\\\"\\\")\")\n  inspect(view.strip_prefix(\"\"), content=\"Some(\\\"hello world\\\")\")\n  let empty_view = \"\"[:]\n  inspect(empty_view.strip_prefix(\"\"), content=\"Some(\\\"\\\")\")\n  inspect(empty_view.strip_prefix(\"a\"), content=\"None\")\n  let unicode_view = \"hello\"[:]\n  inspect(unicode_view.strip_prefix(\"\"), content=\"Some(\\\"hello\\\")\")\n  inspect(unicode_view.strip_prefix(\"\"), content=\"None\")\n}\n\n///|\ntest \"View::strip_suffix\" {\n  let view = \"hello world\"[:]\n  inspect(view.strip_suffix(\" world\"), content=\"Some(\\\"hello\\\")\")\n  inspect(view.strip_suffix(\" moon\"), content=\"None\")\n  inspect(view.strip_suffix(\"hello world\"), content=\"Some(\\\"\\\")\")\n  inspect(view.strip_suffix(\"\"), content=\"Some(\\\"hello world\\\")\")\n  let empty_view = \"\"[:]\n  inspect(empty_view.strip_suffix(\"\"), content=\"Some(\\\"\\\")\")\n  inspect(empty_view.strip_suffix(\"a\"), content=\"None\")\n  let unicode_view = \"hello\"[:]\n  inspect(unicode_view.strip_suffix(\"\"), content=\"Some(\\\"hello\\\")\")\n  inspect(unicode_view.strip_suffix(\"\"), content=\"None\")\n}\n\n///|\ntest \"View::to_array\" {\n  let view = \"Hello\"[:]\n  let chars = view.to_array()\n  assert_eq(chars, ['H', 'e', 'l', 'l', 'o', ''])\n  let empty_view = \"\"[:]\n  let empty_chars = empty_view.to_array()\n  assert_eq(empty_chars, [])\n  let sub_view = \"Hello World\"[6:11] // \"World\"\n  let sub_chars = sub_view.to_array()\n  assert_eq(sub_chars, ['W', 'o', 'r', 'l', 'd'])\n}\n\n///|\n/// Returns true if this string contains the given substring.\npub fn StringView::contains(self : StringView, str : StringView) -> Bool {\n  self.find(str) is Some(_)\n}\n\n///|\n/// Returns true if this string contains the given substring.\npub fn String::contains(self : String, str : StringView) -> Bool {\n  self[:].contains(str)\n}\n\n///|\n/// Returns true if this string contains any character from the given set.\npub fn StringView::contains_any(self : StringView, chars~ : StringView) -> Bool {\n  match chars {\n    [] => false\n    [c] => self.contains_char(c) // specialize for single character\n    _ =>\n      for c in self {\n        if chars.contains_char(c) {\n          break true\n        }\n      } else {\n        false\n      }\n  }\n}\n\n///|\n/// Returns true if this string contains any character from the given set.\npub fn String::contains_any(self : String, chars~ : StringView) -> Bool {\n  self[:].contains_any(chars~)\n}\n\n///|\ntest \"contains\" {\n  inspect(\"hello\".contains(\"o\"), content=\"true\")\n  inspect(\"hello\".contains(\"l\"), content=\"true\")\n  inspect(\"hello\".contains(\"hello\"), content=\"true\")\n  inspect(\"hello\".contains(\"h\"), content=\"true\")\n  inspect(\"hello\".contains(\"\"), content=\"true\")\n  inspect(\"hello\".contains(\"world\"), content=\"false\")\n  inspect(\"\".contains(\"\"), content=\"true\")\n  inspect(\"\".contains(\"a\"), content=\"false\")\n  inspect(\"hello hello\".contains(\"hello\"), content=\"true\")\n  inspect(\"aaa\".contains(\"aa\"), content=\"true\")\n  inspect(\"\".contains(\"\"), content=\"true\")\n}\n\n///|\ntest \"contains_any\" {\n  inspect(\"hello\".contains_any(chars=\"h\"), content=\"true\")\n  inspect(\"hello\".contains_any(chars=\"xyz\"), content=\"false\")\n  inspect(\"hello\".contains_any(chars=\"\"), content=\"false\")\n  inspect(\"\".contains_any(chars=\"abc\"), content=\"false\")\n  inspect(\"\".contains_any(chars=\"\"), content=\"true\")\n  inspect(\"hello\"[:].contains_any(chars=\"eo\"), content=\"true\")\n}\n\n///|\n/// Returns true if this string contains the given character.\npub fn StringView::contains_char(self : StringView, c : Char) -> Bool {\n  let len = self.length()\n  // Check empty\n  guard len > 0 else { return false }\n  let c = c.to_int()\n  if c <= 0xFFFF {\n    // Search BMP\n    for i in 0..<len {\n      if self.unsafe_get(i).to_int() == c {\n        return true\n      }\n    }\n  } else {\n    // Check insufficient\n    guard len >= 2 else { return false }\n    // Calc surrogate pair\n    let adj = c - 0x10000\n    let high = 0xD800 + (adj >> 10)\n    let low = 0xDC00 + (adj & 0x3FF)\n    // Search surrogate pair\n    let mut i = 0\n    while i < len - 1 {\n      if self.unsafe_get(i).to_int() == high {\n        i += 1\n        if self.unsafe_get(i).to_int() == low {\n          return true\n        }\n      }\n      i += 1\n    }\n  }\n  false\n}\n\n///|\n/// Returns true if this string contains the given character.\npub fn String::contains_char(self : String, c : Char) -> Bool {\n  self[:].contains_char(c)\n}\n\n///|\ntest \"contains_char\" {\n  inspect(\"hello\".contains_char('h'), content=\"true\")\n  inspect(\"hello\".contains_char('e'), content=\"true\")\n  inspect(\"hello\".contains_char('l'), content=\"true\")\n  inspect(\"hello\".contains_char('o'), content=\"true\")\n  inspect(\"hello\".contains_char('x'), content=\"false\")\n  inspect(\"\".contains_char('a'), content=\"false\")\n  inspect(\"hello world\".contains_char(' '), content=\"true\")\n  inspect(\"hello world\".contains_char('w'), content=\"true\")\n  inspect(\"\".contains_char(''), content=\"true\")\n  inspect(\"\".contains_char(''), content=\"false\")\n  inspect(\"hello\".contains_char((104).unsafe_to_char()), content=\"true\") // 'h' is 104 in ASCII\n}\n\n///|\n/// Returns the view of the string without the leading characters that are in\n/// the given string.\n#label_migration(chars, alias=char_set)\npub fn StringView::trim_start(\n  self : StringView,\n  chars? : StringView = \"\\t\\n\\r \",\n) -> StringView {\n  loop self {\n    [] as v => v\n    [c, .. rest] as v => if chars.contains_char(c) { continue rest } else { v }\n  }\n}\n\n///|\n/// Returns the view of the string without the leading characters that are in\n/// the given string.\n#label_migration(chars, alias=char_set)\npub fn String::trim_start(\n  self : String,\n  chars? : StringView = \"\\t\\n\\r \",\n) -> StringView {\n  self[:].trim_start(chars~)\n}\n\n///|\ntest \"trim_start\" {\n  inspect(\"hello\".trim_start(chars=\"h\"), content=\"ello\")\n  inspect(\"hello\".trim_start(chars=\"he\"), content=\"llo\")\n  inspect(\"hello\".trim_start(chars=\"eh\"), content=\"llo\")\n  inspect(\"hello\".trim_start(chars=\"x\"), content=\"hello\")\n  inspect(\"hello\".trim_start(chars=\"\"), content=\"hello\")\n  inspect(\"\".trim_start(chars=\"a\"), content=\"\")\n  inspect(\"   hello\".trim_start(chars=\" \"), content=\"hello\")\n  inspect(\"hello world\".trim_start(chars=\"helo\"), content=\" world\")\n  inspect(\"hello\".trim_start(chars=\"\"), content=\"hello\")\n  inspect(\"hello\".trim_start(chars=\"\"), content=\"hello\")\n  inspect(\"aaaabc\".trim_start(chars=\"a\"), content=\"bc\")\n  inspect(\"aaaa\".trim_start(chars=\"a\"), content=\"\")\n}\n\n///|\n/// Returns the view of the string without the trailing characters that are in\n/// the given string.\n#label_migration(chars, alias=char_set)\npub fn StringView::trim_end(\n  self : StringView,\n  chars? : StringView = \"\\t\\n\\r \",\n) -> StringView {\n  loop self {\n    [] as v => v\n    [.. rest, c] as v => if chars.contains_char(c) { continue rest } else { v }\n  }\n}\n\n///|\n/// Returns the view of the string without the trailing characters that are in\n/// the given string.\n// TODO(upstream): label_migration warning does not apply to the current package\n// TODO: make chars optional with default value of whitespace characters\n#label_migration(chars, alias=char_set)\npub fn String::trim_end(\n  self : String,\n  chars? : StringView = \"\\t\\n\\r \",\n) -> StringView {\n  self[:].trim_end(chars~)\n}\n\n///|\ntest \"trim_end\" {\n  inspect(\"hello\".trim_end(chars=\"o\"), content=\"hell\")\n  inspect(\"hello\".trim_end(chars=\"lo\"), content=\"he\")\n  inspect(\"hello\".trim_end(chars=\"x\"), content=\"hello\")\n  inspect(\"hello\".trim_end(chars=\"\"), content=\"hello\")\n  inspect(\"\".trim_end(chars=\"a\"), content=\"\")\n  inspect(\"hello   \".trim_end(chars=\" \"), content=\"hello\")\n  inspect(\"hello world\".trim_end(chars=\"dlrow \"), content=\"he\")\n  inspect(\"hello\".trim_end(chars=\"\"), content=\"hello\")\n  inspect(\"hello\".trim_end(chars=\"\"), content=\"hello\")\n  inspect(\"abcccc\".trim_end(chars=\"c\"), content=\"ab\")\n  inspect(\"cccc\".trim_end(chars=\"c\"), content=\"\")\n}\n\n///|\n/// Returns the view of the string without the leading and trailing characters\n/// that are in the given string.\n#label_migration(chars, alias=char_set)\npub fn StringView::trim(\n  self : StringView,\n  chars? : StringView = \"\\t\\n\\r \",\n) -> StringView {\n  self.trim_start(chars~).trim_end(chars~)\n}\n\n///|\n/// Returns the view of the string without the leading and trailing characters\n/// that are in the given string.\n#label_migration(chars, alias=char_set)\npub fn String::trim(\n  self : String,\n  chars? : StringView = \"\\t\\n\\r \",\n) -> StringView {\n  self[:].trim(chars~)\n}\n\n///|\ntest \"trim\" {\n  inspect(\"hello\".trim(chars=\"h\"), content=\"ello\")\n  inspect(\"hello\".trim(chars=\"o\"), content=\"hell\")\n  inspect(\"hello\".trim(chars=\"ho\"), content=\"ell\")\n  inspect(\"hello\".trim(chars=\"oh\"), content=\"ell\")\n  inspect(\"hello\".trim(chars=\"x\"), content=\"hello\")\n  inspect(\"hello\".trim(chars=\"\"), content=\"hello\")\n  inspect(\"\".trim(chars=\"a\"), content=\"\")\n  inspect(\"   hello   \".trim(chars=\" \"), content=\"hello\")\n  inspect(\"hello world\".trim(chars=\"hd\"), content=\"ello worl\")\n  inspect(\"hello\".trim(chars=\"\"), content=\"hello\")\n  inspect(\"hello\".trim(chars=\"\"), content=\"hello\")\n  inspect(\"aaaabcaaa\".trim(chars=\"a\"), content=\"bc\")\n  inspect(\"aaaa\".trim(chars=\"a\"), content=\"\")\n  inspect(\"  hello world  \".trim(chars=\" \"), content=\"hello world\")\n  inspect(\"abcabc\".trim(chars=\"abc\"), content=\"\")\n}\n\n///|\n/// Returns the view of the string without the leading and trailing spaces.\n#deprecated(\"Use `trim` with default whitespace characters instead\")\npub fn StringView::trim_space(self : StringView) -> StringView {\n  self.trim()\n}\n\n///|\n/// Returns the view of the string without the leading and trailing spaces.\n#deprecated(\"Use `trim` with default whitespace characters instead\")\npub fn String::trim_space(self : String) -> StringView {\n  self.trim()\n}\n\n///|\ntest \"trim whitespace for string\" {\n  inspect(\"hello\".trim(), content=\"hello\")\n  inspect(\"  hello  \".trim(), content=\"hello\")\n  inspect(\"hello  \".trim(), content=\"hello\")\n  inspect(\"  hello\".trim(), content=\"hello\")\n  inspect(\"\\t\\nhello\\r\\n\".trim(), content=\"hello\")\n  inspect(\"  hello world  \".trim(), content=\"hello world\")\n  inspect(\"  \".trim(), content=\"\")\n  inspect(\"\\n\\r\\t\".trim(), content=\"\")\n  inspect(\"\".trim(), content=\"\")\n  inspect(\"  hello\\nworld\\t\".trim(), content=\"hello\\nworld\")\n}\n\n///|\n/// Returns true if this string is empty.\npub fn StringView::is_empty(self : StringView) -> Bool {\n  self.length() == 0\n}\n\n///|\n/// Returns true if this string is empty.\npub fn String::is_empty(self : String) -> Bool {\n  self == \"\"\n}\n\n///|\ntest \"is_empty\" {\n  inspect(\"\".is_empty(), content=\"true\")\n  inspect(\"hello\".is_empty(), content=\"false\")\n  inspect(\" \".is_empty(), content=\"false\")\n  inspect(\"\\n\".is_empty(), content=\"false\")\n  inspect(\"\\t\".is_empty(), content=\"false\")\n  inspect(\"   \".is_empty(), content=\"false\")\n\n  // Test with string views\n  let s = \"hello\"\n  let empty_view = s[0:0]\n  let non_empty_view = s[0:3]\n  inspect(empty_view.is_empty(), content=\"true\")\n  inspect(non_empty_view.is_empty(), content=\"false\")\n}\n\n///|\n/// Returns true if this string is blank.\npub fn StringView::is_blank(self : StringView) -> Bool {\n  self.trim().is_empty()\n}\n\n///|\n/// Returns true if this string is blank.\npub fn String::is_blank(self : String) -> Bool {\n  self[:].is_blank()\n}\n\n///|\ntest \"is_blank\" {\n  inspect(\"\".is_blank(), content=\"true\")\n  inspect(\"hello\".is_blank(), content=\"false\")\n  inspect(\" \".is_blank(), content=\"true\")\n  inspect(\"\\n\".is_blank(), content=\"true\")\n  inspect(\"\\t\".is_blank(), content=\"true\")\n  inspect(\"   \".is_blank(), content=\"true\")\n  inspect(\" \\n\\t\\r \".is_blank(), content=\"true\")\n  inspect(\"hello world\".is_blank(), content=\"false\")\n  inspect(\"  hello  \".is_blank(), content=\"false\")\n\n  // Test with string views\n  let s = \"   hello  \"\n  let blank_view = s[0:3] // \"   \"\n  let non_blank_view = s[3:8] // \"hello\"\n  inspect(blank_view.is_blank(), content=\"true\")\n  inspect(non_blank_view.is_blank(), content=\"false\")\n}\n\n///|\n/// Returns a new string with `padding_char`s prefixed to `self` if\n/// `self.char_length() < total_width`. The number of unicode characters in\n/// the returned string is `total_width` if padding is added.\npub fn StringView::pad_start(\n  self : StringView,\n  total_width : Int,\n  padding_char : Char,\n) -> String {\n  let len = self.length()\n  guard len < total_width else { return self.to_string() }\n  let padding = String::make(total_width - len, padding_char)\n  [..padding, ..self]\n}\n\n///|\n/// Returns a new string with `padding_char`s prefixed to `self` if\n/// `self.char_length() < total_width`. The number of unicode characters in\n/// the returned string is `total_width` if padding is added.\npub fn String::pad_start(\n  self : String,\n  total_width : Int,\n  padding_char : Char,\n) -> String {\n  let len = self.length()\n  guard len < total_width else { return self }\n  let padding = String::make(total_width - len, padding_char)\n  [..padding, ..self]\n}\n\n///|\ntest \"pad_start\" {\n  // Test with regular strings\n  inspect(\"2\".pad_start(3, '0'), content=\"002\")\n  inspect(\"abc\".pad_start(5, 'x'), content=\"xxabc\")\n  inspect(\"hello\".pad_start(4, ' '), content=\"hello\") // No padding needed\n  inspect(\"\".pad_start(3, '-'), content=\"---\")\n\n  // Test with different padding characters\n  inspect(\"test\".pad_start(8, '*'), content=\"****test\")\n  inspect(\"123\".pad_start(6, '0'), content=\"000123\")\n\n  // Test with string views\n  let s = \"hello\"\n  let view = s[2:5] // \"llo\"\n  inspect(view.pad_start(5, 'x'), content=\"xxllo\")\n\n  // Test with Unicode characters\n  inspect(\"\".pad_start(3, ''), content=\"\")\n\n  // Edge cases\n  inspect(\"abc\".pad_start(0, 'x'), content=\"abc\") // width less than string length\n  inspect(\"abc\".pad_start(3, 'x'), content=\"abc\") // width equal to string length\n}\n\n///|\n/// Returns a new string with `padding_char`s appended to `self` if\n/// `self.length() < total_width`. The number of unicode characters in\n/// the returned string is `total_width` if padding is added.\npub fn StringView::pad_end(\n  self : StringView,\n  total_width : Int,\n  padding_char : Char,\n) -> String {\n  let len = self.length()\n  guard len < total_width else { return self.to_string() }\n  let padding = String::make(total_width - len, padding_char)\n  [..self, ..padding]\n}\n\n///|\n/// Returns a new string with `padding_char`s appended to `self` if\n/// `self.length() < total_width`. The number of unicode characters in\n/// the returned string is `total_width` if padding is added.\npub fn String::pad_end(\n  self : String,\n  total_width : Int,\n  padding_char : Char,\n) -> String {\n  let len = self.length()\n  guard len < total_width else { return self }\n  let padding = String::make(total_width - len, padding_char)\n  [..self, ..padding]\n}\n\n///|\ntest \"pad_end\" {\n  // Test with regular strings\n  inspect(\"2\".pad_end(3, '0'), content=\"200\")\n  inspect(\"abc\".pad_end(5, 'x'), content=\"abcxx\")\n  inspect(\"hello\".pad_end(4, ' '), content=\"hello\") // No padding needed\n  inspect(\"\".pad_end(3, '-'), content=\"---\")\n\n  // Test with different padding characters\n  inspect(\"test\".pad_end(8, '*'), content=\"test****\")\n  inspect(\"123\".pad_end(6, '0'), content=\"123000\")\n\n  // Test with string views\n  let s = \"hello\"\n  let view = s[2:5] // \"llo\"\n  inspect(view.pad_end(5, 'x'), content=\"lloxx\")\n\n  // Test with Unicode characters\n  inspect(\"\".pad_end(3, ''), content=\"\")\n\n  // Edge cases\n  inspect(\"abc\".pad_end(0, 'x'), content=\"abc\") // width less than string length\n  inspect(\"abc\".pad_end(3, 'x'), content=\"abc\") // width equal to string length\n}\n\n///|\n/// Returns a new string with `self` repeated `n` times.\npub fn StringView::repeat(self : StringView, n : Int) -> StringView {\n  match n {\n    _..=0 => \"\"\n    1 => self\n    _ => {\n      let len = self.length()\n      let buf = StringBuilder::new(size_hint=len * n)\n      let str = self.to_string()\n      for _ in 0..<n {\n        buf.write_string(str)\n      }\n      buf.to_string()\n    }\n  }\n}\n\n///|\n/// Returns a new string with `self` repeated `n` times.\npub fn String::repeat(self : String, n : Int) -> String {\n  match n {\n    _..=0 => \"\"\n    1 => self\n    _ => {\n      let len = self.length()\n      let buf = StringBuilder::new(size_hint=len * n)\n      let str = self.to_string()\n      for _ in 0..<n {\n        buf.write_string(str)\n      }\n      buf.to_string()\n    }\n  }\n}\n\n///|\ntest \"repeat\" {\n  // Test with regular strings\n  inspect(\"abc\".repeat(3), content=\"abcabcabc\")\n  inspect(\"x\".repeat(5), content=\"xxxxx\")\n  inspect(\"hello \".repeat(2), content=\"hello hello \")\n\n  // Test with empty string\n  inspect(\"\".repeat(10), content=\"\")\n\n  // Test with string views\n  let s = \"hello world\"\n  let view = s[6:11] // \"world\"\n  inspect(view.repeat(2), content=\"worldworld\")\n\n  // Test with Unicode characters\n  inspect(\"\".repeat(3), content=\"\")\n  inspect(\"\".repeat(2), content=\"\")\n\n  // Edge cases\n  inspect(\"abc\".repeat(0), content=\"\")\n  inspect(\"abc\".repeat(-5), content=\"\")\n  inspect(\"abc\".repeat(1), content=\"abc\")\n}\n\n///|\n/// Returns a new string with the characters in reverse order. It respects\n/// Unicode characters and surrogate pairs but not grapheme clusters.\npub fn StringView::rev(self : StringView) -> String {\n  let buf = StringBuilder::new(size_hint=self.length())\n  for c in self.rev_iter() {\n    buf.write_char(c)\n  }\n  buf.to_string()\n}\n\n///|\n/// Returns a new string with the characters in reverse order. It respects\n/// Unicode characters and surrogate pairs but not grapheme clusters.\npub fn String::rev(self : String) -> String {\n  self[:].rev()\n}\n\n///|\ntest \"rev\" {\n  inspect(\"hello\".rev(), content=\"olleh\")\n  inspect(\"\".rev(), content=\"\")\n  inspect(\"abc\".rev(), content=\"cba\")\n  inspect(\"\".rev(), content=\"\")\n}\n\n///|\n/// Splits the string into all substrings separated by the given separator.\n/// \n/// If the string does not contain the separator and the separator is not empty,\n/// the returned iterator will contain only one element, which is the original\n/// string.\n/// \n/// If the separator is empty, the returned iterator will contain all the\n/// characters in the string as single elements.\npub fn StringView::split(\n  self : StringView,\n  sep : StringView,\n) -> Iter[StringView] {\n  let sep_len = sep.length()\n  if sep_len == 0 {\n    return self.iter().map(c => c.to_string().view())\n  }\n  let mut remaining = Some(self)\n  Iter::new(() => {\n    guard remaining is Some(view) else { None }\n    guard view.find(sep) is Some(end) else {\n      remaining = None\n      Some(view)\n    }\n    remaining = Some(view.view(start_offset=end + sep_len))\n    Some(view.view(end_offset=end))\n  })\n}\n\n///|\n/// Splits the string into all substrings separated by the given separator.\n/// \n/// If the string does not contain the separator and the separator is not empty,\n/// the returned iterator will contain only one element, which is the original\n/// string.\n/// \n/// If the separator is empty, the returned iterator will contain all the\n/// characters in the string as single elements.\npub fn String::split(self : String, sep : StringView) -> Iter[StringView] {\n  self[:].split(sep)\n}\n\n///|\ntest \"split\" {\n  assert_eq(\"a,b,c\".split(\",\").map(StringView::to_string).collect(), [\n    \"a\", \"b\", \"c\",\n  ])\n  assert_eq(\"a,b,c\".split(\"\").map(StringView::to_string).collect(), [\n    \"a\", \",\", \"b\", \",\", \"c\",\n  ])\n  assert_eq(\n    \"apple::orange::banana\".split(\"::\").map(StringView::to_string).collect(),\n    [\"apple\", \"orange\", \"banana\"],\n  )\n  assert_eq(\"abc\".split(\"\").map(StringView::to_string).collect(), [\n    \"a\", \"b\", \"c\",\n  ])\n  assert_eq(\"hello\".split(\",\").map(StringView::to_string).collect(), [\"hello\"])\n  assert_eq(\",a,b,c\".split(\",\").map(StringView::to_string).collect(), [\n    \"\", \"a\", \"b\", \"c\",\n  ])\n  assert_eq(\"a,b,c,\".split(\",\").map(StringView::to_string).collect(), [\n    \"a\", \"b\", \"c\", \"\",\n  ])\n  assert_eq(\"a,b,c\".split(\"\").map(StringView::to_string).collect(), [\n    \"a\", \",\", \"b\", \",\", \"c\",\n  ])\n  assert_eq(\"\".split(\"\").map(StringView::to_string).collect(), [])\n  assert_eq(\"\".split(\",\").map(StringView::to_string).collect(), [\"\"])\n  assert_eq(\",,\".split(\",\").map(StringView::to_string).collect(), [\n    \"\", \"\", \"\",\n  ])\n  assert_eq(\"abc\".split(\"\").map(StringView::to_string).collect(), [\n    \"a\", \"b\", \"c\",\n  ])\n}\n\n///|\n/// Replaces the first occurrence of `old` with `new` in `self`.\n/// \n/// If `old` is empty, it matches the beginning of the string, and `new` is\n/// prepended to the string.\npub fn StringView::replace(\n  self : StringView,\n  old~ : StringView,\n  new~ : StringView,\n) -> StringView {\n  match self.find(old) {\n    Some(end) =>\n      [\n        ..self.view(end_offset=end),\n        ..new,\n        ..self.view(start_offset=end + old.length()),\n      ]\n    None => self\n  }\n}\n\n///|\n/// Replaces the first occurrence of `old` with `new` in `self`.\n/// \n/// If `old` is empty, it matches the beginning of the string, and `new` is\n/// prepended to the string.\npub fn String::replace(\n  self : String,\n  old~ : StringView,\n  new~ : StringView,\n) -> String {\n  match self.find(old) {\n    Some(end) =>\n      [\n        ..self.view(end_offset=end),\n        ..new,\n        ..self.view(start_offset=end + old.length()),\n      ]\n    None => self\n  }\n}\n\n///|\ntest \"replace\" {\n  inspect(\"hello\".replace(old=\"o\", new=\"a\"), content=\"hella\")\n  inspect(\"hello\".replace(old=\"l\", new=\"a\"), content=\"healo\")\n  inspect(\"hello\".replace(old=\"hello\", new=\"a\"), content=\"a\")\n  inspect(\"hello\".replace(old=\"h\", new=\"a\"), content=\"aello\")\n  inspect(\"hello\".replace(old=\"\", new=\"a\"), content=\"ahello\")\n  inspect(\"hello\".replace(old=\"world\", new=\"a\"), content=\"hello\")\n  inspect(\"\".replace(old=\"\", new=\"a\"), content=\"a\")\n}\n\n///|\n/// Replaces all non-overlapping occurrences of `old` with `new` in `self`.\n/// \n/// If `old` is empty, it matches at the beginning of the string and after each\n/// character in the string, so `new` is inserted at the beginning of the string\n/// and after each character.\npub fn StringView::replace_all(\n  self : StringView,\n  old~ : StringView,\n  new~ : StringView,\n) -> StringView {\n  let len = self.length()\n  let buf = StringBuilder::new(size_hint=len)\n  let old_len = old.length()\n  let new = new.to_string()\n  // use write_substring to avoid intermediate allocations\n  if old_len == 0 {\n    buf.write_string(new)\n    for c in self {\n      buf.write_char(c)\n      buf.write_string(new)\n    }\n    buf.to_string()\n  } else {\n    let first_end = self.find(old)\n    if first_end is Some(end) {\n      for view = self, end = end {\n        let seg = view.view(end_offset=end)\n        buf.write_substring(seg.data(), seg.start_offset(), seg.length())\n        buf.write_string(new)\n        // check if there is no more characters after the last occurrence of `old`\n        guard end + old_len <= len else { break }\n        let next_view = view.view(start_offset=end + old_len)\n        guard next_view.find(old) is Some(next_end) else {\n          buf.write_substring(\n            next_view.data(),\n            next_view.start_offset(),\n            next_view.length(),\n          )\n          break\n        }\n        continue next_view, next_end\n      }\n      buf.to_string()\n    } else {\n      self\n    }\n  }\n}\n\n///|\n/// Replaces all non-overlapping occurrences of `old` with `new` in `self`.\n/// \n/// If `old` is empty, it matches at the beginning of the string and after each\n/// character in the string, so `new` is inserted at the beginning of the string\n/// and after each character.\npub fn String::replace_all(\n  self : String,\n  old~ : StringView,\n  new~ : StringView,\n) -> String {\n  let len = self.length()\n  let buf = StringBuilder::new(size_hint=len)\n  let old_len = old.length()\n  let new = new.to_string()\n  // use write_substring to avoid intermediate allocations\n  if old_len == 0 {\n    buf.write_string(new)\n    for c in self {\n      buf.write_char(c)\n      buf.write_string(new)\n    }\n    buf.to_string()\n  } else {\n    let first_end = self.find(old)\n    if first_end is Some(end) {\n      for view = self[:], end = end {\n        let seg = view.view(end_offset=end)\n        buf.write_substring(seg.data(), seg.start_offset(), seg.length())\n        buf.write_string(new)\n        // check if there is no more characters after the last occurrence of `old`\n        guard end + old_len <= len else { break }\n        let next_view = view.view(start_offset=end + old_len)\n        guard next_view.find(old) is Some(next_end) else {\n          buf.write_substring(\n            next_view.data(),\n            next_view.start_offset(),\n            next_view.length(),\n          )\n          break\n        }\n        continue next_view, next_end\n      }\n      buf.to_string()\n    } else {\n      self\n    }\n  }\n}\n\n///|\ntest \"replace_all\" {\n  assert_eq(\"hello\".replace_all(old=\"o\", new=\"a\"), \"hella\")\n  assert_eq(\"hello\".replace_all(old=\"l\", new=\"a\"), \"heaao\")\n  assert_eq(\"hello\".replace_all(old=\"ll\", new=\"rr\"), \"herro\")\n  assert_eq(\"hello\".replace_all(old=\"hello\", new=\"world\"), \"world\")\n  assert_eq(\"hello hello hello\".replace_all(old=\"hello\", new=\"hi\"), \"hi hi hi\")\n  assert_eq(\n    \"hello hello helloi\".replace_all(old=\"hello\", new=\"hi\"),\n    \"hi hi hii\",\n  )\n  assert_eq(\n    \"hi hi hii\".replace_all(old=\"hi\", new=\"hello\"),\n    \"hello hello helloi\",\n  )\n  assert_eq(\"hello\".replace_all(old=\"\", new=\"a\"), \"ahaealalaoa\")\n  assert_eq(\"hello\".replace_all(old=\"world\", new=\"a\"), \"hello\")\n  assert_eq(\"\".replace_all(old=\"\", new=\"a\"), \"a\")\n  assert_eq(\"aaa\".replace_all(old=\"a\", new=\"b\"), \"bbb\")\n  assert_eq(\"aaa\".replace_all(old=\"a\", new=\"bb\"), \"bbbbbb\")\n  assert_eq(\"aaa\".replace_all(old=\"aa\", new=\"b\"), \"ba\")\n  assert_eq(\"\".replace_all(old=\"\", new=\"\"), \"\")\n  assert_eq(\"abc123abc\".replace_all(old=\"abc\", new=\"xyz\"), \"xyz123xyz\")\n  assert_eq(\"abcabcabc\".replace_all(old=\"abc\", new=\"\"), \"\")\n  assert_eq(\"abc\".replace_all(old=\"abc\", new=\"\"), \"\")\n  assert_eq(\"abc\".replace_all(old=\"\", new=\"x\"), \"xaxbxcx\")\n}\n\n///|\ntest \"String::replace_all boundary cases\" {\n  // These tests should trigger the uncovered line 1187: guard end + old_len <= len else { break }\n  // This happens when the pattern is found at the very end of the string\n\n  // Pattern at the end of string - should trigger the guard condition\n  assert_eq(\"helloworld\".replace_all(old=\"world\", new=\"X\"), \"helloX\")\n  assert_eq(\"abcdef\".replace_all(old=\"def\", new=\"XYZ\"), \"abcXYZ\")\n\n  // Multiple patterns where the last one is at the end\n  assert_eq(\"abcabc\".replace_all(old=\"abc\", new=\"X\"), \"XX\")\n\n  // Pattern that exactly matches the string length\n  assert_eq(\"test\".replace_all(old=\"test\", new=\"done\"), \"done\")\n\n  // Empty replacement at the end\n  assert_eq(\"remove_me\".replace_all(old=\"_me\", new=\"\"), \"remove\")\n}\n\n///|\ntest \"View::replace_all\" {\n  assert_eq(\"hello\"[:].replace_all(old=\"o\", new=\"a\"), \"hella\")\n  assert_eq(\"hello\"[:].replace_all(old=\"l\", new=\"a\"), \"heaao\")\n  assert_eq(\"hello\"[:].replace_all(old=\"ll\", new=\"rr\"), \"herro\")\n  assert_eq(\"hello\"[:].replace_all(old=\"hello\", new=\"world\"), \"world\")\n  assert_eq(\n    \"hello hello hello\"[:].replace_all(old=\"hello\", new=\"hi\"),\n    \"hi hi hi\",\n  )\n  assert_eq(\n    \"hello hello helloi\"[:].replace_all(old=\"hello\", new=\"hi\"),\n    \"hi hi hii\",\n  )\n  assert_eq(\n    \"hi hi hii\"[:].replace_all(old=\"hi\", new=\"hello\"),\n    \"hello hello helloi\",\n  )\n  assert_eq(\"hello\"[:].replace_all(old=\"\", new=\"a\"), \"ahaealalaoa\")\n  assert_eq(\"hello\"[:].replace_all(old=\"world\", new=\"a\"), \"hello\")\n  assert_eq(\"\"[:].replace_all(old=\"\", new=\"a\"), \"a\")\n  assert_eq(\"aaa\"[:].replace_all(old=\"a\", new=\"b\"), \"bbb\")\n  assert_eq(\"aaa\"[:].replace_all(old=\"a\", new=\"bb\"), \"bbbbbb\")\n  assert_eq(\"aaa\"[:].replace_all(old=\"aa\", new=\"b\"), \"ba\")\n  assert_eq(\n    \"\"[:].replace_all(old=\"\", new=\"\"),\n    \"\",\n  )\n  assert_eq(\"abc123abc\"[:].replace_all(old=\"abc\", new=\"xyz\"), \"xyz123xyz\")\n  assert_eq(\"abcabcabc\"[:].replace_all(old=\"abc\", new=\"\"), \"\")\n  assert_eq(\"abc\"[:].replace_all(old=\"abc\", new=\"\"), \"\")\n  assert_eq(\"abc\"[:].replace_all(old=\"\", new=\"x\"), \"xaxbxcx\")\n}\n\n///|\ntest \"View::replace_all boundary cases\" {\n  // These tests should trigger the uncovered line 1141: guard end + old_len <= len else { break }\n  // This condition triggers when end + old_len > len, meaning we're at the boundary\n\n  // Let me trace through the algorithm more carefully...\n  // Actually, let me try a different approach - create a scenario where the view length changes\n\n  // Try with overlapping patterns or edge cases\n  assert_eq(\"abcabc\"[:].replace_all(old=\"abc\", new=\"X\"), \"XX\")\n  assert_eq(\"aaaa\"[:].replace_all(old=\"aa\", new=\"b\"), \"bb\")\n\n  // Pattern at exact end\n  assert_eq(\"hello\"[:].replace_all(old=\"lo\", new=\"X\"), \"helX\")\n\n  // Test with empty string edge case\n  assert_eq(\"a\"[:].replace_all(old=\"a\", new=\"\"), \"\")\n\n  // Let me try to understand when end + old_len > len could happen...\n  // Maybe when we have a complex replacement scenario\n  inspect(\"Testing boundary condition\", content=\"Testing boundary condition\")\n}\n\n///|\n/// Converts this string to lowercase.\npub fn StringView::to_lower(self : StringView) -> StringView {\n  // TODO: deal with non-ascii characters\n  guard self.find_by(x => x.is_ascii_uppercase()) is Some(idx) else {\n    return self\n  }\n  let buf = StringBuilder::new(size_hint=self.length())\n  let head = self.view(end_offset=idx)\n  buf.write_substring(head.data(), head.start_offset(), head.length())\n  for c in self.view(start_offset=idx) {\n    if c.is_ascii_uppercase() {\n      // 'A' is 65 in ASCII, 'a' is 97, the difference is 32\n      buf.write_char((c.to_int() + 32).unsafe_to_char())\n    } else {\n      buf.write_char(c)\n    }\n  }\n  buf.to_string()\n}\n\n///|\n/// Converts this string to lowercase.\npub fn String::to_lower(self : String) -> String {\n  // TODO: deal with non-ascii characters\n  guard self.find_by(x => x.is_ascii_uppercase()) is Some(idx) else {\n    return self\n  }\n  let buf = StringBuilder::new(size_hint=self.length())\n  let head = self.view(end_offset=idx)\n  buf.write_substring(head.data(), head.start_offset(), head.length())\n  for c in self.view(start_offset=idx) {\n    if c.is_ascii_uppercase() {\n      // 'A' is 65 in ASCII, 'a' is 97, the difference is 32\n      buf.write_char((c.to_int() + 32).unsafe_to_char())\n    } else {\n      buf.write_char(c)\n    }\n  }\n  buf.to_string()\n}\n\n///|\ntest \"to_lower\" {\n  assert_eq(\"Hello\".to_lower(), \"hello\")\n  assert_eq(\"HELLO\".to_lower(), \"hello\")\n  assert_eq(\"Hello, World!\".to_lower(), \"hello, world!\")\n}\n\n///|\ntest \"View::to_lower\" {\n  assert_eq(\"Hello\"[:].to_lower(), \"hello\")\n  assert_eq(\"HELLO\"[:].to_lower(), \"hello\")\n  assert_eq(\"Hello, World!\"[:].to_lower(), \"hello, world!\")\n}\n\n///|\n/// Converts this string to uppercase.\npub fn StringView::to_upper(self : StringView) -> StringView {\n  // TODO: deal with non-ascii characters\n  guard self.find_by(Char::is_ascii_lowercase) is Some(idx) else { return self }\n  let buf = StringBuilder::new(size_hint=self.length())\n  let head = self.view(end_offset=idx)\n  buf.write_substring(head.data(), head.start_offset(), head.length())\n  for c in self.view(start_offset=idx) {\n    if c.is_ascii_lowercase() {\n      buf.write_char((c.to_int() - 32).unsafe_to_char())\n    } else {\n      buf.write_char(c)\n    }\n  }\n  buf.to_string()\n}\n\n///|\n/// Converts this string to uppercase.\npub fn String::to_upper(self : String) -> String {\n  // TODO: deal with non-ascii characters\n  guard self.find_by(Char::is_ascii_lowercase) is Some(idx) else { return self }\n  let buf = StringBuilder::new(size_hint=self.length())\n  let head = self.view(end_offset=idx)\n  buf.write_substring(head.data(), head.start_offset(), head.length())\n  for c in self.view(start_offset=idx) {\n    if c.is_ascii_lowercase() {\n      buf.write_char((c.to_int() - 32).unsafe_to_char())\n    } else {\n      buf.write_char(c)\n    }\n  }\n  buf.to_string()\n}\n\n///|\ntest \"to_upper\" {\n  assert_eq(\"hello\".to_upper(), \"HELLO\")\n  assert_eq(\"HELLO\".to_upper(), \"HELLO\")\n  assert_eq(\"Hello, World!\".to_upper(), \"HELLO, WORLD!\")\n}\n\n///|\ntest \"View::to_upper\" {\n  assert_eq(\"hello\"[:].to_upper(), \"HELLO\")\n  assert_eq(\"HELLO\"[:].to_upper(), \"HELLO\")\n  assert_eq(\"Hello, World!\"[:].to_upper(), \"HELLO, WORLD!\")\n}\n\n///|\n/// Folds the characters of the string into a single value.\npub fn[A] StringView::fold(\n  self : StringView,\n  init~ : A,\n  f : (A, Char) -> A raise?,\n) -> A raise? {\n  let mut rv = init\n  for c in self {\n    rv = f(rv, c)\n  }\n  rv\n}\n\n///|\n/// Folds the characters of the string into a single value.\npub fn[A] String::fold(\n  self : String,\n  init~ : A,\n  f : (A, Char) -> A raise?,\n) -> A raise? {\n  self[:].fold(init~, f)\n}\n\n///|\ntest \"fold\" {\n  assert_eq(\n    \"hello\".fold(init=[], (acc, c) => {\n      acc.push(c)\n      acc\n    }),\n    ['h', 'e', 'l', 'l', 'o'],\n  )\n  assert_eq(\n    \"hello\".fold(init=0, (acc, c) => acc + c.to_int()),\n    104 + 101 + 108 + 108 + 111,\n  )\n}\n\n///|\ntest \"fold with raise\" {\n  let result = try? \"hello\".fold(init=0, (acc, c) => {\n    if c == 'l' {\n      raise Failure(\"found l\")\n    }\n    acc + 1\n  })\n  inspect(result, content=\"Err(Failure(\\\"found l\\\"))\")\n}\n\n///|\npub fn[A] StringView::rev_fold(\n  self : StringView,\n  init~ : A,\n  f : (A, Char) -> A raise?,\n) -> A raise? {\n  let mut rv = init\n  for c in self.rev_iter() {\n    rv = f(rv, c)\n  }\n  rv\n}\n\n///|\npub fn[A] String::rev_fold(\n  self : String,\n  init~ : A,\n  f : (A, Char) -> A raise?,\n) -> A raise? {\n  self[:].rev_fold(init~, f)\n}\n\n///|\ntest \"rev_fold\" {\n  assert_eq(\n    \"hello\".rev_fold(init=[], (acc, c) => {\n      acc.push(c)\n      acc\n    }),\n    ['o', 'l', 'l', 'e', 'h'],\n  )\n  assert_eq(\n    \"hello\".rev_fold(init=0, (acc, c) => acc + c.to_int()),\n    111 + 108 + 108 + 101 + 104,\n  )\n}\n\n///|\ntest \"rev_fold with raise\" {\n  let result = try? \"hello\".rev_fold(init=0, (acc, c) => {\n    if c == 'l' {\n      raise Failure(\"found l\")\n    }\n    acc + 1\n  })\n  inspect(result, content=\"Err(Failure(\\\"found l\\\"))\")\n}\n\n///|\n/// Returns the UTF-16 code unit at the given index. Returns `None` if the index\n/// is out of bounds.\n#deprecated(\"The return type is about to change to `UInt16?` in a future release. Please check boundaries manually and use `String::code_unit_at` instead.\", skip_current_package=true)\npub fn String::get(self : String, idx : Int) -> Int? {\n  guard idx >= 0 && idx < self.length() else { return None }\n  Some(self.unsafe_get(idx).to_int())\n}\n\n///|\n/// Returns the UTF-16 code unit at the given index. Returns `None` if the index\n/// is out of bounds.\n#deprecated(\"The return type is about to change to `UInt16?` in a future release. Please check boundaries manually and use `StringView::code_unit_at` instead.\", skip_current_package=true)\npub fn StringView::get(self : StringView, idx : Int) -> Int? {\n  guard idx >= 0 && idx < self.length() else { return None }\n  Some(self.unsafe_get(idx).to_int())\n}\n\n///|\ntest \"String::get supports emoji (surrogate pair)\" {\n  let s = \"hello\"\n  inspect(s.get(0), content=\"Some(104)\")\n  inspect(s.get(4), content=\"Some(111)\")\n  inspect(s.get(5), content=\"None\")\n  inspect(s.get(-1), content=\"None\")\n  let s = \"ab\"\n  inspect(s.get(0), content=\"Some(97)\")\n  inspect(s.get(1), content=\"Some(55358)\")\n  inspect(s.get(2), content=\"Some(56611)\")\n  inspect(s.get(3), content=\"Some(98)\")\n  inspect(s.get(4), content=\"None\")\n}\n\n///|\ntest \"View::get basic cases\" {\n  let v = \"hello\"[1:-1]\n  inspect(v.get(0), content=\"Some(101)\")\n  inspect(v.get(2), content=\"Some(108)\")\n  inspect(v.get(3), content=\"None\")\n  inspect(v.get(-1), content=\"None\")\n  let v = \"abcd\"[1:-1]\n  inspect(v.get(0), content=\"Some(98)\")\n  inspect(v.get(1), content=\"Some(55358)\")\n  inspect(v.get(2), content=\"Some(56611)\")\n}\n\n///|\n/// Returns the character at the given index. Returns `None` if the index is out\n/// of bounds or the index splits a surrogate pair.\npub fn String::get_char(self : String, idx : Int) -> Char? {\n  guard idx >= 0 && idx < self.length() else { return None }\n  let c = self.unsafe_get(idx)\n  if c.is_leading_surrogate() {\n    guard idx + 1 < self.length() else { return None }\n    let next = self.unsafe_get(idx + 1)\n    if next.is_trailing_surrogate() {\n      Some(code_point_of_surrogate_pair(c.to_int(), next.to_int()))\n    } else {\n      None\n    }\n  } else if c.is_trailing_surrogate() {\n    None\n  } else {\n    Some(c.unsafe_to_char())\n  }\n}\n\n///|\n/// Returns the character at the given index. Returns `None` if the index is out\n/// of bounds or the index splits a surrogate pair.\npub fn StringView::get_char(self : StringView, idx : Int) -> Char? {\n  guard idx >= 0 && idx < self.length() else { return None }\n  let c = self.unsafe_get(idx)\n  if c.is_leading_surrogate() {\n    guard idx + 1 < self.length() else { return None }\n    let next = self.unsafe_get(idx + 1)\n    if next.is_trailing_surrogate() {\n      Some(code_point_of_surrogate_pair(c.to_int(), next.to_int()))\n    } else {\n      None\n    }\n  } else if c.is_trailing_surrogate() {\n    None\n  } else {\n    Some(c.unsafe_to_char())\n  }\n}\n\n///|\ntest \"String::get_char basic cases\" {\n  // Basic ASCII characters\n  let s = \"hello\"\n  inspect(s.get_char(0), content=\"Some('h')\")\n  inspect(s.get_char(1), content=\"Some('e')\")\n  inspect(s.get_char(4), content=\"Some('o')\")\n  inspect(s.get_char(5), content=\"None\")\n  inspect(s.get_char(-1), content=\"None\")\n\n  // Contains emoji (surrogate pair)\n  let s = \"ab\"\n  inspect(s.get_char(0), content=\"Some('a')\")\n  inspect(s.get_char(1), content=\"Some('')\")\n  inspect(s.get_char(2), content=\"None\") // Second half of surrogate pair is not a valid char\n  inspect(s.get_char(3), content=\"Some('b')\")\n  inspect(s.get_char(4), content=\"None\")\n}\n\n///|\ntest \"View::get_char basic cases\" {\n  let s = \"ab\"\n  let v = s[0:-1]\n  inspect(v.get_char(0), content=\"Some('a')\")\n  inspect(v.get_char(1), content=\"Some('')\")\n  inspect(v.get_char(2), content=\"None\")\n  inspect(v.get_char(3), content=\"None\")\n  inspect(v.get_char(4), content=\"None\")\n\n  // Test substring view\n  let v2 = s[1:3] // Only contains the emoji surrogate pair\n  inspect(v2.get_char(0), content=\"Some('')\")\n  inspect(v2.get_char(1), content=\"None\")\n  inspect(v2.get_char(2), content=\"None\")\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//#region\n// These types are of workaround for the restriction that MoonBit do not support\n// generic type parameters of extern ffi\n\n///|\n#external\npriv type JSValue\n\n///|\nfn[T] JSValue::ofAny(array : T) -> JSValue = \"%identity\"\n\n///|\nfn[T] JSValue::toAny(self : JSValue) -> T = \"%identity\"\n\n///|\n#external\npriv type JSArray\n\n///|\nfn[T] JSArray::ofAnyArray(array : Array[T]) -> JSArray = \"%identity\"\n\n///|\nfn[T] JSArray::toAnyArray(self : JSArray) -> Array[T] = \"%identity\"\n\n///|\nfn[T] JSArray::ofAnyFixedArray(array : FixedArray[T]) -> JSArray = \"%identity\"\n\n///|\nfn[T] JSArray::toAnyFixedArray(self : JSArray) -> FixedArray[T] = \"%identity\"\n\n///|\nextern \"js\" fn JSArray::set_length(self : JSArray, new_len : Int) -> Unit =\n  #| (arr, len) => { arr.length = len; }\n\n///|\nextern \"js\" fn JSArray::push(self : JSArray, value : JSValue) -> Unit =\n  #| (arr, val) => { arr.push(val); }\n\n///|\nextern \"js\" fn JSArray::pop(self : JSArray) -> JSValue =\n  #| (arr) => arr.pop()\n\n///|\nextern \"js\" fn JSArray::splice(\n  self : JSArray,\n  index : Int,\n  count : Int,\n) -> JSArray =\n  #| (arr, idx, cnt) => arr.splice(idx, cnt)\n\n///|\nextern \"js\" fn JSArray::splice1(\n  self : JSArray,\n  index : Int,\n  count : Int,\n  value : JSValue,\n) -> JSArray =\n  #| (arr, idx, cnt, val) => arr.splice(idx, cnt, val)\n\n///|\nextern \"js\" fn JSArray::fill(\n  self : JSArray,\n  value : JSValue,\n  start : Int,\n  end : Int,\n) -> Unit =\n  #| (arr, val, start, end) => arr.fill(val, start, end)\n\n///|\nextern \"js\" fn JSArray::copy(self : JSArray) -> JSArray =\n  #|(arr) => arr.slice(0)\n\n//#endregion\n\n///|\n/// An `Array` is a collection of values that supports random access and can\n/// grow in size.\n#external\ntype Array[T]\n\n///|\nfn[T] Array::make_uninit(len : Int) -> Array[T] = \"%fixedarray.make_uninit\"\n\n///|\n/// Creates a new array.\npub fn[T] Array::new(capacity? : Int = 0) -> Array[T] {\n  ignore(capacity)\n  []\n}\n\n///|\n/// Returns the number of elements in the array.\npub fn[T] Array::length(self : Array[T]) -> Int = \"%fixedarray.length\"\n\n///|\nfn[T] Array::unsafe_truncate_to_length(self : Array[T], new_len : Int) -> Unit {\n  JSArray::ofAnyArray(self).set_length(new_len)\n}\n\n///|\nfn[T] Array::buffer(self : Array[T]) -> UninitializedArray[T] = \"%identity\"\n\n///|\ntest \"array_unsafe_blit_fixed\" {\n  let src = FixedArray::make(5, 0)\n  let dst = UninitializedArray::make(5)\n  for i in 0..<5 {\n    src[i] = i + 1\n  }\n  UninitializedArray::unsafe_blit_fixed(dst, 0, src, 0, 5)\n  for i in 0..<5 {\n    assert_eq(dst[i], src[i])\n  }\n}\n\n///|\ntest \"UninitializedArray::unsafe_blit_fixed\" {\n  let src = FixedArray::make(5, 0)\n  let dst = UninitializedArray::make(5)\n  for i in 0..<5 {\n    src[i] = i + 1\n  }\n  UninitializedArray::unsafe_blit_fixed(dst, 0, src, 0, 5)\n  for i in 0..<5 {\n    assert_eq(dst[i], src[i])\n  }\n}\n\n///|\n/// Reserves capacity to ensure that it can hold at least the number of elements\n/// specified by the `capacity` argument.\n///\n/// **NOTE**: This method does nothing on js platform.\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let v = [1]\n///   v.reserve_capacity(10)\n///   assert_eq(v.capacity(), 1)\n/// }\n/// ```\npub fn[T] Array::reserve_capacity(self : Array[T], capacity : Int) -> Unit {\n  ignore(self)\n  ignore(capacity)\n}\n\n///|\n/// Shrinks the capacity of the array as much as possible.\n///\n/// **NOTE**: This method does nothing on js platform.\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let v = Array::new(capacity=10)\n///   v.push(1)\n///   v.push(2)\n///   v.push(3)\n///   assert_eq(v.capacity(), 3)\n///   v.shrink_to_fit()\n///   assert_eq(v.capacity(), 3)\n/// }\n/// ```\npub fn[T] Array::shrink_to_fit(self : Array[T]) -> Unit {\n  ignore(self)\n}\n\n///|\n/// Adds an element to the end of the array.\n///\n/// If the array is at capacity, it will be reallocated.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = []\n///   v.push(3)\n/// }\n/// ```\npub fn[T] Array::push(self : Array[T], value : T) -> Unit {\n  JSArray::ofAnyArray(self).push(JSValue::ofAny(value))\n}\n\n///|\n/// Removes the last element from an array and returns it, or `None` if it is empty.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [1, 2, 3]\n///   let vv = v.pop()\n///   assert_eq(vv, Some(3))\n///   assert_eq(v, [1, 2])\n/// }\n/// ```\npub fn[T] Array::pop(self : Array[T]) -> T? {\n  if self.length() == 0 {\n    None\n  } else {\n    let v = self.unsafe_pop()\n    Some(v)\n  }\n}\n\n///|\n/// Removes the last element from an array and returns it.\n///\n/// **NOTE** This method will not cause a panic, but it may result in undefined\n/// behavior on the JavaScript platform. Use with caution.\n///\n#internal(unsafe, \"Panic if the array is empty.\")\n#doc(hidden)\n#alias(pop_exn, deprecated)\npub fn[T] Array::unsafe_pop(self : Array[T]) -> T {\n  JSArray::ofAnyArray(self).pop().toAny()\n}\n\n///|\n/// Remove an element from the array at a given index.\n///\n/// Removes and returns the element at position index within the array, shifting all elements after it to the left.\n/// \n/// This function will panic if the index is out of bounds.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let vv = v.remove(1)\n///   assert_eq(vv, 4)\n///   assert_eq(v, [3, 5])\n/// }\n/// ```\npub fn[T] Array::remove(self : Array[T], index : Int) -> T {\n  guard index >= 0 && index < self.length() else {\n    abort(\n      \"index out of bounds: the len is from 0 to \\{self.length()} but the index is \\{index}\",\n    )\n  }\n  let value = self.buffer()[index]\n  let _ = JSArray::ofAnyArray(self).splice(index, 1)\n  value\n}\n\n///|\n/// Removes the specified range from the array and returns it.\n///\n/// This functions returns an array range from `begin` to `end` `[begin, end)`\n/// \n/// This function will panic if the index is out of bounds.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let vv = v.drain(1, 2) // vv = [4], v = [3, 5]\n///   assert_eq(vv, [4])\n///   assert_eq(v, [3, 5])\n/// }\n/// ```\npub fn[T] Array::drain(self : Array[T], begin : Int, end : Int) -> Array[T] {\n  guard begin >= 0 && end <= self.length() && begin <= end else {\n    abort(\n      \"index out of bounds: the len is \\{self.length()} but the index is (\\{begin}, \\{end})\",\n    )\n  }\n  JSArray::ofAnyArray(self).splice(begin, end - begin).toAnyArray()\n}\n\n///|\n/// Inserts an element at a given index within the array.\n/// \n/// This function will panic if the index is out of bounds.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   [3, 4, 5].insert(1, 6)\n/// }\n/// ```\npub fn[T] Array::insert(self : Array[T], index : Int, value : T) -> Unit {\n  guard index >= 0 && index <= self.length() else {\n    abort(\n      \"index out of bounds: the len is from 0 to \\{self.length()} but the index is \\{index}\",\n    )\n  }\n  let _ = JSArray::ofAnyArray(self).splice1(index, 0, JSValue::ofAny(value))\n\n}\n\n///|\n/// Resize the array in-place so that `len` is equal to `new_len`.\n///\n/// If `new_len` is greater than `len`, the array will be extended by the\n/// difference, and the values in the new slots are left uninitilized.\n///  If `new_len` is less than `len`, it will panic\n///\nfn[T] Array::unsafe_grow_to_length(self : Array[T], new_len : Int) -> Unit {\n  guard new_len >= self.length()\n  JSArray::ofAnyArray(self).set_length(new_len)\n}\n\n///|\n/// Fills an Array with a specified value.\n/// \n/// This method fills all or part of an Array with the given value.\n/// \n/// # Parameters\n/// - `value`: The value to fill the array with\n/// - `start`: The starting index (inclusive, default: 0)\n/// - `end`: The ending index (exclusive, optional)\n/// \n/// If `end` is not provided, fills from `start` to the end of the array.\n/// If `start` equals `end`, no elements are modified.\n/// \n/// # Panics\n/// - Panics if `start` is negative or greater than or equal to the array length\n/// - Panics if `end` is provided and is less than `start` or greater than array length\n/// - Does nothing if the array is empty\n/// \n/// # Example\n/// ```mbt check\n/// test {\n///   // Fill entire array\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.fill(0)\n///   inspect(arr, content=\"[0, 0, 0, 0, 0]\")\n///\n///   // Fill from index 1 to 3 (exclusive)\n///   let arr2 = [1, 2, 3, 4, 5]\n///   arr2.fill(99, start=1, end=3)\n///   inspect(arr2, content=\"[1, 99, 99, 4, 5]\")\n///\n///   // Fill from index 2 to end\n///   let arr3 = [\"a\", \"b\", \"c\", \"d\"]\n///   arr3.fill(\"x\", start=2)\n///   inspect(\n///     arr3,\n///     content=(\n///       #|[\"a\", \"b\", \"x\", \"x\"]\n///     ),\n///   )\n/// }\n/// ```\npub fn[A] Array::fill(\n  self : Array[A],\n  value : A,\n  start? : Int = 0,\n  end? : Int,\n) -> Unit {\n  let array_length = self.length()\n  guard array_length > 0 else { return }\n  guard start >= 0 && start < array_length\n  let end = match end {\n    None => array_length\n    Some(e) => {\n      guard e >= 0 && e <= array_length\n      e\n    }\n  }\n  JSArray::ofAnyArray(self).fill(JSValue::ofAny(value), start, end)\n}\n\n///|\n/// Creates and returns a new array with a copy of all elements from the input\n/// array.\n///\n/// Parameters:\n///\n/// * `array` : The array to be copied.\n///\n/// Returns a new array containing all elements from the original array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let original = [1, 2, 3]\n///   let copied = original.copy()\n///   inspect(copied, content=\"[1, 2, 3]\")\n///   inspect(physical_equal(original, copied), content=\"false\")\n/// }\n/// ```\npub fn[T] Array::copy(self : Array[T]) -> Array[T] {\n  JSArray::ofAnyArray(self).copy().toAnyArray()\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn Char::to_hex(char : Char) -> String {\n  let code = char.to_int()\n  match code {\n    0..=0xFF => code.to_byte().to_hex()\n    _..=0xFFFF => (code >> 8).to_byte().to_hex() + code.to_byte().to_hex()\n    _ =>\n      (code >> 16).to_byte().to_hex() +\n      (code >> 8).to_byte().to_hex() +\n      code.to_byte().to_hex()\n  }\n}\n\n///|\ntest \"Char::to_hex\" {\n  // Test various characters\n  inspect(Char::to_hex('A'), content=\"41\")\n  inspect(Char::to_hex('a'), content=\"61\")\n  inspect(Char::to_hex('0'), content=\"30\")\n  inspect(Char::to_hex('\\n'), content=\"0a\")\n  inspect(Char::to_hex('\\u{0}'), content=\"00\")\n  inspect(Char::to_hex('\\u{FF}'), content=\"ff\")\n  inspect(Char::to_hex('\\u{100}'), content=\"0100\")\n  inspect(Char::to_hex('\\u{1000}'), content=\"1000\")\n  inspect(Char::to_hex(''), content=\"01f600\")\n}\n\n///|\npub impl Hash for Char with hash_combine(self, hasher) -> Unit {\n  hasher.combine_char(self)\n}\n\n///|\n/// Checks if the value is within the ASCII range.\npub fn Char::is_ascii(self : Self) -> Bool {\n  self is ('\\u{00}'..='\\u{7F}')\n}\n\n///|\n/// Checks if the value is an ASCII alphabetic  character:\n/// - U+0041 'A' ..= U+005A 'Z'\n/// - U+0061 'a' ..= U+007A 'z'\npub fn Char::is_ascii_alphabetic(self : Self) -> Bool {\n  self is ('A'..='Z' | 'a'..='z')\n}\n\n///|\n/// Checks if the value is an ASCII control character:\n/// U+0000 NUL ..= U+001F UNIT SEPARATOR, or U+007F DELETE.\n/// Note that most ASCII whitespace characters are control characters, but SPACE is not.\npub fn Char::is_ascii_control(self : Self) -> Bool {\n  self is ('\\u{00}'..='\\u{1F}' | '\\u{7F}')\n}\n\n///|\n/// Checks if the value is an ASCII decimal digit:\n/// U+0030 '0' ..= U+0039 '9'\npub fn Char::is_ascii_digit(self : Self) -> Bool {\n  self is ('0'..='9')\n}\n\n///|\n/// Checks if the value is an ASCII graphic character:\n/// U+0021 '!' ..= U+007E '~'\npub fn Char::is_ascii_graphic(self : Self) -> Bool {\n  self is ('\\u{21}'..='\\u{7E}')\n}\n\n///|\n/// Checks if the value is an ASCII hexadecimal digit:\n/// - U+0030 '0' ..= U+0039 '9'\n/// - U+0041 'A' ..= U+0046 'F'\n/// - U+0061 'a' ..= U+0066 'f'\npub fn Char::is_ascii_hexdigit(self : Self) -> Bool {\n  self is ('0'..='9' | 'A'..='F' | 'a'..='f')\n}\n\n///|\n/// Checks if the value is an ASCII lowercase character:\n/// U+0061 'a' ..= U+007A 'z'.\npub fn Char::is_ascii_lowercase(self : Self) -> Bool {\n  self is ('a'..='z')\n}\n\n///|\n/// Checks if the value is an ASCII octal digit:\n/// U+0030 '0' ..= U+0037 '7'\npub fn Char::is_ascii_octdigit(self : Self) -> Bool {\n  self is ('0'..='7')\n}\n\n///|\n/// Checks if the value is an ASCII punctuation character:\n/// - U+0021 ..= U+002F ! \" # $ % & ' ( ) * + , - . /\n/// - U+003A ..= U+0040 : ; < = > ? @\n/// - U+005B ..= U+0060 [ \\ ] ^ _ `\n/// - U+007B ..= U+007E { | } ~\npub fn Char::is_ascii_punctuation(self : Self) -> Bool {\n  self\n  is ('\\u{21}'..='\\u{2F}'\n  | '\\u{3A}'..='\\u{40}'\n  | '\\u{5B}'..='\\u{60}'\n  | '\\u{7B}'..='\\u{7E}')\n}\n\n///|\n/// Checks if the value is an ASCII uppercase character:\n/// U+0041 'A' ..= U+005A 'Z'\npub fn Char::is_ascii_uppercase(self : Self) -> Bool {\n  self is ('A'..='Z')\n}\n\n///|\n/// Checks if the value is an ASCII whitespace character:\n/// U+0020 SPACE, U+0009 HORIZONTAL TAB, U+000A LINE FEED, U+000B VERTICAL TAB, U+000C FORM FEED, or U+000D CARRIAGE RETURN.\npub fn Char::is_ascii_whitespace(self : Self) -> Bool {\n  self is ('\\u{20}' | '\\u{09}' | '\\u{0A}' | '\\u{0B}' | '\\u{0C}' | '\\u{0D}')\n}\n\n///|\n/// Returns true if this char has the general category for control codes.\npub fn Char::is_control(self : Self) -> Bool {\n  self is ('\\u0000'..='\\u001F' | '\\u007F'..='\\u009F')\n}\n\n///|\n/// Checks if a char is a digit in the given radix (range from 2 to 36).\n/// \n/// panic if the radix is invalid.\npub fn Char::is_digit(self : Self, radix : UInt) -> Bool {\n  let v = self.to_uint()\n  match radix {\n    2..=10 => v >= 48 && v <= radix + 47\n    11..=36 =>\n      (v >= 48 && v <= 57) ||\n      (v >= 65 && v <= radix + 54) ||\n      (v >= 97 && v <= radix + 86)\n    _ => panic()\n  }\n}\n\n///|\n/// Returns true if this char has the White_Space property.\npub fn Char::is_whitespace(self : Self) -> Bool {\n  self\n  is ('\\u0009'..='\\u000D'\n  | '\\u0020'\n  | '\\u0085'\n  | '\\u00A0'\n  | '\\u1680'\n  | '\\u2000'..='\\u200A'\n  | '\\u2028'\n  | '\\u2029'\n  | '\\u202F'\n  | '\\u205F'\n  | '\\u3000')\n}\n\n///|\n/// Returns true if this char has one of the general categories for numbers.\npub fn Char::is_numeric(self : Self) -> Bool {\n  self\n  is ('\\u0030'..='\\u0039'\n  | '\\u00B2'\n  | '\\u00B3'\n  | '\\u00B9'\n  | '\\u00BC'\n  | '\\u00BD'\n  | '\\u00BE'\n  | '\\u0660'..='\\u0669'\n  | '\\u06F0'..='\\u06F9'\n  | '\\u07C0'..='\\u07F9'\n  | '\\u0966'..='\\u096F'\n  | '\\u09E6'..='\\u09EF'\n  | '\\u09F4'..='\\u09F9'\n  | '\\u0A66'..='\\u0A6F'\n  | '\\u0AE6'..='\\u0AEF'\n  | '\\u0B66'..='\\u0B6F'\n  | '\\u0B72'..='\\u0B77'\n  | '\\u0BE6'..='\\u0BEF'\n  | '\\u0BF0'..='\\u0BF2'\n  | '\\u0C66'..='\\u0C6F'\n  | '\\u0C78'..='\\u0C7E'\n  | '\\u0CE6'..='\\u0CEF'\n  | '\\u0D58'..='\\u0D5E'\n  | '\\u0D66'..='\\u0D6F'\n  | '\\u0D70'..='\\u0D78'\n  | '\\u0DE6'..='\\u0DEF'\n  | '\\u0E50'..='\\u0E59'\n  | '\\u0ED0'..='\\u0ED9'\n  | '\\u0F20'..='\\u0F33'\n  | '\\u1040'..='\\u1049'\n  | '\\u1090'..='\\u1099'\n  | '\\u1369'..='\\u137C'\n  | '\\u16EE'..='\\u16F0'\n  | '\\u17E0'..='\\u17E9'\n  | '\\u17F0'..='\\u17F9'\n  | '\\u1810'..='\\u1819'\n  | '\\u1946'..='\\u194F'\n  | '\\u19D0'..='\\u19DA'\n  | '\\u1A80'..='\\u1A89'\n  | '\\u1A90'..='\\u1A99'\n  | '\\u1B50'..='\\u1B59'\n  | '\\u1BB0'..='\\u1BB9'\n  | '\\u1C40'..='\\u1C49'\n  | '\\u1C50'..='\\u1C59'\n  | '\\u2070'\n  | '\\u2074'..='\\u2079'\n  | '\\u2080'..='\\u2089'\n  | '\\u2150'..='\\u2189'\n  | '\\u2460'..='\\u249B'\n  | '\\u24EA'..='\\u24FF'\n  | '\\u2776'..='\\u2793'\n  | '\\u2CFD'\n  | '\\u3007'\n  | '\\u3021'..='\\u3029'\n  | '\\u3038'..='\\u303A'\n  | '\\u3192'..='\\u3195'\n  | '\\u3220'..='\\u3229'\n  | '\\u3248'..='\\u324F'\n  | '\\u3251'..='\\u325F'\n  | '\\u3280'..='\\u3289'\n  | '\\u32B1'..='\\u32BF'\n  | '\\uA620'..='\\uA629'\n  | '\\uA6E6'..='\\uA6EF'\n  | '\\uA830'..='\\uA835'\n  | '\\uA8D0'..='\\uA8D9'\n  | '\\uA900'..='\\uA909'\n  | '\\uA9D0'..='\\uA9D9'\n  | '\\uA9F0'..='\\uA9F9'\n  | '\\uAA50'..='\\uAA59'\n  | '\\uABF0'..='\\uABF9'\n  | '\\uFF10'..='\\uFF19'\n  | '\\u{10107}'..='\\u{10133}'\n  | '\\u{10140}'..='\\u{10178}'\n  | '\\u{1018A}'..='\\u{1018B}'\n  | '\\u{102E1}'..='\\u{102FB}'\n  | '\\u{10320}'..='\\u{10323}'\n  | '\\u{10341}'\n  | '\\u{1034A}'\n  | '\\u{103D1}'..='\\u{103D5}'\n  | '\\u{104A0}'..='\\u{104A9}'\n  | '\\u{10858}'..='\\u{1085F}'\n  | '\\u{10879}'..='\\u{1087F}'\n  | '\\u{108A7}'..='\\u{108AF}'\n  | '\\u{108FB}'..='\\u{108FF}'\n  | '\\u{10916}'..='\\u{1091B}'\n  | '\\u{109BC}'..='\\u{109BD}'\n  | '\\u{109C0}'..='\\u{109CF}'\n  | '\\u{10A40}'..='\\u{10A48}'\n  | '\\u{10A7D}'..='\\u{10A7E}'\n  | '\\u{10A9D}'..='\\u{10A9F}'\n  | '\\u{10AEB}'..='\\u{10AEF}'\n  | '\\u{10B58}'..='\\u{10B5F}'\n  | '\\u{10B78}'..='\\u{10B7F}'\n  | '\\u{10BA9}'..='\\u{10BAF}'\n  | '\\u{10CFA}'..='\\u{10CFF}'\n  | '\\u{10D30}'..='\\u{10D39}'\n  | '\\u{10D40}'..='\\u{10D49}'\n  | '\\u{10E60}'..='\\u{10E7E}'\n  | '\\u{10F1D}'..='\\u{10F26}'\n  | '\\u{10F51}'..='\\u{10F54}'\n  | '\\u{10FC5}'..='\\u{10FCB}'\n  | '\\u{11052}'..='\\u{1106F}'\n  | '\\u{110F0}'..='\\u{110F9}'\n  | '\\u{11136}'..='\\u{1113F}'\n  | '\\u{111D0}'..='\\u{111D9}'\n  | '\\u{111E1}'..='\\u{111F4}'\n  | '\\u{112F0}'..='\\u{112F9}'\n  | '\\u{11450}'..='\\u{11459}'\n  | '\\u{114D0}'..='\\u{114D9}'\n  | '\\u{11650}'..='\\u{11659}'\n  | '\\u{116C0}'..='\\u{116C9}'\n  | '\\u{116D0}'..='\\u{116E3}'\n  | '\\u{11730}'..='\\u{1173B}'\n  | '\\u{118E0}'..='\\u{118F2}'\n  | '\\u{11950}'..='\\u{11959}'\n  | '\\u{11BF0}'..='\\u{11BF9}'\n  | '\\u{11C50}'..='\\u{11C6C}'\n  | '\\u{11D50}'..='\\u{11D59}'\n  | '\\u{11DA0}'..='\\u{11DA9}'\n  | '\\u{11F50}'..='\\u{11F59}'\n  | '\\u{11FC0}'..='\\u{11FD4}'\n  | '\\u{12400}'..='\\u{1246E}'\n  | '\\u{16130}'..='\\u{16139}'\n  | '\\u{16A60}'..='\\u{16A69}'\n  | '\\u{16AC0}'..='\\u{16AC9}'\n  | '\\u{16B50}'..='\\u{16B59}'\n  | '\\u{16B5B}'..='\\u{16B61}'\n  | '\\u{16D70}'..='\\u{16D79}'\n  | '\\u{16D80}'..='\\u{16E96}'\n  | '\\u{1CCF0}'..='\\u{1CCF9}'\n  | '\\u{1D2C0}'..='\\u{1D2F3}'\n  | '\\u{1D360}'..='\\u{1D378}'\n  | '\\u{1D7CE}'..='\\u{1D7FF}'\n  | '\\u{1E140}'..='\\u{1E149}'\n  | '\\u{1E2F0}'..='\\u{1E2F9}'\n  | '\\u{1E4F0}'..='\\u{1E4F9}'\n  | '\\u{1E5F1}'..='\\u{1E5FA}'\n  | '\\u{1E8C7}'..='\\u{1E8CF}'\n  | '\\u{1E950}'..='\\u{1E959}'\n  | '\\u{1EC71}'..='\\u{1ECB4}'\n  | '\\u{1ED01}'..='\\u{1ED3D}'\n  | '\\u{1F100}'..='\\u{1F10C}'\n  | '\\u{1FBF0}'..='\\u{1FBF9}')\n}\n\n///|\n/// Returns true if this character is printable (visible when displayed).\n/// Aligns with Unicode standard categories for printable characters.\n/// Characters are considered printable if they are:\n/// - Letters (L*)\n/// - Marks (M*)\n/// - Numbers (N*)\n/// - Punctuation (P*)\n/// - Symbols (S*)\n/// - Spaces (Zs), with some exceptions\n/// Characters are considered non-printable if they are:\n/// - Control characters (Cc)\n/// - Format characters (Cf)\n/// - Line/paragraph separators (Zl, Zp)\n/// - Private use (Co)\n/// - Unassigned (Cn)\n/// - Surrogates (Cs)\npub fn Char::is_printable(self : Self) -> Bool {\n  // Check for control characters (Cc)\n  if self.is_control() {\n    return false\n  }\n  let self = self.to_int()\n\n  // Private use areas (Co)\n  if self is (0xE000..=0xF8FF | 0xF0000..=0xFFFFD | 0x100000..=0x10FFFD) {\n    return false\n  }\n\n  // Format characters (Cf)\n  if self\n    is ('\\u{00AD}'\n    | '\\u{0600}'..='\\u{0605}'\n    | '\\u{061C}'\n    | '\\u{06DD}'\n    | '\\u{070F}'\n    | '\\u{0890}'..='\\u{0891}'\n    | '\\u{08E2}'\n    | '\\u{180E}'\n    | '\\u{200B}'..='\\u{200F}'\n    | '\\u{202A}'..='\\u{202E}'\n    | '\\u{2060}'..='\\u{2064}'\n    | '\\u{2066}'..='\\u{206F}'\n    | '\\u{feff}'\n    | '\\u{FFF9}'..='\\u{FFFB}'\n    | '\\u{110BD}'\n    | '\\u{110CD}'\n    | '\\u{13430}'..='\\u{1343F}'\n    | '\\u{1BCA0}'..='\\u{1BCA3}'\n    | '\\u{1D173}'..='\\u{1D17A}'\n    | '\\u{E0001}'\n    | '\\u{E0020}'..='\\u{E007F}') {\n    return false\n  }\n  // Surrogate (Cs)\n  if self.is_surrogate() {\n    return false\n  }\n\n  // Line and paragraph separators (Zl, Zp)\n  if self == '\\u{2028}' || self == '\\u{2029}' {\n    return false\n  }\n\n  // Noncharacter\n  if self\n    is (0xFDD0..=0xFDEF\n    | 0xFFFE..=0xFFFF\n    | 0x1FFFE..=0x1FFFF\n    | 0x2FFFE..=0x2FFFF\n    | 0x3FFFE..=0x3FFFF\n    | 0x4FFFE..=0x4FFFF\n    | 0x5FFFE..=0x5FFFF\n    | 0x6FFFE..=0x6FFFF\n    | 0x7FFFE..=0x7FFFF\n    | 0x8FFFE..=0x8FFFF\n    | 0x9FFFE..=0x9FFFF\n    | 0xAFFFE..=0xAFFFF\n    | 0xBFFFE..=0xBFFFF\n    | 0xCFFFE..=0xCFFFF\n    | 0xDFFFE..=0xDFFFF\n    | 0xEFFFE..=0xEFFFF\n    | 0xFFFFE..=0xFFFFF\n    | 0x10FFFE..=0x10FFFF) {\n    return false\n  }\n  true\n}\n\n///|\n/// Makes a copy of the value in its ASCII lower case equivalent.\n/// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n/// but non-ASCII letters are unchanged.\npub fn Char::to_ascii_lowercase(self : Self) -> Char {\n  if self.is_ascii_uppercase() {\n    return (self.to_int() + 32).unsafe_to_char()\n  }\n  self\n}\n\n///|\n/// Makes a copy of the value in its ASCII upper case equivalent.\n/// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n/// but non-ASCII letters are unchanged.\npub fn Char::to_ascii_uppercase(self : Self) -> Char {\n  if self.is_ascii_lowercase() {\n    return (self.to_int() - 32).unsafe_to_char()\n  }\n  self\n}\n\n///|\n/// Convert Char to String\npub impl Show for Char with to_string(self : Char) -> String {\n  char_to_string(self)\n}\n\n///|\n/// TODO: support attributes for impl\n#intrinsic(\"%char.to_string\")\nfn char_to_string(char : Char) -> String {\n  [char]\n}\n\n///|\n/// Show implementation for Char that produces a human-readable representation\n/// of characters suitable for debugging and display purposes.\n/// \n/// The output format follows Rust/C-style character literal syntax with single quotes.\n/// \n/// ## Format Rules\n/// \n/// 1. **Wrapper**: All characters are wrapped in single quotes: `'c'`\n/// \n/// 2. **Special escape sequences**: Common control characters use backslash escapes:\n///    - `\\'` for single quote (U+0027)\n///    - `\\\\` for backslash (U+005C)\n///    - `\\n` for line feed (U+000A)\n///    - `\\r` for carriage return (U+000D)\n///    - `\\b` for backspace (U+0008)\n///    - `\\t` for horizontal tab (U+0009)\n/// \n/// 3. **ASCII printable range**: Characters from space (U+0020) to tilde (U+007E)\n///    are displayed as-is: `'A'`, `'5'`, `'@'`\n/// \n/// 4. **Unicode escape sequences**: Non-printable characters use `\\u{...}` format\n///    with minimal hex digits (no leading zeros)\n/// \n/// ## When Char::to_hex is Called\n/// \n/// The `Char::to_hex` function is called for characters that:\n/// - Are not in the ASCII printable range (U+0020 to U+007E)\n/// - Are not one of the special escape sequences\n/// - Fail the `is_printable()` check (control chars, format chars, private use, etc.)\n/// \n/// For such characters, `Char::to_hex` converts the entire Unicode code point\n/// to its minimal hexadecimal string representation.\n/// \n/// ## Examples\n/// \n/// - ASCII printable: `'A'` displays as `'A'`\n/// - Special escape: `'\\n'` displays as `'\\n'`  \n/// - Non-printable: `'\\u{0}'` displays as `'\\u{0}'`\n/// - Emoji: `'\\u{1F600}'` displays as `'\\u{1f600}'`\npub impl Show for Char with output(self, logger) {\n\n  // Start with opening single quote\n  logger.write_char('\\'')\n  match self {\n    // Handle characters that need special escape sequences\n    '\\'' | '\\\\' => {\n      logger.write_char('\\\\')\n      logger.write_char(self)\n    }\n    '\\n' => logger.write_string(\"\\\\n\")\n    '\\r' => logger.write_string(\"\\\\r\")\n    '\\b' => logger.write_string(\"\\\\b\")\n    '\\t' => logger.write_string(\"\\\\t\")\n\n    // ASCII printable characters (space through tilde): display as-is\n    ' '..='~' => logger.write_char(self)\n\n    // All other characters: check if they're printable\n    _ =>\n      if !self.is_printable() {\n        // Non-printable characters get Unicode escape sequences: \\u{...}\n        logger.write_string(\"\\\\u{\")\n        logger.write_string(self.to_hex())\n        logger.write_char('}')\n      } else {\n        // Printable Unicode characters outside ASCII range: display as-is\n        // Examples: emoji, accented letters, CJK characters, etc.\n        logger.write_char(self)\n      }\n  }\n\n  // End with closing single quote\n  logger.write_char('\\'')\n}\n\n///|\npub impl ToJson for Char with to_json(self : Char) -> Json {\n  Json::string(self.to_string())\n}\n\n///|\n/// Returns the number of UTF-16 code units required to encode this character.\n///\n/// Parameters:\n///\n/// * `self` : The character to analyze.\n///\n/// Returns the number of UTF-16 code units (1 or 2) needed to represent this\n/// character.\n/// Note surrogate pairs are counted as 2, it should not happen in general since \n/// surrogate pair is Int instead of Char.\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect('A'.utf16_len(), content=\"1\")\n///   inspect(''.utf16_len(), content=\"2\")\n/// }\n/// ```\n///\npub fn Char::utf16_len(self : Self) -> Int {\n  let code = self.to_int()\n  if code <= 0xFFFF {\n    1\n  } else {\n    2\n  }\n}\n\n///|\n/// Returns true if this character is in the Basic Multilingual Plane (BMP).\n/// \n/// The BMP (Basic Multilingual Plane) contains 65,536 code points (U+0000 to U+FFFF)\n/// distributed as follows:\n/// \n/// - **~57,022 actual Unicode character positions** (87% of BMP)\n/// - **2,048 surrogate code points** (U+D800-U+DFFF) - reserved for UTF-16 encoding\n///   - High surrogates: U+D800-U+DBFF (1,024 code points)\n///   - Low surrogates: U+DC00-U+DFFF (1,024 code points)\n/// - **6,400 private use area** (U+E000-U+F8FF) - for custom characters\n/// - **66 permanent noncharacters** (including U+FFFE, U+FFFF, U+FDD0-U+FDEF)\n/// \n/// Note: Surrogate code points are not actual characters but encoding mechanisms\n/// for representing characters outside the BMP in UTF-16.\n/// \n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect('A'.is_bmp(), content=\"true\")\n///   inspect(''.is_bmp(), content=\"false\")\n/// }\n/// ```\n/// \npub fn Char::is_bmp(self : Self) -> Bool {\n  self.to_int() <= 0xFFFF\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\npub impl Show for Unit with output(_self, logger) {\n  logger.write_string(\"()\")\n}\n\n///|\npub impl Show for Bool with output(self, logger) {\n  if self {\n    logger.write_string(\"true\")\n  } else {\n    logger.write_string(\"false\")\n  }\n}\n\n///|\npub impl Show for Int with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub impl Show for Int64 with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub impl Show for UInt with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub impl Show for UInt64 with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub impl Show for Byte with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub impl Show for UInt16 with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub fn Byte::to_hex(b : Byte) -> String {\n  fn to_hex_digit(i : Byte) -> Char {\n    if i < 10 {\n      (i + '0').to_char()\n    } else {\n      (i + 'a' - 10).to_char()\n    }\n  }\n\n  [to_hex_digit(b / 16), to_hex_digit(b % 16)]\n}\n\n///|\ntest \"to_hex_digit\" {\n  inspect(Byte::to_hex(b'\\xee'), content=\"ee\")\n  inspect(Byte::to_hex(b'\\xf3'), content=\"f3\")\n}\n\n///|\npub impl Show for String with output(self, logger) {\n  logger.write_char('\"')\n  fn flush_segment(seg : Int, i : Int) {\n    if i > seg {\n      logger.write_substring(self, seg, i - seg)\n    }\n  }\n  // The loop keeps two pieces of state:\n  //   i   : the current scanning position\n  //   seg : the beginning index of the current \"plain\" segment that has\n  //         no escaping requirements. Whenever we meet a character that\n  //         needs escaping, we flush the segment [seg, i) and reset seg.\n  let len = self.length()\n  for i = 0, seg = 0 {\n    if i >= len {\n      // If we reached the end of the string, flush any remaining segment\n      // and break out of the loop.\n      flush_segment(seg, i)\n      break\n    }\n    let code = self.unsafe_get(i)\n    match code {\n      '\"' | '\\\\' as c => {\n        flush_segment(seg, i)\n        logger.write_char('\\\\')\n        logger.write_char(c.unsafe_to_char())\n        // Advance both pointers: continue with next index, new segment starts after current char\n        continue i + 1, i + 1\n      }\n      '\\n' => {\n        flush_segment(seg, i)\n        logger.write_string(\"\\\\n\")\n        continue i + 1, i + 1\n      }\n      '\\r' => {\n        flush_segment(seg, i)\n        logger.write_string(\"\\\\r\")\n        continue i + 1, i + 1\n      }\n      '\\b' => {\n        flush_segment(seg, i)\n        logger.write_string(\"\\\\b\")\n        continue i + 1, i + 1\n      }\n      '\\t' => {\n        flush_segment(seg, i)\n        logger.write_string(\"\\\\t\")\n        continue i + 1, i + 1\n      }\n      code =>\n        if code < ' ' {\n          // has to be ascii\n          flush_segment(seg, i)\n          logger.write_string(\"\\\\u{\")\n          logger.write_string(code.to_byte().to_hex())\n          logger.write_char('}')\n          continue i + 1, i + 1\n        } else {\n          // Normal character, keep scanning; only advance index.\n          continue i + 1, seg\n        }\n    }\n  }\n  logger.write_char('\"')\n}\n\n///|\n/// This is different from `Show::output`,\n/// here it returns the original string without escaping. \n/// The rationale is in string interpolation,\n/// we want to show the original string, not the escaped one.\n/// # Examples\n/// \n/// ```mbt check\n/// test {\n///   let str = \"Hello \\n\"\n///   inspect(str.to_string(), content=\"Hello \\n\")\n///   inspect(str.escape(), content=\"\\\"Hello \\\\n\\\"\")\n/// }\n/// ```\npub impl Show for String with to_string(self) {\n  self\n}\n\n///|\n/// Returns a valid MoonBit string literal representation of a string,\n/// add quotes and escape special characters.\n/// # Examples\n/// \n/// ```mbt check\n/// test {\n///   let str = \"Hello \\n\"\n///   inspect(str.to_string(), content=\"Hello \\n\")\n///   inspect(str.escape(), content=\"\\\"Hello \\\\n\\\"\")\n/// }\n/// ```\npub fn String::escape(self : String) -> String {\n  let buf = StringBuilder::new()\n  Show::output(self, buf)\n  buf.to_string()\n}\n\n///|\npub impl[X : Show] Show for X? with output(self, logger) {\n  match self {\n    None => logger.write_string(\"None\")\n    Some(arg) => {\n      logger.write_string(\"Some(\")\n      logger.write_object(arg)\n      logger.write_string(\")\")\n    }\n  }\n}\n\n///|\npub impl[T : Show, E : Show] Show for Result[T, E] with output(self, logger) {\n  match self {\n    Ok(x) => {\n      logger.write_string(\"Ok(\")\n      logger.write_object(x)\n      logger.write_string(\")\")\n    }\n    Err(e) => {\n      logger.write_string(\"Err(\")\n      logger.write_object(e)\n      logger.write_string(\")\")\n    }\n  }\n}\n\n///|\npub impl[X : Show] Show for FixedArray[X] with output(self, logger) {\n  logger.write_iter(self.iter())\n}\n\n///|\npub impl[X : Show] Show for Array[X] with output(self, logger) {\n  logger.write_iter(self.iter())\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// #region type definition and intrinsics\n\n///|\n/// An `ArrayView` represents a view into a section of an array without copying the data.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let view = arr[1:4] // Creates a view of elements at indices 1,2,3\n///   assert_eq(view[0], 2)\n///   assert_eq(view.length(), 3)\n/// }\n/// ```\n#builtin.valtype\ntype ArrayView[T]\n\n///|\nfn[T] ArrayView::buf(self : ArrayView[T]) -> UninitializedArray[T] = \"%arrayview.buf\"\n\n///|\nfn[T] ArrayView::start(self : ArrayView[T]) -> Int = \"%arrayview.start\"\n\n///|\nfn[T] ArrayView::len(self : ArrayView[T]) -> Int = \"%arrayview.len\"\n\n///|\nfn[T] ArrayView::make(\n  buf : UninitializedArray[T],\n  start : Int,\n  len : Int,\n) -> ArrayView[T] = \"%arrayview.make\"\n\n// #endregion\n\n// #region methods\n\n///|\n/// Returns the length (number of elements) of an array view.\n///\n/// Parameters:\n///\n/// * `array_view` : The array view whose length is to be determined.\n///\n/// Returns an integer representing the number of elements in the array view.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let view = arr[2:4]\n///   inspect(view.length(), content=\"2\")\n/// }\n/// ```\npub fn[T] ArrayView::length(self : ArrayView[T]) -> Int {\n  self.len()\n}\n\n///|\n/// Returns whether the array view is empty.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let view = [1, 2, 3][:]\n///   inspect(view.is_empty(), content=\"false\")\n///   let empty = [1, 2][0:0]\n///   inspect(empty.is_empty(), content=\"true\")\n/// }\n/// ```\npub fn[T] ArrayView::is_empty(self : ArrayView[T]) -> Bool {\n  self.length() == 0\n}\n\n///|\npub fn[T] ArrayView::start_offset(self : Self[T]) -> Int {\n  self.start()\n}\n\n///|\n/// Retrieves an element at the specified index from the array view.\n///\n/// Parameters:\n///\n/// * `self` : The array view to access.\n/// * `index` : The position in the array view from which to retrieve the\n/// element.\n///\n/// Returns the element at the specified index.\n///\n/// Throws a runtime error if the index is out of bounds (less than 0 or greater\n/// than or equal to the length of the array view).\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let view = arr[2:4]\n///   inspect(view[0], content=\"3\")\n///   inspect(view[1], content=\"4\")\n/// }\n/// ```\n#alias(\"_[_]\")\npub fn[T] ArrayView::at(self : ArrayView[T], index : Int) -> T {\n  guard index >= 0 && index < self.len() else {\n    abort(\n      \"index out of bounds: the len is from 0 to \\{self.len()} but the index is \\{index}\",\n    )\n  }\n  self.buf()[self.start() + index]\n}\n\n///|\n/// Retrieves an element from the array view at the specified index.\n///\n/// Parameters:\n///\n/// * `self` : The array view to retrieve the element from.\n/// * `index` : The position in the array view from which to retrieve the\n/// element.\n///\n/// Returns `Some(element)` if the index is within bounds, or `None` if the index\n/// is out of bounds.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let view = arr[1:4]\n///   inspect(view.get(0), content=\"Some(2)\")\n///   inspect(view.get(1), content=\"Some(3)\")\n///   inspect(view.get(2), content=\"Some(4)\")\n///   inspect(view.get(5), content=\"None\")\n/// }\n/// ```\npub fn[T] ArrayView::get(self : ArrayView[T], index : Int) -> T? {\n  let len = self.length()\n  guard index >= 0 && index < len else { None }\n  Some(self.buf()[self.start() + index])\n}\n\n///|\n/// Returns the last element of the array view, if any.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let view = [1, 2, 3][:]\n///   inspect(view.last(), content=\"Some(3)\")\n///   let empty = [1, 2][0:0]\n///   inspect(empty.last(), content=\"None\")\n/// }\n/// ```\npub fn[T] ArrayView::last(self : ArrayView[T]) -> T? {\n  let len = self.length()\n  if len == 0 {\n    None\n  } else {\n    Some(self.unsafe_get(len - 1))\n  }\n}\n\n///|\n/// Retrieves an element from the array view at the specified index without\n/// performing bounds checking.\n///\n/// Parameters:\n///\n/// * `array_view` : The array view to retrieve the element from.\n/// * `index` : The position in the array view from which to retrieve the\n/// element.\n///\n/// Returns the element at the specified index in the array view.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let view = arr[1:4]\n///   inspect(view.unsafe_get(1), content=\"3\")\n/// }\n/// ```\n#intrinsic(\"%arrayview.unsafe_get\")\n#internal(unsafe, \"Panic if index is out of bounds\")\n#doc(hidden)\npub fn[T] ArrayView::unsafe_get(self : ArrayView[T], index : Int) -> T {\n  self.buf()[self.start() + index]\n}\n\n///|\n/// Creates a view of a portion of the array. The view provides read-write access\n/// to the underlying array without copying the elements.\n///\n/// Parameters:\n///\n/// * `array` : The array to create a view from.\n/// * `start` : The starting index of the view (inclusive). Defaults to 0.\n/// * `end` : The ending index of the view (exclusive). If not provided, defaults\n/// to the length of the array.\n///\n/// Returns an `ArrayView` that provides a window into the specified portion of\n/// the array.\n///\n/// Throws a panic if the indices are invalid (i.e., `start` is negative, `end`\n/// is greater than the array length, or `start` is greater than `end`).\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let view = arr[1:4] // Create a view of elements at indices 1, 2, and 3\n///   inspect(view[0], content=\"2\") // First element of view is arr[1]\n///   inspect(view.length(), content=\"3\") // View contains 3 elements\n/// }\n/// ```\n#alias(\"_[_:_]\")\n#alias(sub, deprecated=\"Use _[_:_] instead\")\npub fn[T] Array::view(\n  self : Array[T],\n  start? : Int = 0,\n  end? : Int,\n) -> ArrayView[T] {\n  let len = self.length()\n  let end = match end {\n    None => len\n    Some(end) => if end < 0 { len + end } else { end }\n  }\n  let start = if start < 0 { len + start } else { start }\n  guard start >= 0 && start <= end && end <= len else {\n    abort(\"View index out of bounds\")\n  }\n  ArrayView::make(self.buffer(), start, end - start)\n}\n\n///|\n/// Creates a view of a portion of the array, returning `None` when indices are\n/// invalid.\n///\n/// Parameters:\n///\n/// * `array` : The array to create a view from.\n/// * `start` : The starting index of the view (inclusive). Defaults to 0.\n/// * `end` : The ending index of the view (exclusive). If not provided, defaults\n/// to the length of the array.\n///\n/// Returns `Some(ArrayView)` that provides a window into the specified portion\n/// of the array, or `None` when the indices are invalid.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let start = 1\n///   let end = 4\n///   inspect(arr.get_view(start~, end~), content=\"Some([2, 3, 4])\")\n///   let start = 3\n///   let end = 10\n///   inspect(arr.get_view(start~, end~), content=\"None\")\n/// }\n/// ```\npub fn[T] Array::get_view(\n  self : Array[T],\n  start? : Int = 0,\n  end? : Int,\n) -> ArrayView[T]? {\n  let len = self.length()\n  let end = match end {\n    None => len\n    Some(end) => if end < 0 { len + end } else { end }\n  }\n  let start = if start < 0 { len + start } else { start }\n  guard start >= 0 && start <= end && end <= len else { None }\n  Some(ArrayView::make(self.buffer(), start, end - start))\n}\n\n///|\n/// Creates a new view into a portion of the array view.\n///\n/// Parameters:\n///\n/// * `self` : The array view to create a new view from.\n/// * `start` : The starting index in the current view (inclusive). Defaults to\n/// 0.\n/// * `end` : The ending index in the current view (exclusive). Defaults to the\n/// length of the current view.\n///\n/// Returns a new `ArrayView` that provides a window into the specified portion\n/// of the original array view. The indices are relative to the start of the\n/// current view.\n///\n/// Throws a panic if:\n///\n/// * `start` is negative\n/// * `end` is greater than the length of the current view\n/// * `start` is greater than `end`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let view = arr[1:4] // view = [2, 3, 4]\n///   let subview = view[1:2] // subview = [3]\n///   inspect(subview[0], content=\"3\")\n/// }\n/// ```\n#alias(\"_[_:_]\")\n#alias(sub, deprecated=\"Use _[_:_] instead\")\npub fn[T] ArrayView::view(\n  self : ArrayView[T],\n  start? : Int = 0,\n  end? : Int,\n) -> ArrayView[T] {\n  let len = self.length()\n  let end = match end {\n    None => len\n    Some(end) => if end < 0 { len + end } else { end }\n  }\n  let start = if start < 0 { len + start } else { start }\n  guard start >= 0 && start <= end && end <= len else {\n    abort(\"View index out of bounds\")\n  }\n  ArrayView::make(self.buf(), self.start() + start, end - start)\n}\n\n///|\n/// Creates a new view into a portion of the array view, returning `None` when\n/// indices are invalid.\n///\n/// Parameters:\n///\n/// * `self` : The array view to create a new view from.\n/// * `start` : The starting index in the current view (inclusive). Defaults to\n/// 0.\n/// * `end` : The ending index in the current view (exclusive). Defaults to the\n/// length of the current view.\n///\n/// Returns `Some(ArrayView)` that provides a window into the specified portion\n/// of the original array view, or `None` when the indices are invalid.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let view = arr[1:4] // view = [2, 3, 4]\n///   let start = 1\n///   let end = 2\n///   inspect(view.get_view(start~, end~), content=\"Some([3])\")\n///   let start = 4\n///   let end = 5\n///   inspect(view.get_view(start~, end~), content=\"None\")\n/// }\n/// ```\npub fn[T] ArrayView::get_view(\n  self : ArrayView[T],\n  start? : Int = 0,\n  end? : Int,\n) -> ArrayView[T]? {\n  let len = self.length()\n  let end = match end {\n    None => len\n    Some(end) => if end < 0 { len + end } else { end }\n  }\n  let start = if start < 0 { len + start } else { start }\n  guard start >= 0 && start <= end && end <= len else { None }\n  Some(ArrayView::make(self.buf(), self.start() + start, end - start))\n}\n\n///|\nfn[T] unsafe_cast_fixedarray_to_uninitializedarray(\n  arr : FixedArray[T],\n) -> UninitializedArray[T] = \"%identity\"\n\n///|\n/// Creates a new `ArrayView` from a `FixedArray`.\n///\n/// Parameters:\n///\n/// * `self` : The fixed array to create a new view from.\n/// * `start` : The starting index in the array (inclusive). Defaults to 0.\n/// * `end` : The ending index in the array (exclusive). Defaults to the\n/// length of the array.\n///\n/// Returns a new `ArrayView` that provides a window into the specified portion\n/// of the original fixed array.\n///\n/// Throws a panic if:\n///\n/// * `start` is negative\n/// * `end` is greater than the length of the array\n/// * `start` is greater than `end`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr : FixedArray[Int] = [1, 2, 3, 4, 5]\n///   let view = arr[1:4] // view = [2, 3, 4]\n///   inspect(view[0], content=\"2\")\n/// }\n/// ```\n#alias(\"_[_:_]\")\n#alias(sub, deprecated=\"Use _[_:_] instead\")\npub fn[T] FixedArray::view(\n  self : FixedArray[T],\n  start? : Int = 0,\n  end? : Int,\n) -> ArrayView[T] {\n  let len = self.length()\n  let end = match end {\n    None => len\n    Some(end) => if end < 0 { len + end } else { end }\n  }\n  let start = if start < 0 { len + start } else { start }\n  guard start >= 0 && start <= end && end <= len else {\n    abort(\"View index out of bounds\")\n  }\n  ArrayView::make(\n    unsafe_cast_fixedarray_to_uninitializedarray(self),\n    start,\n    end - start,\n  )\n}\n\n///|\n/// Creates a new `ArrayView` from a `FixedArray`, returning `None` when indices\n/// are invalid.\n///\n/// Parameters:\n///\n/// * `self` : The fixed array to create a new view from.\n/// * `start` : The starting index in the array (inclusive). Defaults to 0.\n/// * `end` : The ending index in the array (exclusive). Defaults to the\n/// length of the array.\n///\n/// Returns `Some(ArrayView)` that provides a window into the specified portion\n/// of the original fixed array, or `None` when the indices are invalid.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr : FixedArray[Int] = [1, 2, 3, 4, 5]\n///   let start = 1\n///   let end = 4\n///   inspect(arr.get_view(start~, end~), content=\"Some([2, 3, 4])\")\n///   let start = 2\n///   let end = 10\n///   inspect(arr.get_view(start~, end~), content=\"None\")\n/// }\n/// ```\npub fn[T] FixedArray::get_view(\n  self : FixedArray[T],\n  start? : Int = 0,\n  end? : Int,\n) -> ArrayView[T]? {\n  let len = self.length()\n  let end = match end {\n    None => len\n    Some(end) => if end < 0 { len + end } else { end }\n  }\n  let start = if start < 0 { len + start } else { start }\n  guard start >= 0 && start <= end && end <= len else { None }\n  Some(\n    ArrayView::make(\n      unsafe_cast_fixedarray_to_uninitializedarray(self),\n      start,\n      end - start,\n    ),\n  )\n}\n\n///|\npub fn[T] ArrayView::suffixes(\n  self : Self[T],\n  include_empty? : Bool = false,\n) -> Iter[ArrayView[T]] {\n  let len = self.length()\n  let mut i = 0\n  Iter::new(fn() -> ArrayView[T]? {\n    if i < len {\n      let suffix = self[i:]\n      i += 1\n      Some(suffix)\n    } else if i == len {\n      i += 1\n      if include_empty {\n        Some(self[len:])\n      } else {\n        None\n      }\n    } else {\n      None\n    }\n  })\n}\n\n///|\n/// Returns an iterator that yields each element of the array view in sequence\n/// from start to end.\n///\n/// Parameters:\n///\n/// * `array_view` : The array view to iterate over.\n///\n/// Returns an iterator that yields elements of type `A` from the array view.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   let view = arr[1:]\n///   let mut sum = 0\n///   view.iter().each(x => sum = sum + x)\n///   inspect(sum, content=\"5\")\n/// }\n/// ```\n#alias(iterator, deprecated)\npub fn[X] ArrayView::iter(self : ArrayView[X]) -> Iter[X] {\n  let mut i = 0\n  Iter::new(fn() {\n    guard i < self.length() else { None }\n    let elem = self.unsafe_get(i)\n    i += 1\n    Some(elem)\n  })\n}\n\n///|\n#alias(rev_iterator, deprecated)\npub fn[X] ArrayView::rev_iter(self : ArrayView[X]) -> Iter[X] {\n  let mut i = self.length()\n  Iter::new(fn() {\n    guard i > 0 else { None }\n    i -= 1\n    Some(self.unsafe_get(i))\n  })\n}\n\n///|\n/// Returns an iterator that yields tuples of index and value\n/// indices start from 0.\n/// \n/// Example:\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   let view = arr[1:]\n///   let mut sum = 0\n///   let mut sum_keys = 0\n///   view\n///   .iter2()\n///   .each((i, x) => {\n///     sum = sum + x\n///     sum_keys = sum_keys + i\n///   })\n///   inspect(sum, content=\"5\")\n///   inspect(sum_keys, content=\"1\")\n/// }\n/// ```\n#alias(iterator2, deprecated)\npub fn[X] ArrayView::iter2(self : ArrayView[X]) -> Iter2[Int, X] {\n  let mut i = 0\n  Iter2::new(fn() {\n    guard i < self.length() else { None }\n    let result = Some((i, self.unsafe_get(i)))\n    i += 1\n    result\n  })\n}\n\n///|\n/// Iterates over each element in the array view and applies a function to it.\n///\n/// Parameters:\n///\n/// * `self` : The array view to iterate over.\n/// * `function` : A function that takes an element of type `T` and returns\n/// nothing. This function will be applied to each element in the array view.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3][:]\n///   let mut sum = 0\n///   arr.each(x => sum = sum + x)\n///   inspect(sum, content=\"6\")\n/// }\n/// ```\npub fn[T] ArrayView::each(\n  self : ArrayView[T],\n  f : (T) -> Unit raise?,\n) -> Unit raise? {\n  for v in self {\n    f(v)\n  }\n}\n\n///|\n/// Iterates over the elements of the array view with index.\n///\n/// # Example\n/// \n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5][:]\n///   let mut sum = 0\n///   v.eachi((i, x) => sum = sum + x + i)\n///   inspect(sum, content=\"15\")\n/// }\n/// ```\npub fn[T] ArrayView::eachi(\n  self : ArrayView[T],\n  f : (Int, T) -> Unit raise?,\n) -> Unit raise? {\n  for i, v in self {\n    f(i, v)\n  }\n}\n\n///|\n/// Checks if all elements in the array view match the condition.\n/// \n/// # Example\n/// \n/// ```mbt check\n/// test {\n///   let v = [1, 4, 6, 8, 9]\n///   assert_false(v[:].all(elem => elem % 2 == 0))\n///   assert_true(v[1:4].all(elem => elem % 2 == 0))\n/// }\n/// ```\n#alias(every)\npub fn[T] ArrayView::all(\n  self : ArrayView[T],\n  f : (T) -> Bool raise?,\n) -> Bool raise? {\n  for v in self {\n    if !f(v) {\n      return false\n    }\n  }\n  true\n}\n\n///|\n/// Check if any of the elements in the array view match the condition.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let v = [1, 2, 3, 4, 5][:]\n///   assert_true(v.any(ele => ele < 6))\n///   assert_false(v.any(ele => ele < 1))\n/// }\n/// ```\n#alias(exists)\npub fn[T] ArrayView::any(\n  self : ArrayView[T],\n  f : (T) -> Bool raise?,\n) -> Bool raise? {\n  for v in self {\n    if f(v) {\n      return true\n    }\n  }\n  false\n}\n\n///|\n/// Checks whether the array view contains a specific element by comparing each\n/// element with the target value using the equality operator.\n///\n/// Parameters:\n///\n/// * `view` : The array view to search in.\n/// * `target` : The value to search for in the array view.\n///\n/// Returns a boolean value indicating whether the target value exists in the\n/// array view.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5][:]\n///   inspect(arr.contains(3), content=\"true\")\n///   inspect(arr.contains(6), content=\"false\")\n/// }\n/// ```\npub fn[T : Eq] ArrayView::contains(self : ArrayView[T], value : T) -> Bool {\n  for v in self {\n    if v == value {\n      break true\n    }\n  } else {\n    false\n  }\n}\n\n///|\n/// Searches for the first occurrence of a value in the array view.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let view = [1, 2, 3, 2, 4][:]\n///   inspect(view.search(2), content=\"Some(1)\")\n///   inspect(view.search(5), content=\"None\")\n/// }\n/// ```\npub fn[T : Eq] ArrayView::search(self : ArrayView[T], value : T) -> Int? {\n  for i in 0..<self.length() {\n    if self.unsafe_get(i) == value {\n      break Some(i)\n    }\n  } else {\n    None\n  }\n}\n\n///|\n/// Checks if the array view starts with the given prefix.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let view = [1, 2, 3, 4, 5][:]\n///   inspect(view.starts_with([1, 2][:]), content=\"true\")\n///   inspect(view.starts_with([2, 3][:]), content=\"false\")\n/// }\n/// ```\npub fn[T : Eq] ArrayView::starts_with(\n  self : ArrayView[T],\n  prefix : ArrayView[T],\n) -> Bool {\n  if prefix.length() > self.length() {\n    return false\n  }\n  for i in 0..<prefix.length() {\n    if self.unsafe_get(i) != prefix.unsafe_get(i) {\n      break false\n    }\n  } else {\n    true\n  }\n}\n\n///|\n/// Checks if the array view ends with the given suffix.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let view = [1, 2, 3, 4, 5][:]\n///   inspect(view.ends_with([4, 5][:]), content=\"true\")\n///   inspect(view.ends_with([3, 4][:]), content=\"false\")\n/// }\n/// ```\npub fn[T : Eq] ArrayView::ends_with(\n  self : ArrayView[T],\n  suffix : ArrayView[T],\n) -> Bool {\n  let suffix_len = suffix.length()\n  let self_len = self.length()\n  if suffix_len > self_len {\n    return false\n  }\n  for i in 0..<suffix_len {\n    if self.unsafe_get(self_len - suffix_len + i) != suffix.unsafe_get(i) {\n      break false\n    }\n  } else {\n    true\n  }\n}\n\n///|\n/// Performs a binary search on a sorted array view.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let view = [1, 3, 5, 7, 9][:]\n///   inspect(view.binary_search(5), content=\"Ok(2)\")\n///   inspect(view.binary_search(6), content=\"Err(3)\")\n/// }\n/// ```\npub fn[T : Compare] ArrayView::binary_search(\n  self : ArrayView[T],\n  value : T,\n) -> Result[Int, Int] {\n  let len = self.length()\n  for i = 0, j = len; i < j; {\n    let h = i + (j - i) / 2\n    if self.unsafe_get(h) < value {\n      continue h + 1, j\n    } else {\n      continue i, h\n    }\n  } else {\n    if i < len && self.unsafe_get(i) == value {\n      Ok(i)\n    } else {\n      Err(i)\n    }\n  }\n}\n\n///|\n/// Performs a binary search using a custom comparison function.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let view = [1, 3, 5, 7, 9][:]\n///   let result = view.binary_search_by(x => x.compare(5))\n///   inspect(result, content=\"Ok(2)\")\n/// }\n/// ```\n#locals(cmp)\npub fn[T] ArrayView::binary_search_by(\n  self : ArrayView[T],\n  cmp : (T) -> Int raise?,\n) -> Result[Int, Int] raise? {\n  let len = self.length()\n  for i = 0, j = len; i < j; {\n    let h = i + (j - i) / 2\n    if cmp(self.unsafe_get(h)) < 0 {\n      continue h + 1, j\n    } else {\n      continue i, h\n    }\n  } else {\n    if i < len && cmp(self.unsafe_get(i)) == 0 {\n      Ok(i)\n    } else {\n      Err(i)\n    }\n  }\n}\n\n///|\n/// Fold out values from an ArrayView according to certain rules.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let sum = [1, 2, 3, 4, 5][:].fold(init=0, (sum, elem) => sum + elem)\n///   inspect(sum, content=\"15\")\n/// }\n/// ```\npub fn[A, B] ArrayView::fold(\n  self : ArrayView[A],\n  init~ : B,\n  f : (B, A) -> B raise?,\n) -> B raise? {\n  for i = 0, acc = init; i < self.length(); {\n    continue i + 1, f(acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an ArrayView according to certain rules in reversed turn.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let sum = [1, 2, 3, 4, 5][:].rev_fold(init=0, (sum, elem) => sum + elem)\n///   inspect(sum, content=\"15\")\n/// }\n/// ```\npub fn[A, B] ArrayView::rev_fold(\n  self : ArrayView[A],\n  init~ : B,\n  f : (B, A) -> B raise?,\n) -> B raise? {\n  for i = self.length() - 1, acc = init; i >= 0; {\n    continue i - 1, f(acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an ArrayView according to certain rules with index.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let sum = [1, 2, 3, 4, 5][:].foldi(init=0, (index, sum, _elem) => sum + index)\n///   inspect(sum, content=\"10\")\n/// }\n/// ```\npub fn[A, B] ArrayView::foldi(\n  self : ArrayView[A],\n  init~ : B,\n  f : (Int, B, A) -> B raise?,\n) -> B raise? {\n  for i = 0, acc = init; i < self.length(); {\n    continue i + 1, f(i, acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an ArrayView according to certain rules in reversed turn with index.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let sum = [1, 2, 3, 4, 5][:].rev_foldi(init=0, (index, sum, _elem) => sum +\n///     index)\n///   inspect(sum, content=\"10\")\n/// }\n/// ```\npub fn[A, B] ArrayView::rev_foldi(\n  self : ArrayView[A],\n  init~ : B,\n  f : (Int, B, A) -> B raise?,\n) -> B raise? {\n  let len = self.length()\n  for i = len - 1, acc = init; i >= 0; {\n    continue i - 1, f(len - i - 1, acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Maps a function over the elements of the array view.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let v2 = v[1:].map(x => x + 1)\n///   assert_eq(v2, [5, 6])\n/// }\n/// ```\npub fn[T, U] ArrayView::map(\n  self : ArrayView[T],\n  f : (T) -> U raise?,\n) -> Array[U] raise? {\n  if self.length() == 0 {\n    return []\n  }\n  Array::makei(self.length(), i => f(self[i]))\n}\n\n///|\n/// Maps a function over the elements of the array view with index.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let v2 = v[1:].mapi((i, x) => x + i)\n///   assert_eq(v2, [4, 6])\n/// }\n/// ```\npub fn[T, U] ArrayView::mapi(\n  self : ArrayView[T],\n  f : (Int, T) -> U raise?,\n) -> Array[U] raise? {\n  if self.length() == 0 {\n    return []\n  }\n  Array::makei(self.length(), i => f(i, self[i]))\n}\n\n///|\n/// Filters the array view with a predicate function.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5, 6]\n///   let v = arr[2:].filter(x => x % 2 == 0)\n///   assert_eq(v, [4, 6])\n/// }\n/// ```\npub fn[T] ArrayView::filter(\n  self : ArrayView[T],\n  f : (T) -> Bool raise?,\n) -> Array[T] raise? {\n  let arr = []\n  for v in self {\n    if f(v) {\n      arr.push(v)\n    }\n  }\n  arr\n}\n\n///|\n/// Copy the view elements to a new array\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let view = [1, 2, 3, 4, 5, 6][2:4]\n///   let arr = view.to_array()\n///   assert_eq(arr, [3, 4])\n/// }\n/// ```\npub fn[T] ArrayView::to_array(self : ArrayView[T]) -> Array[T] {\n  let len = self.length()\n  if len == 0 {\n    []\n  } else {\n    let arr = Array::make(len, self[0])\n    for i, v in self {\n      arr[i] = v\n    }\n    arr\n  }\n}\n\n///|\n/// Concatenate strings within an array into a single complete string.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a : Array[String] = [\"1\", \"2\", \"3\"]\n///   let array_view = a[:]\n///   inspect(array_view.join(\",\"), content=\"1,2,3\")\n/// }\n/// ```\npub fn[A : ToStringView] ArrayView::join(\n  self : ArrayView[A],\n  separator : StringView,\n) -> String {\n  match self {\n    [] => \"\"\n    [hd, .. tl] => {\n      let hd = hd.to_string_view()\n      let mut size_hint = hd.length()\n      for s in tl {\n        size_hint += s.to_string_view().length() + separator.length()\n      }\n      size_hint = size_hint << 1\n      let buf = StringBuilder::new(size_hint~)\n      // buf.write_string(hd)\n      buf.write_view(hd)\n      if separator is \"\" {\n        for s in tl {\n          // buf.write_string(s)\n          let s = s.to_string_view()\n          buf.write_view(s)\n        }\n      } else {\n        for s in tl {\n          let s = s.to_string_view()\n          buf.write_view(separator)\n          // buf.write_string(s)\n          buf.write_view(s)\n        }\n      }\n      buf.to_string()\n    }\n  }\n}\n\n///|\n/// Performs a lexicographical comparison of two array views.\n///\n/// This method compares the array views element by element until a difference\n/// is found or one view is exhausted. Unlike the `Compare` trait implementation\n/// which uses shortlex order (shorter views come first), this method compares\n/// based purely on element values until a difference is found.\n///\n/// # Returns\n///\n/// - A negative integer if `self` is lexicographically less than `other`\n/// - Zero if `self` is lexicographically equal to `other`\n/// - A positive integer if `self` is lexicographically greater than `other`\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   inspect([1, 2][:].lexical_compare([1, 2, 3][:]), content=\"-1\")\n///   inspect([1, 2, 3][:].lexical_compare([1, 2][:]), content=\"1\")\n///   inspect([1, 2, 3][:].lexical_compare([1, 2, 3][:]), content=\"0\")\n///   inspect([1, 2, 3][:].lexical_compare([1, 2, 4][:]), content=\"-1\")\n/// }\n/// ```\npub fn[T : Compare] ArrayView::lexical_compare(\n  self : ArrayView[T],\n  other : ArrayView[T],\n) -> Int {\n  let self_len = self.length()\n  let other_len = other.length()\n  let min_len = if self_len < other_len { self_len } else { other_len }\n  for i in 0..<min_len {\n    let cmp = self.unsafe_get(i).compare(other.unsafe_get(i))\n    if cmp != 0 {\n      return cmp\n    }\n  }\n  self_len.compare(other_len)\n}\n\n// #endregion\n\n// #region trait impls\n\n///|\npub impl[X : Show] Show for ArrayView[X] with output(self, logger) {\n  logger.write_iter(self.iter())\n}\n\n///|\npub impl[T : Eq] Eq for ArrayView[T] with equal(self, other) -> Bool {\n  if self.length() != other.length() {\n    return false\n  }\n  for i in 0..<self.length() {\n    if !(self[i] == other[i]) {\n      return false\n    }\n  } else {\n    true\n  }\n}\n\n///|\npub impl[T : Compare] Compare for ArrayView[T] with compare(self, other) -> Int {\n  let len_self = self.length()\n  let len_other = other.length()\n  let cmp = len_self.compare(len_other)\n  guard cmp == 0 else { return cmp }\n  for i in 0..<len_self {\n    let cmp = self[i].compare(other[i])\n    guard cmp == 0 else { break cmp }\n  } else {\n    0\n  }\n}\n\n///|\npub impl[A : Hash] Hash for ArrayView[A] with hash_combine(self, hasher) {\n  for e in self {\n    hasher.combine(e)\n  }\n}\n\n// #endregion\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Creates a new dynamic array from a fixed-size array.\n///\n/// Parameters:\n///\n/// * `arr` : The fixed-size array to convert. The elements of this array will be\n/// copied to the new array.\n///\n/// Returns a new dynamic array containing all elements from the input fixed-size\n/// array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let fixed = FixedArray::make(3, 42)\n///   let dynamic = Array::from_fixed_array(fixed)\n///   inspect(dynamic, content=\"[42, 42, 42]\")\n/// }\n/// ```\npub fn[T] Array::from_fixed_array(arr : FixedArray[T]) -> Array[T] {\n  let len = arr.length()\n  let arr2 = Array::make_uninit(len)\n  UninitializedArray::unsafe_blit_fixed(arr2.buffer(), 0, arr, 0, len)\n  arr2\n}\n\n///|\n/// Creates a new array with a specified length and initializes all elements with\n/// the given value.\n///\n/// Parameters:\n///\n/// * `length` : The length of the array to create. Must be a non-negative\n/// integer.\n/// * `initial_value` : The value used to initialize all elements in the array.\n///\n/// Returns a new array of type `Array[T]` with `length` elements, where each\n/// element is initialized to `initial_value`.\n///\n/// Throws an error if `length` is negative.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = Array::make(3, 42)\n///   inspect(arr, content=\"[42, 42, 42]\")\n/// }\n/// ```\n///\n/// WARNING: A common pitfall is creating with the same initial value, for example:\n/// ```mbt check\n/// test {\n///   let two_dimension_array = Array::make(10, Array::make(10, 0))\n///   two_dimension_array[0][5] = 10\n///   assert_eq(two_dimension_array[5][5], 10)\n/// }\n/// ```\n/// This is because all the cells reference to the same object (the Array[Int] in this case).\n/// One should use makei() instead which creates an object for each index.\npub fn[T] Array::make(len : Int, elem : T) -> Array[T] {\n  let arr = Array::make_uninit(len)\n  for i in 0..<len {\n    arr.unsafe_set(i, elem)\n  }\n  arr\n}\n\n///|\n/// Creates a new array of the specified length, where each element is\n/// initialized using an index-based initialization function.\n///\n/// Parameters:\n///\n/// * `length` : The length of the new array. If `length` is less than or equal\n/// to 0, returns an empty array.\n/// * `initializer` : A function that takes an index (starting from 0) and\n/// returns a value of type `T`. This function is called for each index to\n/// initialize the corresponding element.\n///\n/// Returns a new array of type `Array[T]` with the specified length, where each\n/// element is initialized using the provided function.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = Array::makei(3, i => i * 2)\n///   inspect(arr, content=\"[0, 2, 4]\")\n/// }\n/// ```\n#locals(f)\npub fn[T] Array::makei(length : Int, f : (Int) -> T raise?) -> Array[T] raise? {\n  if length <= 0 {\n    []\n  } else {\n    let array = Array::make_uninit(length)\n    for i in 0..<length {\n      array.unsafe_set(i, f(i))\n    }\n    array\n  }\n}\n\n///|\n/// Returns the total capacity of the array, which is the number of elements that\n/// the array can hold without requiring reallocation of its internal buffer.\n///\n/// Parameters:\n///\n/// * `array` : The array whose capacity is to be determined.\n///\n/// Returns the current capacity of the array as an integer.\n///\n/// NOTE: The capacity of an array may not be consistent across different backends\n/// and/or different versions of the MoonBit compiler/core.\npub fn[T] Array::capacity(self : Array[T]) -> Int {\n  self.buffer().0.length()\n}\n\n///|\n/// Retrieves the element at the specified index from an array without bounds\n/// checking.\n///\n/// Parameters:\n///\n/// * `array` : The array from which to retrieve the element.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns the element at the specified index.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   inspect(arr.unsafe_get(1), content=\"2\")\n/// }\n/// ```\n///\n#intrinsic(\"%array.unsafe_get\")\npub fn[T] Array::unsafe_get(self : Array[T], idx : Int) -> T {\n  self.buffer()[idx]\n}\n\n///|\n/// Retrieves an element from the array at the specified index.\n///\n/// Parameters:\n///\n/// * `array` : The array to get the element from.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns the element at the specified index.\n///\n/// Throws a panic if the index is negative or greater than or equal to the\n/// length of the array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   inspect(arr[1], content=\"2\")\n/// }\n/// ```\n///\n#intrinsic(\"%array.get\")\n#alias(\"_[_]\")\npub fn[T] Array::at(self : Array[T], index : Int) -> T {\n  let len = self.length()\n  guard index >= 0 && index < len\n  self.buffer()[index]\n}\n\n///|\n/// Retrieves the element at the specified index from the array.\n///\n/// Parameters:\n///\n/// * `self` : The array to get the element from.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns `Some(element)` if the index is within bounds, or `None` if the index\n/// is out of bounds.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   inspect(arr.get(-1), content=\"None\")\n///   inspect(arr.get(0), content=\"Some(1)\")\n///   inspect(arr.get(3), content=\"None\")\n/// }\n/// ```\npub fn[T] Array::get(self : Array[T], index : Int) -> T? {\n  let len = self.length()\n  guard index >= 0 && index < len else { None }\n  Some(self.unsafe_get(index))\n}\n\n///|\n#intrinsic(\"%array.unsafe_set\")\npub fn[T] Array::unsafe_set(self : Array[T], idx : Int, val : T) -> Unit {\n  self.buffer()[idx] = val\n}\n\n///|\n/// Sets the element at the specified index in the array to a new value. The\n/// original value at that index is overwritten.\n///\n/// Parameters:\n///\n/// * `array` : The array to modify.\n/// * `index` : The position in the array where the value will be set.\n/// * `value` : The new value to assign at the specified index.\n///\n/// Throws an error if `index` is negative or greater than or equal to the length\n/// of the array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   arr[1] = 42\n///   inspect(arr, content=\"[1, 42, 3]\")\n/// }\n/// ```\n///\n#intrinsic(\"%array.set\")\n#alias(\"_[_]=_\")\npub fn[T] Array::set(self : Array[T], index : Int, value : T) -> Unit {\n  let len = self.length()\n  guard index >= 0 && index < len\n  self.buffer()[index] = value\n}\n\n///|\n/// Compares two arrays for equality. Returns true if both arrays have the same\n/// length and contain equal elements in the same order.\n///\n/// Parameters:\n///\n/// * `self` : The first array to compare.\n/// * `other` : The second array to compare.\n///\n/// Returns true if the arrays are equal, false otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr1 = [1, 2, 3]\n///   let arr2 = [1, 2, 3]\n///   let arr3 = [1, 2, 4]\n///   inspect(arr1 == arr2, content=\"true\")\n///   inspect(arr1 == arr3, content=\"false\")\n/// }\n/// ```\npub impl[T : Eq] Eq for Array[T] with equal(self, other) {\n  let self_len = self.length()\n  let other_len = other.length()\n  guard self_len == other_len else { return false }\n  for i in 0..<self_len {\n    guard self.unsafe_get(i) == other.unsafe_get(i) else { break false }\n  } else {\n    true\n  }\n}\n\n///|\npub impl[T : Hash] Hash for Array[T] with hash_combine(self, hasher) {\n  for v in self {\n    v.hash_combine(hasher)\n  }\n}\n\n///|\n/// Compares two arrays based on shortlex order.\n///\n/// First compares the lengths of the arrays. If they differ, returns -1 if the\n/// first array is shorter, 1 if it's longer. If the lengths are equal, compares\n/// elements pairwise until a difference is found or all elements have been\n/// compared.\n///\n/// Parameters:\n///\n/// * `self` : The first array to compare.\n/// * `other` : The second array to compare.\n///\n/// Returns an integer that indicates the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr1 = [1, 2, 3]\n///   let arr2 = [1, 2, 4]\n///   let arr3 = [1, 2]\n///   inspect(arr1.compare(arr2), content=\"-1\") // arr1 < arr2\n///   inspect(arr2.compare(arr1), content=\"1\") // arr2 > arr1\n///   inspect(arr1.compare(arr3), content=\"1\") // arr1 > arr3 (longer)\n///   inspect(arr1.compare(arr1), content=\"0\") // arr1 = arr1\n/// }\n/// ```\npub impl[T : Compare] Compare for Array[T] with compare(self, other) {\n  let len_self = self.length()\n  let len_other = other.length()\n  let cmp = len_self.compare(len_other)\n  guard cmp is 0 else { return cmp }\n  for i in 0..<len_self {\n    let cmp = self.unsafe_get(i).compare(other.unsafe_get(i))\n    guard cmp is 0 else { break cmp }\n  } else {\n    0\n  }\n}\n\n///|\n/// Concatenates two arrays into a new array. The resulting array contains all\n/// elements from the first array followed by all elements from the second array.\n///\n/// Parameters:\n///\n/// * `self` : The first array to concatenate.\n/// * `other` : The second array to concatenate.\n///\n/// Returns a new array containing all elements from both arrays in order.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = [1, 2, 3]\n///   let b = [4, 5]\n///   inspect(a + b, content=\"[1, 2, 3, 4, 5]\")\n/// }\n/// ```\npub impl[T] Add for Array[T] with add(self, other) {\n  let result = Array::make_uninit(self.length() + other.length())\n  UninitializedArray::unsafe_blit(\n    result.buffer(),\n    0,\n    self.buffer(),\n    0,\n    self.length(),\n  )\n  UninitializedArray::unsafe_blit(\n    result.buffer(),\n    self.length(),\n    other.buffer(),\n    0,\n    other.length(),\n  )\n  result\n}\n\n///|\n/// Appends all elements from one array to the end of another array. The elements\n/// are added in-place, modifying the original array.\n///\n/// Parameters:\n///\n/// * `self` : The array to append to.\n/// * `other` : The array whose elements will be appended.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let v1 = [1, 2, 3]\n///   let v2 = [4, 5, 6]\n///   v1.append(v2)\n///   inspect(v1, content=\"[1, 2, 3, 4, 5, 6]\")\n///   let v1 = [1, 2, 3]\n///   let v2 : Array[Int] = []\n///   v1.append(v2)\n///   inspect(v1, content=\"[1, 2, 3]\")\n/// }\n/// ```\npub fn[T] Array::append(self : Array[T], other : ArrayView[T]) -> Unit {\n  other.blit_to(self, dst_offset=self.length())\n}\n\n///|\n/// Iterates through each element of the array in order, applying the given\n/// function to each element.\n///\n/// Parameters:\n///\n/// * `array` : The array to iterate over.\n/// * `function` : A function that takes a single element of type `T` as input\n/// and returns `Unit`. This function is applied to each element of the array in\n/// order.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   let mut sum = 0\n///   arr.each(x => sum = sum + x)\n///   inspect(sum, content=\"6\")\n/// }\n/// ```\n#locals(f)\npub fn[T] Array::each(self : Array[T], f : (T) -> Unit raise?) -> Unit raise? {\n  for v in self {\n    f(v)\n  }\n}\n\n///|\n/// Iterates over the elements of the array in reverse order, applying the given\n/// function to each element.\n///\n/// Parameters:\n///\n/// * `array` : The array to iterate over.\n/// * `f` : A function that takes an element of type `T` and returns `Unit`. This\n/// function is applied to each element of the array in reverse order.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let mut sum = 0\n///   v.rev_each(x => sum = sum - x)\n///   @json.json_inspect(sum, content=-12)\n/// }\n/// ```\n#locals(f)\npub fn[T] Array::rev_each(self : Array[T], f : (T) -> Unit) -> Unit {\n  let len = self.length()\n  for i in 0..<len {\n    f(self[len - i - 1])\n  }\n}\n\n///|\n/// Iterates over the elements of the array with index in reversed order.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let mut sum = 0\n///   v.rev_eachi((i, x) => sum = sum + x + i)\n///   assert_eq(sum, 15)\n/// }\n/// ```\n#locals(f)\npub fn[T] Array::rev_eachi(\n  self : Array[T],\n  f : (Int, T) -> Unit raise?,\n) -> Unit raise? {\n  let len = self.length()\n  for i in 0..<len {\n    f(i, self[len - i - 1])\n  }\n}\n\n///|\n/// Iterates over the elements of the array with index.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let mut sum = 0\n///   v.eachi((i, x) => sum = sum + x + i)\n///   inspect(sum, content=\"15\")\n/// }\n/// ```\n#locals(f)\npub fn[T] Array::eachi(\n  self : Array[T],\n  f : (Int, T) -> Unit raise?,\n) -> Unit raise? {\n  for i, v in self {\n    f(i, v)\n  }\n}\n\n///|\n/// Checks whether all elements satisfy the predicate.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   assert_true(arr.all(x => x < 6))\n///   assert_false(arr.all(x => x < 5))\n/// }\n/// ```\n#alias(every)\npub fn[T] Array::all(self : Array[T], f : (T) -> Bool raise?) -> Bool raise? {\n  self[:].all(f)\n}\n\n///|\n/// Checks whether any element satisfies the predicate.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   assert_true(arr.any(x => x < 6))\n///   assert_false(arr.any(x => x < 1))\n/// }\n/// ```\n#alias(exists)\npub fn[T] Array::any(self : Array[T], f : (T) -> Bool raise?) -> Bool raise? {\n  self[:].any(f)\n}\n\n///|\n/// Clears the array, removing all values.\n///\n/// This method has no effect on the allocated capacity of the array, only setting the length to 0.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   v.clear()\n///   assert_eq(v.length(), 0)\n/// }\n/// ```\npub fn[T] Array::clear(self : Array[T]) -> Unit {\n  self.unsafe_truncate_to_length(0)\n}\n\n///|\n/// Maps a function over the elements of the array.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let v2 = v.map(x => x + 1)\n///   assert_eq(v2, [4, 5, 6])\n/// }\n/// ```\n#locals(f)\npub fn[T, U] Array::map(\n  self : Array[T],\n  f : (T) -> U raise?,\n) -> Array[U] raise? {\n  let arr = Array::make_uninit(self.length())\n  for i, v in self {\n    arr.unsafe_set(i, f(v))\n  }\n  arr\n}\n\n///|\n/// Maps a function over the elements of the array in place.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   v.map_in_place(x => x + 1)\n///   assert_eq(v, [4, 5, 6])\n/// }\n/// ```\n#locals(f)\n#alias(map_inplace, deprecated)\npub fn[T] Array::map_in_place(\n  self : Array[T],\n  f : (T) -> T raise?,\n) -> Unit raise? {\n  for i, v in self {\n    self[i] = f(v)\n  }\n}\n\n///|\n/// Maps a function over the elements of the array with index.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let v2 = v.mapi((i, x) => x + i)\n///   assert_eq(v2, [3, 5, 7])\n/// }\n/// ```\n#locals(f)\npub fn[T, U] Array::mapi(\n  self : Array[T],\n  f : (Int, T) -> U raise?,\n) -> Array[U] raise? {\n  if self.length() == 0 {\n    return []\n  }\n  let arr = Array::make_uninit(self.length())\n  for i, v in self {\n    arr.unsafe_set(i, f(i, v))\n  }\n  arr\n}\n\n///|\n/// Maps a function over the elements of the array with index in place.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   v.mapi_in_place((i, x) => x + i)\n///   assert_eq(v, [3, 5, 7])\n/// }\n/// ```\n#locals(f)\n#alias(mapi_inplace, deprecated)\npub fn[T] Array::mapi_in_place(\n  self : Array[T],\n  f : (Int, T) -> T raise?,\n) -> Unit raise? {\n  for i, v in self {\n    self[i] = f(i, v)\n  }\n}\n\n///|\n/// Creates a new array containing all elements from the input array that satisfy\n/// the given predicate function.\n///\n/// Parameters:\n///\n/// * `array` : The array to filter.\n/// * `predicate` : A function that takes an element and returns a boolean\n/// indicating whether the element should be included in the result.\n///\n/// Returns a new array containing only the elements for which the predicate\n/// function returns `true`. The relative order of the elements is preserved.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let evens = arr.filter(x => x % 2 == 0)\n///   inspect(evens, content=\"[2, 4]\")\n/// }\n/// ```\n#locals(f)\npub fn[T] Array::filter(\n  self : Array[T],\n  f : (T) -> Bool raise?,\n) -> Array[T] raise? {\n  let arr = []\n  for v in self {\n    if f(v) {\n      arr.push(v)\n    }\n  }\n  arr\n}\n\n///|\n/// Tests whether the array contains no elements.\n///\n/// Parameters:\n///\n/// * `array` : The array to check.\n///\n/// Returns `true` if the array has no elements, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let empty : Array[Int] = []\n///   inspect(empty.is_empty(), content=\"true\")\n///   let non_empty = [1, 2, 3]\n///   inspect(non_empty.is_empty(), content=\"false\")\n/// }\n/// ```\npub fn[T] Array::is_empty(self : Array[T]) -> Bool {\n  self.length() == 0\n}\n\n///|\n/// Reverses the order of elements in an array in place, modifying the original\n/// array.\n///\n/// Parameters:\n///\n/// * `self` : The array to be reversed.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.rev_in_place()\n///   inspect(arr, content=\"[5, 4, 3, 2, 1]\")\n///   let arr : Array[Int] = []\n///   arr.rev_in_place()\n///   inspect(arr, content=\"[]\")\n/// }\n/// ```\n#alias(rev_inplace, deprecated)\npub fn[T] Array::rev_in_place(self : Array[T]) -> Unit {\n  let len = self.length()\n  for i in 0..<(len / 2) {\n    let temp = self.unsafe_get(i)\n    self.unsafe_set(i, self.unsafe_get(len - i - 1))\n    self.unsafe_set(len - i - 1, temp)\n  }\n}\n\n///|\n/// Creates a new array with elements in reversed order.\n///\n/// Parameters:\n///\n/// * `self` : The array to be reversed.\n///\n/// Returns a new array containing the same elements as the input array but in\n/// reverse order. The original array remains unchanged.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.rev(), content=\"[5, 4, 3, 2, 1]\")\n///   inspect(arr, content=\"[1, 2, 3, 4, 5]\") // original array unchanged\n/// }\n/// ```\npub fn[T] Array::rev(self : Array[T]) -> Array[T] {\n  let len = self.length()\n  let arr = Array::make_uninit(len)\n  for i in 0..<len {\n    arr.unsafe_set(i, self.unsafe_get(len - i - 1))\n  }\n  arr\n}\n\n///|\n/// Split the array into two at the given index.\n/// This function will panic if the index is out of bounds.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let (v1, v2) = (v[:1], v[1:])\n///   assert_eq(v1, [3])\n///   assert_eq(v2, [4, 5])\n/// }\n/// ```\n#deprecated(\"Use ArrayView instead, e.g, (a[:index], a[index:])\")\n#doc(hidden)\npub fn[T] Array::split_at(self : Array[T], index : Int) -> (Array[T], Array[T]) {\n  if index < 0 || index > self.length() {\n    let len = self.length()\n    abort(\n      \"index out of bounds: the len is from 0 to \\{len} but the index is \\{index}\",\n    )\n  }\n  let v1 = Array::make_uninit(index)\n  let v2 = Array::make_uninit(self.length() - index)\n  UninitializedArray::unsafe_blit(v1.buffer(), 0, self.buffer(), 0, index)\n  if index != self.length() {\n    UninitializedArray::unsafe_blit(\n      v2.buffer(),\n      0,\n      self.buffer(),\n      index,\n      self.length() - index,\n    )\n  }\n  (v1, v2)\n}\n\n///|\n/// Checks whether the array contains an element equal to the given value.\n///\n/// Parameters:\n///\n/// * `array` : The array to search in.\n/// * `value` : The value to search for.\n///\n/// Returns `true` if the array contains an element equal to the given value,\n/// `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.contains(3), content=\"true\")\n///   inspect(arr.contains(6), content=\"false\")\n///   let arr : Array[Int] = []\n///   inspect(arr.contains(1), content=\"false\")\n/// }\n/// ```\npub fn[T : Eq] Array::contains(self : Array[T], value : T) -> Bool {\n  for v in self {\n    if v == value {\n      break true\n    }\n  } else {\n    false\n  }\n}\n\n///|\n/// Checks if the array begins with all elements of the provided prefix array in\n/// order.\n///\n/// Parameters:\n///\n/// * `self` : The array to check against.\n/// * `prefix` : The array containing the sequence of elements to look for at the\n/// beginning.\n///\n/// Returns `true` if the array starts with all elements in `prefix` in the same\n/// order, `false` otherwise. An empty prefix array always returns `true`, and a\n/// prefix longer than the array always returns `false`.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.starts_with([1, 2]), content=\"true\")\n///   inspect(arr.starts_with([2, 3]), content=\"false\")\n///   inspect(arr.starts_with([]), content=\"true\")\n///   inspect(arr.starts_with([1, 2, 3, 4, 5, 6]), content=\"false\")\n/// }\n/// ```\npub fn[T : Eq] Array::starts_with(self : Array[T], prefix : Array[T]) -> Bool {\n  self[:].starts_with(prefix[:])\n}\n\n///|\n/// Tests if an array ends with the given suffix.\n///\n/// Parameters:\n///\n/// * `self` : The array to check.\n/// * `suffix` : The array to test against.\n///\n/// Returns `true` if the array ends with the given suffix, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.ends_with([4, 5]), content=\"true\")\n///   inspect(arr.ends_with([3, 4]), content=\"false\")\n///   inspect(arr.ends_with([]), content=\"true\")\n///   let arr : Array[Int] = []\n///   inspect(arr.ends_with([]), content=\"true\")\n///   inspect(arr.ends_with([1]), content=\"false\")\n/// }\n/// ```\npub fn[T : Eq] Array::ends_with(self : Array[T], suffix : Array[T]) -> Bool {\n  self[:].ends_with(suffix[:])\n}\n\n///|\n/// Removes a prefix from an array if it exists.\n///\n/// Parameters:\n///\n/// * `array` : The array to remove the prefix from.\n/// * `prefix` : The array to be removed from the beginning of `array`.\n///\n/// Returns `Some(array)` containing the remaining elements after removing the\n/// prefix if the array starts with the prefix, or `None` if the array doesn't\n/// start with the prefix.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.strip_prefix([1, 2]), content=\"Some([3, 4, 5])\")\n///   inspect(arr.strip_prefix([2, 3]), content=\"None\")\n/// }\n/// ```\npub fn[T : Eq] Array::strip_prefix(\n  self : Array[T],\n  prefix : Array[T],\n) -> Array[T]? {\n  if self.starts_with(prefix) {\n    let v = Array::make_uninit(self.length() - prefix.length())\n    UninitializedArray::unsafe_blit(\n      v.buffer(),\n      0,\n      self.buffer(),\n      prefix.length(),\n      self.length() - prefix.length(),\n    )\n    Some(v)\n  } else {\n    None\n  }\n}\n\n///|\n/// Strip a suffix from the array.\n///\n/// If the array ends with the suffix, return the array before the suffix, otherwise return None.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let v2 = v.strip_suffix([5])\n///   assert_eq(v2, Some([3, 4]))\n/// }\n/// ```\npub fn[T : Eq] Array::strip_suffix(\n  self : Array[T],\n  suffix : Array[T],\n) -> Array[T]? {\n  if self.ends_with(suffix) {\n    let v = Array::make_uninit(self.length() - suffix.length())\n    let len = self.length() - suffix.length()\n    UninitializedArray::unsafe_blit(v.buffer(), 0, self.buffer(), 0, len)\n    Some(v)\n  } else {\n    None\n  }\n}\n\n///|\n/// Searches for the first occurrence of a value in the array and returns its\n/// index.\n///\n/// Parameters:\n///\n/// * `self` : The array to search in.\n/// * `value` : The value to search for.\n///\n/// Returns an `Option` containing the index of the first occurrence of `value`\n/// if found, or `None` if the value is not present in the array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 2, 4]\n///   inspect(arr.search(2), content=\"Some(1)\") // first occurrence\n///   inspect(arr.search(5), content=\"None\") // not found\n/// }\n/// ```\npub fn[T : Eq] Array::search(self : Array[T], value : T) -> Int? {\n  self[:].search(value)\n}\n\n///|\n/// Search the index of the first element that satisfies the predicate.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let v = [1, 2, 3, 4, 5]\n///   match v.search_by(x => x == 3) {\n///     Some(index) => assert_eq(index, 2) // 2\n///     None => println(\"Not found\")\n///   }\n/// }\n/// ```\n#locals(f)\n#alias(find_index, deprecated)\npub fn[T] Array::search_by(self : Array[T], f : (T) -> Bool) -> Int? {\n  for i, v in self {\n    if f(v) {\n      break Some(i)\n    }\n  } else {\n    None\n  }\n}\n\n///|\n/// Performs a binary search on a sorted array to find the index of a given element.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let result = v.binary_search(3)\n///   assert_eq(result, Ok(0)) // The element 3 is found at index 0\n/// }\n/// ```\n///\n/// # Arguments\n/// - `self`: The array in which to perform the search.\n/// - `value`: The element to search for in the array.\n///\n/// # Returns\n/// - `Result[Int, Int]`:\n/// If the element is found, an `Ok` variant is returned, containing the index of the matching element in the array.\n/// If there are multiple matches, the leftmost match will be returned.\n/// If the element is not found, an `Err` variant is returned, containing the index where the element could be inserted to maintain the sorted order.\n///\n/// # Notes\n/// - Ensure that the array is sorted in increasing order before calling this function.\n/// - If the array is not sorted, the returned result is undefined and should not be relied on.\npub fn[T : Compare] Array::binary_search(\n  self : Array[T],\n  value : T,\n) -> Result[Int, Int] {\n  self[:].binary_search(value)\n}\n\n///|\n/// Performs a binary search on a sorted array using a custom comparison\n/// function. Returns the position of the matching element if found, or the\n/// position where the element could be inserted while maintaining the sorted\n/// order.\n///\n/// Parameters:\n///\n/// * `array` : The sorted array to search in.\n/// * `comparator` : A function that compares each element with the target value,\n/// returning:\n///  * A negative integer if the element is less than the target\n///  * Zero if the element equals the target\n///  * A positive integer if the element is greater than the target\n///\n/// Returns a `Result` containing either:\n///\n/// * `Ok(index)` if a matching element is found at position `index`\n/// * `Err(index)` if no match is found, where `index` is the position where the\n/// element could be inserted\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 3, 5, 7, 9]\n///   let find_3 = arr.binary_search_by(x => x.compare(3))\n///   inspect(find_3, content=\"Ok(1)\")\n///   let find_4 = arr.binary_search_by(x => x.compare(4))\n///   inspect(find_4, content=\"Err(2)\")\n/// }\n/// ```\n///\n/// Notes:\n///\n/// * Assumes the array is sorted according to the ordering implied by the\n/// comparison function\n/// * For multiple matches, returns the leftmost matching position\n/// * Returns an insertion point that maintains the sort order when no match is\n/// found\npub fn[T] Array::binary_search_by(\n  self : Array[T],\n  cmp : (T) -> Int raise?,\n) -> Result[Int, Int] raise? {\n  self[:].binary_search_by(cmp)\n}\n\n///|\n/// Swaps the values at two positions in the array.\n///\n/// Parameters:\n///\n/// * `array` : The array in which to swap elements.\n/// * `index1` : The index of the first element to be swapped.\n/// * `index2` : The index of the second element to be swapped.\n///\n/// This function will panic if either index is negative or greater than or equal to\n/// the length of the array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   arr.swap(0, 2)\n///   inspect(arr, content=\"[3, 2, 1]\")\n/// }\n/// ```\npub fn[T] Array::swap(self : Array[T], i : Int, j : Int) -> Unit {\n  if i >= self.length() || j >= self.length() || i < 0 || j < 0 {\n    let len = self.length()\n    abort(\n      \"index out of bounds: the len is from 0 to \\{len} but the index is (\\{i}, \\{j})\",\n    )\n  }\n  let temp = self.unsafe_get(i)\n  self.unsafe_set(i, self.unsafe_get(j))\n  self.unsafe_set(j, temp)\n}\n\n///|\n/// Removes all elements from the array that do not satisfy the predicate\n/// function, modifying the array in place. The order of remaining elements is\n/// preserved.\n///\n/// Parameters:\n///\n/// * `array` : The array to be filtered.\n/// * `predicate` : A function that takes an element and returns `true` if the\n/// element should be kept, `false` if it should be removed.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.retain(x => x % 2 == 0)\n///   inspect(arr, content=\"[2, 4]\")\n///   let arr = [1, 2, 3]\n///   arr.retain(x => x > 10)\n///   inspect(arr, content=\"[]\")\n///   let arr = [1, 2, 3]\n///   arr.retain(_ => true)\n///   inspect(arr, content=\"[1, 2, 3]\")\n/// }\n/// ```\n/// TODO: perf could be improved\n#locals(f)\npub fn[T] Array::retain(self : Array[T], f : (T) -> Bool raise?) -> Unit raise? {\n  let len = self.length()\n  for i = 0, j = 0; i < len; {\n    let item = self.unsafe_get(i)\n    if f(item) {\n      self.unsafe_set(j, item)\n      continue i + 1, j + 1\n    }\n    continue i + 1, j\n  } else {\n    // we use `else` here to capture `j`\n    self.unsafe_truncate_to_length(j)\n  }\n}\n\n///|\n/// Resizes an array to a specified length, either by truncating if the new\n/// length is smaller, or by appending copies of a default value if the new\n/// length is larger.\n///\n/// Parameters:\n///\n/// * `array` : The array to be resized.\n/// * `new_length` : The desired length of the array after resizing.\n/// * `default_value` : The value to append when extending the array.\n///\n/// Throws a panic if `new_length` is negative.\n///\n/// Examples:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.resize(3, 0)\n///   inspect(arr, content=\"[1, 2, 3]\")\n///   let arr = [1, 2, 3]\n///   arr.resize(5, 0)\n///   inspect(arr, content=\"[1, 2, 3, 0, 0]\")\n/// }\n/// ```\n///\npub fn[T] Array::resize(self : Array[T], new_len : Int, f : T) -> Unit {\n  if new_len < 0 {\n    abort(\"negative new length\")\n  }\n  if new_len < self.length() {\n    self.unsafe_truncate_to_length(new_len)\n  } else {\n    let len = self.length()\n    for _ in len..<new_len {\n      self.push(f)\n    }\n  }\n}\n\n///|\n/// Flattens an array of arrays into an array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let v = [[3, 4], [5, 6]].flatten()\n///   assert_eq(v, [3, 4, 5, 6])\n/// }\n/// ```\npub fn[T] Array::flatten(self : Array[Array[T]]) -> Array[T] {\n  let mut len = 0\n  for x in self {\n    len += x.length()\n  }\n  let res = Array::make_uninit(len)\n  let mut i = 0\n  for xs in self {\n    res.unsafe_blit(i, xs, 0, xs.length())\n    i += xs.length()\n  }\n  res\n}\n\n///|\n/// Create an array by repeat a given array for a given times.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let v = [3, 4].repeat(2)\n///   assert_eq(v, [3, 4, 3, 4])\n/// }\n/// ```\npub fn[T] Array::repeat(self : Array[T], times : Int) -> Array[T] {\n  let v = Array::new(capacity=self.length() * times)\n  for i in 0..<times {\n    v.append(self)\n  }\n  v\n}\n\n///|\n/// Fold out values from an array according to certain rules.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let sum = [1, 2, 3, 4, 5].fold(init=0, (sum, elem) => sum + elem)\n///   assert_eq(sum, 15)\n/// }\n/// ```\n#locals(f)\n#alias(fold_left, deprecated)\npub fn[A, B] Array::fold(\n  self : Array[A],\n  init~ : B,\n  f : (B, A) -> B raise?,\n) -> B raise? {\n  for i = 0, acc = init; i < self.length(); {\n    continue i + 1, f(acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an array according to certain rules in reversed turn.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let sum = [1, 2, 3, 4, 5].rev_fold(init=0, (sum, elem) => sum + elem)\n///   assert_eq(sum, 15)\n/// }\n/// ```\n#locals(f)\n#alias(fold_right, deprecated)\npub fn[A, B] Array::rev_fold(\n  self : Array[A],\n  init~ : B,\n  f : (B, A) -> B raise?,\n) -> B raise? {\n  for i = self.length() - 1, acc = init; i >= 0; {\n    continue i - 1, f(acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an array according to certain rules with index.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let sum = [1, 2, 3, 4, 5].foldi(init=0, (index, sum, _elem) => sum + index)\n///   assert_eq(sum, 10)\n/// }\n/// ```\n#locals(f)\n#alias(fold_lefti, deprecated)\npub fn[A, B] Array::foldi(\n  self : Array[A],\n  init~ : B,\n  f : (Int, B, A) -> B raise?,\n) -> B raise? {\n  for i = 0, acc = init; i < self.length(); {\n    continue i + 1, f(i, acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an array according to certain rules in reversed turn with index.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let sum = [1, 2, 3, 4, 5].rev_foldi(init=0, (index, sum, _elem) => sum + index)\n///   assert_eq(sum, 10)\n/// }\n/// ```\n#locals(f)\n#alias(fold_righti, deprecated)\npub fn[A, B] Array::rev_foldi(\n  self : Array[A],\n  init~ : B,\n  f : (Int, B, A) -> B raise?,\n) -> B raise? {\n  let len = self.length()\n  for i = len - 1, acc = init; i >= 0; {\n    continue i - 1, f(len - i - 1, acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Removes consecutive duplicate elements from an array in-place, using equality\n/// comparison. The first occurrence of each element is retained while subsequent\n/// equal elements are removed.\n///\n/// Parameters:\n///\n/// * `array` : The array to remove duplicates from. Must contain elements that\n/// implement the `Eq` trait for equality comparison.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 2, 3, 3, 3, 2]\n///   arr.dedup()\n///   inspect(arr, content=\"[1, 2, 3, 2]\")\n///   let arr = [1, 2, 2, 2, 3, 3]\n///   arr.dedup()\n///   inspect(arr, content=\"[1, 2, 3]\")\n///   let arr : Array[Int] = []\n///   arr.dedup()\n///   inspect(arr, content=\"[]\")\n/// }\n/// ```\n///\n/// Note: For best results when removing all duplicates regardless of position,\n/// sort the array before calling this function. When used on an unsorted array,\n/// this function only removes consecutive duplicates.\npub fn[T : Eq] Array::dedup(self : Array[T]) -> Unit {\n  if self.is_empty() {\n    return\n  }\n  let mut w = 1\n  for i in 1..<self.length() {\n    if self[i] != self[w - 1] {\n      self[w] = self[i]\n      w = w + 1\n    }\n  }\n  self.unsafe_truncate_to_length(w)\n}\n\n///|\n/// Extracts elements from an array that satisfy a given predicate function. The\n/// extracted elements are removed from the original array and returned as a new\n/// array. The relative order of the extracted elements is preserved.\n///\n/// Parameters:\n///\n/// * `array` : The array to extract elements from.\n/// * `predicate` : A function that takes an element and returns `true` if the\n/// element should be extracted, `false` otherwise.\n///\n/// Returns a new array containing all elements that satisfy the predicate\n/// function, in the order they appeared in the original array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let extracted = arr.extract_if(x => x % 2 == 0)\n///   inspect(extracted, content=\"[2, 4]\")\n///   inspect(arr, content=\"[1, 3, 5]\")\n/// }\n/// ```\n#locals(f)\npub fn[T] Array::extract_if(self : Array[T], f : (T) -> Bool) -> Array[T] {\n  let removed = []\n  let mut write = 0\n  for read in 0..<self.length() {\n    let elem = self[read]\n    if f(elem) {\n      removed.push(elem)\n    } else {\n      if read != write {\n        self[write] = elem\n      }\n      write += 1\n    }\n  }\n  self.truncate(write)\n  removed\n}\n\n///|\n/// Divides an array into smaller arrays (chunks) of the specified size.\n///\n/// Parameters:\n///\n/// * `array` : The array to be divided into chunks.\n/// * `size` : The size of each chunk. Must be a positive integer, otherwise it will panic.\n///\n///\n/// Returns an array of arrays, where each inner array is a chunk containing\n/// elements from the original array. If the length of the original array is not\n/// divisible by the chunk size, the last chunk will contain fewer elements.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let chunks = arr.chunks(2)\n///   inspect(chunks, content=\"[[1, 2], [3, 4], [5]]\")\n///   let arr : Array[Int] = []\n///   inspect(arr.chunks(3), content=\"[]\")\n/// }\n/// ```\npub fn[T] Array::chunks(self : Array[T], size : Int) -> Array[ArrayView[T]] {\n  guard size > 0\n  let len = self.length()\n  if len == 0 {\n    return []\n  }\n  let num_chunks = (len + size - 1) / size\n  Array::makei(num_chunks, i => {\n    let start = i * size\n    let end = Int::min(start + size, len)\n    self[start:end]\n  })\n}\n\n///|\n/// Groups consecutive elements of the array into chunks where adjacent elements\n/// satisfy the given predicate function.\n///\n/// Parameters:\n///\n/// * `array` : The array to be chunked.\n/// * `predicate` : A function that takes two adjacent elements and returns\n/// `true` if they should be in the same chunk, `false` otherwise.\n///\n/// Returns an array of arrays, where each inner array is a chunk of consecutive\n/// elements that satisfy the predicate with their adjacent elements.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let v = [1, 1, 2, 3, 2, 3, 2, 3, 4]\n///   let chunks = v.chunk_by((x, y) => x <= y)\n///   inspect(chunks, content=\"[[1, 1, 2, 3], [2, 3], [2, 3, 4]]\")\n///   let v : Array[Int] = []\n///   inspect(v.chunk_by((x, y) => x <= y), content=\"[]\")\n/// }\n/// ```\n#locals(pred)\npub fn[T] Array::chunk_by(\n  self : Array[T],\n  pred : (T, T) -> Bool raise?,\n) -> Array[ArrayView[T]] raise? {\n  let chunks = []\n  if self.is_empty() {\n    return chunks\n  }\n  let mut start = 0\n  for i in 1..<self.length() {\n    if !pred(self[i - 1], self[i]) {\n      chunks.push(self[start:i])\n      start = i\n    }\n  }\n  chunks.push(self[start:self.length()])\n  chunks\n}\n\n///|\n/// Generates overlapping subslices (sliding windows) of the specified size.\n///\n/// Parameters:\n///\n/// * `array` : The array to be processed with sliding windows.\n/// * `size` : The window length. Must be a positive integer, otherwise it will panic.\n///\n/// Returns an array of slices, where each inner slice is a contiguous subslice\n/// of the original array. Windows are produced with a step size of 1. If the\n/// original array's length is less than the specified window size, the result\n/// will be an empty array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let windows = arr.windows(2)\n///   inspect(windows, content=\"[[1, 2], [2, 3], [3, 4], [4, 5]]\")\n///   let arr = [1, 2]\n///   inspect(arr.windows(3), content=\"[]\")\n/// }\n/// ```\npub fn[T] Array::windows(self : Array[T], size : Int) -> Array[ArrayView[T]] {\n  guard size > 0\n  let len = self.length() - size + 1\n  if len < 1 {\n    return []\n  }\n  Array::makei(len, i => self[i:i + size])\n}\n\n///|\npub fn[T] Array::suffixes(\n  self : Array[T],\n  include_empty? : Bool = false,\n) -> Iter[ArrayView[T]] {\n  self[:].suffixes(include_empty~)\n}\n\n///|\n/// Splits an array into chunks using a predicate function. Creates chunks by\n/// grouping consecutive elements that do not satisfy the predicate function.\n/// Elements that satisfy the predicate function are excluded from the resulting\n/// chunks and act as delimiters.\n///\n/// Parameters:\n///\n/// * `array` : The array to be split into chunks.\n/// * `predicate` : A function that takes an element and returns `true` if the\n/// element should be used as a delimiter.\n///\n/// Returns an array of arrays, where each inner array is a chunk of consecutive\n/// elements that do not satisfy the predicate.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 0, 2, 0, 3, 0, 4]\n///   inspect(arr.split(x => x == 0), content=\"[[1], [2], [3], [4]]\")\n///   let arr = [0, 1, 0, 0, 2, 0]\n///   inspect(arr.split(x => x == 0), content=\"[[], [1], [], [2]]\")\n/// }\n/// ```\n#locals(pred)\npub fn[T] Array::split(\n  self : Array[T],\n  pred : (T) -> Bool raise?,\n) -> Array[Array[T]] raise? {\n  let chunks = []\n  let mut i = 0\n  while i < self.length() {\n    let chunk = []\n    while i < self.length() && !pred(self[i]) {\n      chunk.push(self[i])\n      i = i + 1\n    }\n    chunks.push(chunk)\n    i = i + 1\n  }\n  chunks\n}\n\n///|\n/// Creates an iterator over the elements of the array.\n///\n/// Parameters:\n///\n/// * `array` : The array to create an iterator from.\n///\n/// Returns an iterator that yields each element of the array in order.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   let mut sum = 0\n///   arr.iter().each(x => sum = sum + x)\n///   inspect(sum, content=\"6\")\n/// }\n/// ```\n#alias(iterator, deprecated)\npub fn[T] Array::iter(self : Array[T]) -> Iter[T] {\n  self[:].iter()\n}\n\n///|\n/// Returns an iterator that yields elements from the array in reverse order,\n/// from the last element to the first.\n///\n/// Parameters:\n///\n/// * `array` : The array to iterate over in reverse order.\n///\n/// Returns an iterator that yields each element of the array, starting from the\n/// last element and moving towards the first.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   let result = []\n///   arr.rev_iter().each(x => result.push(x))\n///   inspect(result, content=\"[3, 2, 1]\")\n/// }\n/// ```\n#alias(rev_iterator, deprecated)\npub fn[T] Array::rev_iter(self : Array[T]) -> Iter[T] {\n  self[:].rev_iter()\n}\n\n///|\n/// Returns an iterator that provides both indices and values of the array in\n/// order.\n///\n/// Parameters:\n///\n/// * `self` : The array to iterate over.\n///\n/// Returns an iterator that yields tuples of index and value pairs, where\n/// indices start from 0.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [10, 20, 30]\n///   let mut sum = 0\n///   arr.iter2().each((i, x) => sum = sum + i + x)\n///   inspect(sum, content=\"63\") // (0 + 10) + (1 + 20) + (2 + 30) = 63\n/// }\n/// ```\n#alias(iterator2, deprecated)\npub fn[A] Array::iter2(self : Array[A]) -> Iter2[Int, A] {\n  self[:].iter2()\n}\n\n///|\n/// Creates a new empty array.\n///\n/// Returns an empty array of type `Array[T]`.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr : Array[Int] = Array::default()\n///   inspect(arr.length(), content=\"0\")\n///   inspect(arr.is_empty(), content=\"true\")\n/// }\n/// ```\npub impl[T] Default for Array[T] with default() {\n  []\n}\n\n///|\n/// Removes a back element from an array.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let array = [1, 2, 3, 4, 5]\n///   array.unsafe_pop_back()\n///   assert_eq(array.last(), Some(4))\n/// }\n/// ```\n#internal(unsafe, \"Panic if the array is empty on non-JS backend.\")\n#doc(hidden)\npub fn[A] Array::unsafe_pop_back(self : Array[A]) -> Unit {\n  self.unsafe_pop() |> ignore\n}\n\n///|\n/// Truncates the array in-place to the specified length.\n///\n/// If `len` is greater than or equal to the current array length,\n/// the function does nothing. If `len` is 0, the array is cleared.\n/// Otherwise, removes elements from the end until the array reaches the given length.\n///\n/// Parameters:\n///\n/// * `self` : The target array (modified in-place).\n/// * `len` : The new desired length (must be non-negative).\n///\n/// Important:\n///   - If `len` is negative, the function does nothing.\n///   - If `len` exceeds current length, the array remains unchanged.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.truncate(3)\n///   inspect(arr, content=\"[1, 2, 3]\")\n/// }\n/// ```\npub fn[A] Array::truncate(self : Array[A], len : Int) -> Unit {\n  guard len >= 0 && len < self.length() else { return }\n  self.unsafe_truncate_to_length(len)\n}\n\n///|\n/// In-place filter and map for Array\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.retain_map(fn(x) { if x % 2 == 0 { Some(x * 2) } else { None } })\n///   inspect(arr, content=\"[4, 8]\")\n/// }\n/// ```\npub fn[A] Array::retain_map(self : Array[A], f : (A) -> A?) -> Unit {\n  if self.is_empty() {\n    return\n  }\n  let buf = self.buffer()\n  let len = self.length()\n  let mut write_idx = 0\n  for read_idx in 0..<len {\n    let val = buf[read_idx]\n    match f(val) {\n      Some(new_val) => {\n        buf[write_idx] = new_val\n        write_idx += 1\n      }\n      None => ()\n    }\n  }\n  self.unsafe_truncate_to_length(write_idx)\n}\n\n///|\n/// Creates a new array containing all elements from an iterator.\n///\n/// Parameters:\n///\n/// * `iterator` : An iterator containing elements of type `T`.\n///\n/// Returns a new array containing all elements from the iterator in the same\n/// order.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let iter = Iter::singleton(42)\n///   let arr = Array::from_iter(iter)\n///   inspect(arr, content=\"[42]\")\n/// }\n/// ```\n#alias(from_iterator, deprecated)\npub fn[T] Array::from_iter(iter : Iter[T]) -> Array[T] {\n  iter.collect()\n}\n\n///|\n/// Adds all elements from an iterator to the end of the array.\n///\n/// This function iterates over each element in the provided iterator\n/// and adds them to the array using the `push` method.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let u = [1, 2, 3]\n///   let v = [4, 5, 6]\n///   u.push_iter(v.iter())\n///   assert_eq(u, [1, 2, 3, 4, 5, 6])\n/// }\n/// ```\npub fn[T] Array::push_iter(self : Self[T], iter : Iter[T]) -> Unit {\n  // This function used by [Array spread operator](https://docs.moonbitlang.com/en/latest/language/fundamentals.html#spread-operator)\n  // it can't be removed and deprecated\n  for x in iter {\n    self.push(x)\n  }\n}\n\n///|\n/// Shuffle the array using Knuth shuffle\n///\n/// To use this function, you need to provide a rand function, which takes an integer as it upper bound\n/// and returns an integer.\n/// *rand n* is expected to returns a uniformly distribution integer between 0 and n - 1\n/// # Example\n///\n/// ```mbt check\n/// test {\n/// let arr = [1, 2, 3, 4, 5]\n/// fn rand(upper : Int) -> Int {\n///   let rng = @random.Rand::new()\n///   rng.int(limit=upper)\n/// }\n///\n/// Array::shuffle_in_place(arr, rand~)\n/// }\n/// ```\npub fn[T] Array::shuffle_in_place(\n  self : Array[T],\n  rand~ : (Int) -> Int,\n) -> Unit {\n  let n = self.length()\n  for i = n - 1; i > 0; i = i - 1 {\n    let j = rand(i + 1) % (i + 1)\n    // for safety, perf is not a concern here\n    // TODO: maybe return an error later\n    self.swap(i, j)\n  }\n}\n\n///|\n/// Shuffle the array using Knuth shuffle\n///\n/// To use this function, you need to provide a rand function, which takes an integer as it upper bound\n/// and returns an integer.\n/// *rand n* is expected to returns a uniformly distribution integer between 0 and n - 1\n/// # Example\n///\n/// ```mbt nocheck\n/// let arr = [1, 2, 3, 4, 5]\n///\n/// fn rand(upper : Int) -> Int {\n///   let rng = @random.Rand::new()\n///   rng.int(limit=upper)\n/// }\n///\n/// let _shuffled = Array::shuffle(arr, rand~)\n/// ```\npub fn[T] Array::shuffle(self : Array[T], rand~ : (Int) -> Int) -> Array[T] {\n  let new_arr = self.copy()\n  Array::shuffle_in_place(new_arr, rand~)\n  new_arr\n}\n\n///|\n/// Returns a new array containing the elements of the original array that satisfy the given predicate.\n///\n/// # Arguments\n///\n/// * `self` - The array to filter.\n/// * `f` - The predicate function.\n///\n/// # Returns\n///\npub fn[A, B] Array::filter_map(\n  self : Array[A],\n  f : (A) -> B? raise?,\n) -> Array[B] raise? {\n  let result = []\n  for x in self {\n    if f(x) is Some(x) {\n      result.push(x)\n    }\n  }\n  result\n}\n\n///|\n/// Returns the last element of the array, or `None` if the array is empty.\n///\n/// Parameters:\n///\n/// * `array` : The array to get the last element from.\n///\n/// Returns an optional value containing the last element of the array. The\n/// result is `None` if the array is empty, or `Some(x)` where `x` is the last\n/// element of the array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   inspect(arr.last(), content=\"Some(3)\")\n///   let empty : Array[Int] = []\n///   inspect(empty.last(), content=\"None\")\n/// }\n/// ```\npub fn[A] Array::last(self : Array[A]) -> A? {\n  match self {\n    [] => None\n    [.., last] => Some(last)\n  }\n}\n\n///|\n/// Zips two arrays into a single array of tuples.\n///\n/// Parameters:\n///\n/// * `self` : The first array.\n/// * `other` : The second array.\n///\n/// Returns an array of tuples, where each tuple contains corresponding elements\n/// from the two input arrays.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr1 = [1, 2, 3]\n///   let arr2 = ['a', 'b', 'c']\n///   inspect(arr1.zip(arr2), content=\"[(1, 'a'), (2, 'b'), (3, 'c')]\")\n/// }\n/// ```\npub fn[A, B] Array::zip(self : Array[A], other : Array[B]) -> Array[(A, B)] {\n  let length = if self.length() < other.length() {\n    self.length()\n  } else {\n    other.length()\n  }\n  Array::makei(length, i => (self[i], other[i]))\n}\n\n///|\n/// Splits an array of pairs into two arrays, separating the first and second elements.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr = [(1, \"a\"), (2, \"b\"), (3, \"c\")]\n///   let (nums, strs) = arr.unzip()\n///   inspect(nums, content=\"[1, 2, 3]\")\n///   inspect(strs, content=\"[\\\"a\\\", \\\"b\\\", \\\"c\\\"]\")\n/// }\n/// ```\npub fn[T1, T2] Array::unzip(self : Array[(T1, T2)]) -> (Array[T1], Array[T2]) {\n  let arr1 : Array[T1] = Array::new(capacity=self.length())\n  let arr2 : Array[T2] = Array::new(capacity=self.length())\n  for pair in self {\n    let (x, y) = pair\n    arr1.push(x)\n    arr2.push(y)\n  }\n  (arr1, arr2)\n}\n\n///|\n/// Zips two arrays into an iterator that yields corresponding elements.\n///\n/// Parameters:\n///\n/// * `self` : The first array.\n/// * `other` : The second array.\n///\n/// Returns an `Iter2` iterator that produces corresponding elements\n/// from both arrays. The iteration continues until the shorter array is exhausted.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr1 = [1, 2, 3]\n///   let arr2 = ['a', 'b', 'c']\n///   inspect(\n///     arr1.zip_to_iter2(arr2).to_array(),\n///     content=\"[(1, 'a'), (2, 'b'), (3, 'c')]\",\n///   )\n/// }\n/// ```\npub fn[A, B] Array::zip_to_iter2(\n  self : Array[A],\n  other : Array[B],\n) -> Iter2[A, B] {\n  let length = if self.length() < other.length() {\n    self.length()\n  } else {\n    other.length()\n  }\n  let mut i = 0\n  Iter2::new(() => {\n    guard i < length else { None }\n    let elem = (self[i], other[i])\n    i += 1\n    Some(elem)\n  }).iter2()\n}\n\n///|\n/// Join an array of strings using the provided `separator`.\n///\n/// Parameters:\n///   * `separator` : The string inserted between each element.\n///\n/// Returns a single concatenated `String`.\n/// # Example:\n/// ```mbt check\n/// test {\n///   let s = \"hello world\"\n///   inspect(s.split(\" \").to_array().join(\":\"), content=\"hello:world\")\n/// }\n/// ```\npub fn[A : ToStringView] Array::join(\n  self : Array[A],\n  separator : StringView,\n) -> String {\n  self[:].join(separator)\n}\n\n///|\n/// Performs a lexicographical comparison of two arrays.\n///\n/// This method compares the arrays element by element until a difference is\n/// found or one array is exhausted. Unlike the `Compare` trait implementation\n/// which uses shortlex order (shorter arrays come first), this method compares\n/// based purely on element values until a difference is found.\n///\n/// # Returns\n///\n/// - A negative integer if `self` is lexicographically less than `other`\n/// - Zero if `self` is lexicographically equal to `other`\n/// - A positive integer if `self` is lexicographically greater than `other`\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   inspect([1, 2].lexical_compare([1, 2, 3]), content=\"-1\")\n///   inspect([1, 2, 3].lexical_compare([1, 2]), content=\"1\")\n///   inspect([1, 2, 3].lexical_compare([1, 2, 3]), content=\"0\")\n///   inspect([1, 2, 3].lexical_compare([1, 2, 4]), content=\"-1\")\n/// }\n/// ```\npub fn[T : Compare] Array::lexical_compare(\n  self : Array[T],\n  other : Array[T],\n) -> Int {\n  self[:].lexical_compare(other[:])\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\npub impl[X : Eq] Eq for X? with equal(self, other) {\n  match (self, other) {\n    (None, None) => true\n    (Some(x), Some(y)) => x == y\n    _ => false\n  }\n}\n\n///|\npub fn[X : Show] Option::to_string(self : X?) -> String {\n  match self {\n    None => \"None\"\n    Some(x) => \"Some(\" + x.to_string() + \")\"\n  }\n}\n\n///|\n/// Extract the value in `Some`.\n/// \n/// If the value is `None`, it throws a panic.\npub fn[X] Option::unwrap(self : X?) -> X {\n  match self {\n    None => panic()\n    Some(x) => x\n  }\n}\n\n///|\n/// Return the contained `Some` value or the provided default.\n#alias(or, deprecated)\npub fn[T] Option::unwrap_or(self : T?, default : T) -> T {\n  match self {\n    None => default\n    Some(t) => t\n  }\n}\n\n///|\n/// Return the contained `Some` value or the provided default.\n///\n/// Default is lazily evaluated\n#alias(or_else, deprecated)\npub fn[T] Option::unwrap_or_else(\n  self : T?,\n  default : () -> T raise?,\n) -> T raise? {\n  match self {\n    None => default()\n    Some(t) => t\n  }\n}\n\n///|\n/// Return the contained `Some` value or the result of the `T::default()`.\n#alias(or_default, deprecated)\npub fn[T : Default] Option::unwrap_or_default(self : T?) -> T {\n  match self {\n    None => T::default()\n    Some(t) => t\n  }\n}\n\n///|\npub impl[X : Compare] Compare for X? with compare(self, other) {\n  match (self, other) {\n    (Some(x), Some(y)) => x.compare(y)\n    (Some(_), None) => 1\n    (None, Some(_)) => -1\n    (None, None) => 0\n  }\n}\n\n///|\n#alias(or_error, deprecated)\npub fn[T, Err : Error] Option::unwrap_or_error(\n  self : T?,\n  err : Err,\n) -> T raise Err {\n  match self {\n    Some(v) => v\n    None => raise err\n  }\n}\n\n///|\n/// `None`\npub impl[X] Default for X? with default() {\n  None\n}\n\n///|\n#alias(iterator, deprecated)\npub fn[T] Option::iter(self : T?) -> Iter[T] {\n  match self {\n    Some(v) => Iter::singleton(v)\n    None => Iter::empty()\n  }\n}\n\n///|\n/// Maps the value of an `Option` using a provided function.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let a = Some(5)\n///   assert_eq(a.map(x => x * 2), Some(10))\n///   let b = None\n///   assert_eq(b.map(x => x * 2), None)\n/// }\n/// ```\npub fn[T, U] Option::map(self : T?, f : (T) -> U raise?) -> U? raise? {\n  match self {\n    Some(t) => Some(f(t))\n    None => None\n  }\n}\n\n///|\n/// Returns the provided default result (if none), or applies a function to the contained value (if any).\n/// Arguments passed to map_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use `map_or_else`, which is lazily evaluated.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let a = Some(5)\n///   assert_eq(a.map_or(3, x => x * 2), 10)\n/// }\n/// ```\npub fn[T, U] Option::map_or(\n  self : T?,\n  default : U,\n  f : (T) -> U raise?,\n) -> U raise? {\n  match self {\n    None => default\n    Some(x) => f(x)\n  }\n}\n\n///|\n/// Computes a default function result (if none), or applies a different function to the contained value (if any).\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let a = Some(5)\n///   assert_eq(a.map_or_else(() => 3, x => x * 2), 10)\n/// }\n/// ```\npub fn[T, U] Option::map_or_else(\n  self : T?,\n  default : () -> U raise?,\n  f : (T) -> U raise?,\n) -> U raise? {\n  match self {\n    None => default()\n    Some(x) => f(x)\n  }\n}\n\n///|\n/// Binds an option to a function that returns another option.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let a = Option::Some(5)\n///   let r1 = a.bind(x => Some(x * 2))\n///   assert_eq(r1, Some(10))\n///   let b : Int? = None\n///   let r2 = b.bind(x => Some(x * 2))\n///   assert_eq(r2, None)\n/// }\n/// ```\npub fn[T, U] Option::bind(self : T?, f : (T) -> U? raise?) -> U? raise? {\n  match self {\n    Some(t) => f(t)\n    None => None\n  }\n}\n\n///|\n#deprecated(\"use `option.bind(x => x)` instead\")\npub fn[T] Option::flatten(self : T??) -> T? {\n  match self {\n    Some(inner) => inner\n    None => None\n  }\n}\n\n///|\n/// Checks if the option is empty.\n#deprecated(\"use `x is None` instead\")\npub fn[T] Option::is_empty(self : T?) -> Bool {\n  self is None\n}\n\n///|\n/// Filters the option by applying the given predicate function `f`.\n///\n/// If the predicate function `f` returns `true` for the value contained in the option,\n/// the same option is returned. Otherwise, `None` is returned.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let x = Some(3)\n///   assert_eq(x.filter(x => x > 5), None)\n///   assert_eq(x.filter(x => x < 5), Some(3))\n/// }\n/// ```\npub fn[T] Option::filter(self : T?, f : (T) -> Bool raise?) -> T? raise? {\n  match self {\n    Some(t) => if f(t) { self } else { None }\n    None => None\n  }\n}\n\n///|\n/// Checks if the option contains a value.\n#deprecated(\"use `x is Some(_)` instead\")\npub fn[T] Option::is_some(self : T?) -> Bool {\n  self is Some(_)\n}\n\n///|\n/// Checks if the option is None.\n#deprecated(\"use `x is None` instead\")\npub fn[T] Option::is_none(self : T?) -> Bool {\n  self is None\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Types\n\n///|\npriv struct Entry[K, V] {\n  mut prev : Int\n  mut next : Entry[K, V]?\n  mut psl : Int\n  hash : Int\n  key : K\n  mut value : V\n} derive(Show)\n\n///|\n/// Mutable linked hash map that maintains the order of insertion, not thread safe.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let map = { 3: \"three\", 8: \"eight\", 1: \"one\" }\n///   assert_eq(map.get(2), None)\n///   assert_eq(map.get(3), Some(\"three\"))\n///   map.set(3, \"updated\")\n///   assert_eq(map.get(3), Some(\"updated\"))\n/// }\n/// ```\nstruct Map[K, V] {\n  mut entries : FixedArray[Entry[K, V]?]\n  mut size : Int // active key-value pairs count\n  mut capacity : Int // current capacity\n  mut capacity_mask : Int // capacity_mask = capacity - 1, used to find idx\n  mut grow_at : Int // threshold that triggers grow\n  mut head : Entry[K, V]? // head of linked list\n  mut tail : Int // tail of linked list\n}\n\n// Implementations\n\n///|\n/// Create a hash map.\n/// The capacity of the map will be the smallest power of 2 that is\n/// greater than or equal to the provided [capacity].\npub fn[K, V] Map::new(capacity? : Int = 8) -> Map[K, V] {\n  let capacity = capacity.next_power_of_two()\n  {\n    size: 0,\n    capacity,\n    capacity_mask: capacity - 1,\n    grow_at: calc_grow_threshold(capacity),\n    entries: FixedArray::make(capacity, None),\n    head: None,\n    tail: -1,\n  }\n}\n\n///|\n/// Create a hash map from array.\npub fn[K : Hash + Eq, V] Map::from_array(arr : ArrayView[(K, V)]) -> Map[K, V] {\n  let length = arr.length()\n  let mut capacity = length.next_power_of_two()\n  if length > calc_grow_threshold(capacity) {\n    capacity *= 2\n  }\n  let m = Map::new(capacity~)\n  for e in arr {\n    m.set(e.0, e.1)\n  }\n  m\n}\n\n///|\n/// Sets a key-value pair into the hash map. If the key already exists, updates\n/// its value. If the hash map is near full capacity, automatically\n/// grows the internal storage to accommodate more entries.\n///\n/// Parameters:\n///\n/// * `map` : The hash map to modify.\n/// * `key` : The key to insert or update. Must implement `Hash` and `Eq` traits.\n/// * `value` : The value to associate with the key.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map : Map[String, Int] = Map::new()\n///   map.set(\"key\", 42)\n///   inspect(map.get(\"key\"), content=\"Some(42)\")\n///   map.set(\"key\", 24) // update existing key\n///   inspect(map.get(\"key\"), content=\"Some(24)\")\n/// }\n/// ```\n#alias(\"_[_]=_\")\npub fn[K : Hash + Eq, V] Map::set(self : Map[K, V], key : K, value : V) -> Unit {\n  self.set_with_hash(key, value, key.hash())\n}\n\n///|\nfn[K : Eq, V] Map::set_with_hash(\n  self : Map[K, V],\n  key : K,\n  value : V,\n  hash : Int,\n) -> Unit {\n  // Only grow when actually inserting a new entry, not when updating existing\n  for psl = 0, idx = hash & self.capacity_mask {\n    match self.entries[idx] {\n      None => {\n        // Need to insert new entry - check if grow is needed first\n        if self.size >= self.grow_at {\n          self.grow()\n          // Restart search with new capacity_mask\n          continue 0, hash & self.capacity_mask\n        }\n        let entry = { prev: self.tail, next: None, psl, key, value, hash }\n        self.add_entry_to_tail(idx, entry)\n        return\n      }\n      Some(curr_entry) => {\n        if curr_entry.hash == hash && curr_entry.key == key {\n          // Key exists - just update value, no grow needed\n          curr_entry.value = value\n          return\n        }\n        if psl > curr_entry.psl {\n          // Need to insert and push away - check if grow is needed first\n          if self.size >= self.grow_at {\n            self.grow()\n            // Restart search with new capacity_mask\n            continue 0, hash & self.capacity_mask\n          }\n          self.push_away(idx, curr_entry)\n          let entry = { prev: self.tail, next: None, psl, key, value, hash }\n          self.add_entry_to_tail(idx, entry)\n          return\n        }\n        continue psl + 1, (idx + 1) & self.capacity_mask\n      }\n    }\n  }\n}\n\n///|\nfn[K, V] Map::push_away(\n  self : Map[K, V],\n  idx : Int,\n  entry : Entry[K, V],\n) -> Unit {\n  for psl = entry.psl + 1, idx = (idx + 1) & self.capacity_mask, entry = entry {\n    match self.entries[idx] {\n      None => {\n        entry.psl = psl\n        self.set_entry(entry, idx)\n        break\n      }\n      Some(curr_entry) =>\n        if psl > curr_entry.psl {\n          entry.psl = psl\n          self.set_entry(entry, idx)\n          continue curr_entry.psl + 1,\n            (idx + 1) & self.capacity_mask,\n            curr_entry\n        } else {\n          continue psl + 1, (idx + 1) & self.capacity_mask, entry\n        }\n    }\n  }\n}\n\n///|\nfn[K, V] Map::set_entry(\n  self : Map[K, V],\n  entry : Entry[K, V],\n  new_idx : Int,\n) -> Unit {\n  self.entries[new_idx] = Some(entry)\n  match entry.next {\n    None => self.tail = new_idx\n    Some(next) => next.prev = new_idx\n  }\n}\n\n///|\n/// Retrieves the value associated with a given key in the hash map.\n///\n/// Parameters:\n///\n/// * `self` : The hash map to search in.\n/// * `key` : The key to look up in the map.\n///\n/// Returns `Some(value)` if the key exists in the map, `None` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map = { \"key\": 42 }\n///   inspect(map.get(\"key\"), content=\"Some(42)\")\n///   inspect(map.get(\"nonexistent\"), content=\"None\")\n/// }\n/// ```\npub fn[K : Hash + Eq, V] Map::get(self : Map[K, V], key : K) -> V? {\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break None }\n    if entry.hash == hash && entry.key == key {\n      break Some(entry.value)\n    }\n    if i > entry.psl {\n      break None\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\n#alias(\"_[_]\")\npub fn[K : Hash + Eq, V] Map::at(self : Map[K, V], key : K) -> V {\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry)\n    if entry.hash == hash && entry.key == key {\n      return entry.value\n    }\n    guard i <= entry.psl\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\n/// Returns the value associated with the key in the map, or computes and returns\n/// a default value if the key does not exist.\n///\n/// Parameters:\n///\n/// * `map` : The map to search in.\n/// * `key` : The key to look up in the map.\n/// * `default` : A function that returns a default value when the key is not\n/// found.\n///\n/// Returns either the value associated with the key if it exists, or the result\n/// of calling the default function.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map = { \"a\": 1, \"b\": 2 }\n///   inspect(map.get_or_default(\"a\", 0), content=\"1\")\n///   inspect(map.get_or_default(\"c\", 42), content=\"42\")\n/// }\n/// ```\npub fn[K : Hash + Eq, V] Map::get_or_default(\n  self : Map[K, V],\n  key : K,\n  default : V,\n) -> V {\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    match self.entries[idx] {\n      Some(entry) => {\n        if entry.hash == hash && entry.key == key {\n          break entry.value\n        }\n        if i > entry.psl {\n          break default\n        }\n        continue i + 1, (idx + 1) & self.capacity_mask\n      }\n      None => break default\n    }\n  }\n}\n\n///|\n/// Returns the value for the given key, or sets and returns a default value if the key does not exist.\npub fn[K : Hash + Eq, V] Map::get_or_init(\n  self : Map[K, V],\n  key : K,\n  default : () -> V,\n) -> V {\n  let hash = key.hash()\n  let (idx, psl, new_value, push_away) = for psl = 0, idx = hash &\n                                               self.capacity_mask {\n    match self.entries[idx] {\n      Some(entry) => {\n        if entry.hash == hash && entry.key == key {\n          return entry.value\n        }\n        if psl > entry.psl {\n          let new_value = default()\n          break (idx, psl, new_value, Some(entry))\n        }\n        continue psl + 1, (idx + 1) & self.capacity_mask\n      }\n      None => {\n        let new_value = default()\n        break (idx, psl, new_value, None)\n      }\n    }\n  }\n  if self.size >= self.grow_at {\n    // Slow path, we need to resize\n    self.grow()\n    self.set_with_hash(key, new_value, hash)\n  } else {\n    if push_away is Some(entry) {\n      self.push_away(idx, entry)\n    }\n    let entry = {\n      prev: self.tail,\n      next: None,\n      psl,\n      hash,\n      key,\n      value: new_value,\n    }\n    self.add_entry_to_tail(idx, entry)\n  }\n  new_value\n}\n\n///|\n/// Check if the hash map contains a key.\npub fn[K : Hash + Eq, V] Map::contains(self : Map[K, V], key : K) -> Bool {\n  // inline Map::get to avoid boxing\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break false }\n    if entry.hash == hash && entry.key == key {\n      break true\n    }\n    if i > entry.psl {\n      break false\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\n/// Checks if a map contains a specific key-value pair.\n///\n/// Parameters:\n///\n/// * `map` : A map of type `Map[K, V]` to search in.\n/// * `key` : The key to look up in the map.\n/// * `value` : The value to be compared with the value associated with the key.\n///\n/// Returns `true` if the map contains the specified key and its associated value\n/// equals the given value, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map = { \"a\": 1, \"b\": 2 }\n///   inspect(map.contains_kv(\"a\", 1), content=\"true\")\n///   inspect(map.contains_kv(\"a\", 2), content=\"false\")\n///   inspect(map.contains_kv(\"c\", 3), content=\"false\")\n/// }\n/// ```\npub fn[K : Hash + Eq, V : Eq] Map::contains_kv(\n  self : Map[K, V],\n  key : K,\n  value : V,\n) -> Bool {\n  // inline Map::get to avoid boxing\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break false }\n    if entry.hash == hash && entry.key == key && entry.value == value {\n      break true\n    }\n    if i > entry.psl {\n      break false\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\n/// Removes the entry for the specified key from the hash map. If the key exists\n/// in the map, removes its entry and adjusts the probe sequence length (PSL) of\n/// subsequent entries to maintain the Robin Hood hashing invariant. If the key\n/// does not exist, the map remains unchanged.\n///\n/// Parameters:\n///\n/// * `self` : The hash map to remove the entry from.\n/// * `key` : The key to remove from the map.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map = { \"a\": 1, \"b\": 2 }\n///   map.remove(\"a\")\n///   inspect(map.get(\"a\"), content=\"None\")\n///   inspect(map.length(), content=\"1\")\n/// }\n/// ```\npub fn[K : Hash + Eq, V] Map::remove(self : Map[K, V], key : K) -> Unit {\n  self.remove_with_hash(key, key.hash())\n}\n\n///|\nfn[K : Eq, V] Map::remove_with_hash(\n  self : Map[K, V],\n  key : K,\n  hash : Int,\n) -> Unit {\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break }\n    if entry.hash == hash && entry.key == key {\n      self.remove_entry(entry)\n      self.shift_back(idx)\n      self.size -= 1\n      break\n    }\n    if i > entry.psl {\n      break\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\nfn[K, V] Map::add_entry_to_tail(\n  self : Map[K, V],\n  idx : Int,\n  entry : Entry[K, V],\n) -> Unit {\n  match self.tail {\n    -1 => self.head = Some(entry)\n    tail => self.entries[tail].unwrap().next = Some(entry)\n  }\n  self.tail = idx\n  self.entries[idx] = Some(entry)\n  self.size += 1\n}\n\n///|\nfn[K, V] Map::remove_entry(self : Map[K, V], entry : Entry[K, V]) -> Unit {\n  match entry.prev {\n    -1 => self.head = entry.next\n    idx => self.entries[idx].unwrap().next = entry.next\n  }\n  match entry.next {\n    None => self.tail = entry.prev\n    Some(next) => next.prev = entry.prev\n  }\n}\n\n///|\nfn[K, V] Map::shift_back(self : Map[K, V], idx : Int) -> Unit {\n  let next = (idx + 1) & self.capacity_mask\n  match self.entries[next] {\n    None | Some({ psl: 0, .. }) => self.entries[idx] = None\n    Some(entry) => {\n      entry.psl -= 1\n      self.set_entry(entry, idx)\n      self.shift_back(next)\n    }\n  }\n}\n\n///|\nfn[K : Eq, V] Map::grow(self : Map[K, V]) -> Unit {\n  let old_head = self.head\n  let new_capacity = self.capacity << 1\n  self.entries = FixedArray::make(new_capacity, None)\n  self.capacity = new_capacity\n  self.capacity_mask = new_capacity - 1\n  self.grow_at = calc_grow_threshold(self.capacity)\n  self.size = 0\n  self.head = None\n  self.tail = -1\n  loop old_head {\n    Some({ next, key, value, hash, .. }) => {\n      self.set_with_hash(key, value, hash)\n      continue next\n    }\n    None => break\n  }\n}\n\n///|\nfn calc_grow_threshold(capacity : Int) -> Int {\n  capacity * 13 / 16\n}\n\n// Utils\n\n///|\npub impl[K : Show, V : Show] Show for Map[K, V] with output(self, logger) {\n  logger.write_string(\"{\")\n  loop (0, self.head) {\n    (_, None) => logger.write_string(\"}\")\n    (i, Some({ key, value, next, .. })) => {\n      if i > 0 {\n        logger.write_string(\", \")\n      }\n      logger.write_object(key)\n      logger.write_string(\": \")\n      logger.write_object(value)\n      continue (i + 1, next)\n    }\n  }\n}\n\n///|\n/// Get the number of key-value pairs in the map.\n#alias(size, deprecated)\npub fn[K, V] Map::length(self : Map[K, V]) -> Int {\n  self.size\n}\n\n///|\n/// Get the capacity of the map.\npub fn[K, V] Map::capacity(self : Map[K, V]) -> Int {\n  self.capacity\n}\n\n///|\n/// Check if the hash map is empty.\npub fn[K, V] Map::is_empty(self : Map[K, V]) -> Bool {\n  self.size == 0\n}\n\n///|\n/// Iterate over all key-value pairs of the map in the order of insertion.\n#locals(f)\npub fn[K, V] Map::each(\n  self : Map[K, V],\n  f : (K, V) -> Unit raise?,\n) -> Unit raise? {\n  loop self.head {\n    Some({ key, value, next, .. }) => {\n      f(key, value)\n      continue next\n    }\n    None => break\n  }\n}\n\n///|\n/// Iterate over all key-value pairs of the map in the order of insertion, with index.\n#locals(f)\npub fn[K, V] Map::eachi(\n  self : Map[K, V],\n  f : (Int, K, V) -> Unit raise?,\n) -> Unit raise? {\n  loop (0, self.head) {\n    (i, Some({ key, value, next, .. })) => {\n      f(i, key, value)\n      continue (i + 1, next)\n    }\n    (_, None) => break\n  }\n}\n\n///|\n/// Clears the map, removing all key-value pairs. Keeps the allocated space.\npub fn[K, V] Map::clear(self : Map[K, V]) -> Unit {\n  self.entries.fill(None)\n  self.size = 0\n  self.head = None\n  self.tail = -1\n}\n\n///|\n/// Returns the iterator of the hash map, provide elements in the order of insertion.\n#alias(iterator, deprecated)\npub fn[K, V] Map::iter(self : Map[K, V]) -> Iter[(K, V)] {\n  let mut curr_entry = self.head\n  Iter::new(fn() {\n    match curr_entry {\n      Some({ key, value, next, .. }) => {\n        curr_entry = next\n        Some((key, value))\n      }\n      None => None\n    }\n  })\n}\n\n///|\n#alias(iterator2, deprecated)\npub fn[K, V] Map::iter2(self : Map[K, V]) -> Iter2[K, V] {\n  self.iter()\n}\n\n///|\npub fn[K, V] Map::keys(self : Map[K, V]) -> Iter[K] {\n  let mut curr_entry = self.head\n  Iter::new(fn() {\n    match curr_entry {\n      Some({ key, next, .. }) => {\n        curr_entry = next\n        Some(key)\n      }\n      None => None\n    }\n  })\n}\n\n///|\npub fn[K, V] Map::values(self : Map[K, V]) -> Iter[V] {\n  let mut curr_entry = self.head\n  Iter::new(fn() {\n    match curr_entry {\n      Some({ value, next, .. }) => {\n        curr_entry = next\n        Some(value)\n      }\n      None => None\n    }\n  })\n}\n\n///|\n/// Converts the hash map to an array.\npub fn[K, V] Map::to_array(self : Map[K, V]) -> Array[(K, V)] {\n  let arr = Array::make_uninit(self.size)\n  let mut i = 0\n  loop self.head {\n    Some({ key, value, next, .. }) => {\n      arr.unsafe_set(i, (key, value))\n      i += 1\n      continue next\n    }\n    None => break\n  }\n  arr\n}\n\n///|\npub impl[K : Hash + Eq, V : Eq] Eq for Map[K, V] with equal(\n  self : Map[K, V],\n  that : Map[K, V],\n) -> Bool {\n  guard self.size == that.size else { return false }\n  for k, v in self {\n    guard that.contains_kv(k, v) else { return false }\n  } else {\n    true\n  }\n}\n\n///|\npub fn[K : Hash + Eq, V] Map::of(arr : FixedArray[(K, V)]) -> Map[K, V] {\n  let length = arr.length()\n  let mut capacity = length.next_power_of_two()\n  if length > calc_grow_threshold(capacity) {\n    capacity *= 2\n  }\n  let m = Map::new(capacity~)\n  // arr.iter((e) => { m.set(e.0, e.1) })\n  for i in 0..<length {\n    let e = arr[i]\n    m.set(e.0, e.1)\n  }\n  m\n}\n\n///|\n#alias(from_iterator, deprecated)\npub fn[K : Hash + Eq, V] Map::from_iter(iter : Iter[(K, V)]) -> Map[K, V] {\n  let m = {}\n  while iter.next() is Some((k, v)) {\n    m.set(k, v)\n  }\n  m\n}\n\n///|\npub impl[K, V] Default for Map[K, V] with default() {\n  Map::new()\n}\n\n///|\n/// Applies a function to each key-value pair in the map and returns a new map with the results, using the original keys.\npub fn[K, V, V2] Map::map(self : Map[K, V], f : (K, V) -> V2) -> Map[K, V2] {\n  // copy structure\n  let other = {\n    capacity: self.capacity,\n    entries: FixedArray::make(self.capacity, None),\n    size: self.size,\n    capacity_mask: self.capacity_mask,\n    grow_at: self.grow_at,\n    head: None,\n    tail: self.tail,\n  }\n  if self.size == 0 {\n    return other\n  }\n  guard self.entries[self.tail] is Some(last)\n  loop (last, self.tail, None) {\n    ({ prev, psl, hash, key, value, .. }, idx, next) => {\n      let new_value = f(key, value)\n      let new_entry = { prev, next, psl, hash, key, value: new_value }\n      other.entries[idx] = Some(new_entry)\n      if prev != -1 {\n        continue (self.entries[prev].unwrap(), prev, Some(new_entry))\n      } else {\n        other.head = Some(new_entry)\n      }\n    }\n  }\n  other\n}\n\n///|\n/// Copy the map, creating a new map with the same key-value pairs and order of insertion.\npub fn[K, V] Map::copy(self : Map[K, V]) -> Map[K, V] {\n  // copy structure\n  let other = {\n    capacity: self.capacity,\n    entries: FixedArray::make(self.capacity, None),\n    size: self.size,\n    capacity_mask: self.capacity_mask,\n    grow_at: self.grow_at,\n    head: None,\n    tail: self.tail,\n  }\n  if self.size == 0 {\n    return other\n  }\n  guard self.entries[self.tail] is Some(last)\n  loop (last, self.tail, None) {\n    ({ prev, psl, hash, key, value, .. }, idx, next) => {\n      let new_entry = { prev, next, psl, hash, key, value }\n      other.entries[idx] = Some(new_entry)\n      if prev != -1 {\n        continue (self.entries[prev].unwrap(), prev, Some(new_entry))\n      } else {\n        other.head = Some(new_entry)\n      }\n    }\n  }\n  other\n}\n\n///|\n/// Merges two maps into a new map. Returns a new map containing all key-value\n/// pairs from both maps. When both maps contain the same key, the value from\n/// `other` takes precedence. The iteration order follows the order of `self`\n/// followed by new entries from `other`.\n///\n/// This is a pure operation - it does not modify either of the input maps.\n///\n/// Parameters:\n///\n/// * `self` : The first map.\n/// * `other` : The second map whose values take precedence in case of key\n/// conflicts.\n///\n/// Returns a new linked hash map containing all entries from both maps.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map1 : Map[String, Int] = { \"a\": 1, \"b\": 2 }\n///   let map2 : Map[String, Int] = { \"b\": 3, \"c\": 4 }\n///   let merged = map1.merge(map2)\n///   @json.json_inspect(merged, content={ \"a\": 1, \"b\": 3, \"c\": 4 })\n/// }\n/// ```\npub fn[K : Eq, V] Map::merge(self : Map[K, V], other : Map[K, V]) -> Map[K, V] {\n  let result = self.copy()\n  result.merge_in_place(other)\n  result\n}\n\n///|\n/// Merges another map into this map in-place. Updates the current map by adding\n/// all key-value pairs from `other`. When both maps contain the same key, the\n/// value from `other` overwrites the value in this map. New entries from `other`\n/// are added at the end, preserving the original order of `self` and appending\n/// new keys from `other`.\n///\n/// This is a mutating operation - it modifies the receiver map.\n///\n/// Parameters:\n///\n/// * `self` : The map to be modified.\n/// * `other` : The map whose entries will be added to `self`.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map1 : Map[String, Int] = { \"a\": 1, \"b\": 2 }\n///   let map2 : Map[String, Int] = { \"b\": 3, \"c\": 4 }\n///   map1.merge_in_place(map2)\n///   @json.json_inspect(map1, content={ \"a\": 1, \"b\": 3, \"c\": 4 })\n/// }\n/// ```\npub fn[K : Eq, V] Map::merge_in_place(\n  self : Map[K, V],\n  other : Map[K, V],\n) -> Unit {\n  if physical_equal(self, other) {\n    return\n  }\n  loop other.head {\n    Some({ key, value, next, hash, .. }) => {\n      self.set_with_hash(key, value, hash)\n      continue next\n    }\n    None => break\n  }\n}\n\n///|\n/// Retains only the key-value pairs that satisfy the given predicate function.\n/// This method modifies the map in-place, removing all entries for which\n/// the predicate returns `false`. The order of remaining elements is preserved.\n///\n/// Parameters:\n///\n/// * `self` : The map to be filtered.\n/// * `predicate` : A function that takes a key and value as arguments and returns\n/// `true` if the key-value pair should be kept, `false` if it should be removed.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map = { \"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4 }\n///   map.retain((_k, v) => v % 2 == 0) // Keep only even values\n///   inspect(map.length(), content=\"2\")\n///   inspect(map.get(\"a\"), content=\"None\")\n///   inspect(map.get(\"b\"), content=\"Some(2)\")\n///   inspect(map.get(\"c\"), content=\"None\")\n///   inspect(map.get(\"d\"), content=\"Some(4)\")\n/// }\n/// ```\n#locals(f)\npub fn[K, V] Map::retain(self : Map[K, V], f : (K, V) -> Bool) -> Unit {\n  loop (self.head, false) {\n    (Some({ key, value, next, prev: idx, .. }), remove_prev) => {\n      if remove_prev {\n        guard self.entries[idx] is Some(entry)\n        self.remove_entry(entry)\n        self.shift_back(idx)\n        self.size -= 1\n      }\n      continue (next, !f(key, value))\n    }\n    (None, remove_prev) =>\n      if remove_prev {\n        let idx = self.tail\n        guard self.entries[idx] is Some(entry)\n        self.remove_entry(entry)\n        self.shift_back(idx)\n        self.size -= 1\n      }\n  }\n}\n\n///|\n/// Updates a value in the map based on the existing value.\n///\n/// This method allows you to conditionally update, insert, or remove a key-value pair\n/// based on whether the key already exists in the map. The provided function `f` is\n/// called with `Some(current_value)` if the key exists, or `None` if it doesn't.\n///\n/// Parameters:\n///\n/// * `self` : The map to update.\n/// * `key` : The key to update.\n/// * `f` : A function that takes the current value (wrapped in `Option`) and returns\n///   the new value (wrapped in `Option`). Returning `None` will remove the key-value\n///   pair from the map.\n///\n/// Behavior:\n///\n/// * If the key exists and `f` returns `Some(new_value)`, the value is updated.\n/// * If the key exists and `f` returns `None`, the key-value pair is removed.\n/// * If the key doesn't exist and `f` returns `Some(new_value)`, a new pair is inserted.\n/// * If the key doesn't exist and `f` returns `None`, no operation is performed.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map = { \"a\": 1, \"b\": 2 }\n///\n///   // Update existing value\n///   map.update(\"a\", fn(v) {\n///     match v {\n///       Some(x) => Some(x + 10)\n///       None => Some(0)\n///     }\n///   })\n///   inspect(\n///     map,\n///     content=(\n///       #|{\"a\": 11, \"b\": 2}\n///     ),\n///   )\n///\n///   // Insert new value\n///   map.update(\"c\", fn(v) {\n///     match v {\n///       Some(x) => Some(x)\n///       None => Some(3)\n///     }\n///   })\n///   inspect(\n///     map,\n///     content=(\n///       #|{\"a\": 11, \"b\": 2, \"c\": 3}\n///     ),\n///   )\n///\n///   // Remove existing value\n///   map.update(\"b\", fn(_) { None })\n///   inspect(\n///     map,\n///     content=(\n///       #|{\"a\": 11, \"c\": 3}\n///     ),\n///   )\n/// }\n/// ```\npub fn[K : Hash + Eq, V] Map::update(\n  self : Map[K, V],\n  key : K,\n  f : (V?) -> V?,\n) -> Unit {\n  let hash = key.hash()\n  let (idx, psl, new_value, push_away) = for psl = 0, idx = hash &\n                                               self.capacity_mask {\n    match self.entries[idx] {\n      Some(entry) => {\n        if entry.hash == hash && entry.key == key {\n          // Found the entry, update its value\n          if f(Some(entry.value)) is Some(new_value) {\n            entry.value = new_value\n          } else {\n            // Remove the entry since the new value is None\n            self.remove_entry(entry)\n            self.shift_back(idx)\n            self.size -= 1\n          }\n          return\n        }\n        if psl > entry.psl {\n          guard f(None) is Some(new_value) else { return }\n          break (idx, psl, new_value, Some(entry))\n        }\n        continue psl + 1, (idx + 1) & self.capacity_mask\n      }\n      None => {\n        guard f(None) is Some(new_value) else { return }\n        break (idx, psl, new_value, None)\n      }\n    }\n  }\n  if self.size >= self.grow_at {\n    // Slow path, we need to resize\n    self.grow()\n    self.set(key, new_value)\n  } else {\n    if push_away is Some(entry) {\n      self.push_away(idx, entry)\n    }\n    let entry = {\n      prev: self.tail,\n      next: None,\n      psl,\n      hash,\n      key,\n      value: new_value,\n    }\n    self.add_entry_to_tail(idx, entry)\n  }\n}\n\n// Special handling for Views as accessors\n\n///|\nfn StringView::equal_to_string(self : Self, other : String) -> Bool {\n  let str = self.str()\n  let start = self.start()\n  let end = self.end()\n  let len = end - start\n  guard len == other.length() else { return false }\n  if physical_equal(str, other) && self.start() == 0 {\n    return true\n  }\n  for i in 0..<len {\n    guard str.unsafe_get(self.start() + i) == other.unsafe_get(i) else {\n      return false\n    }\n  }\n  true\n}\n\n///|\nfn BytesView::equal_to_bytes(self : Self, other : Bytes) -> Bool {\n  let self_len = self.len()\n  let start = self.start()\n  guard self_len == other.length() else { return false }\n  for i in 0..<self_len {\n    guard self.bytes().unsafe_get(i + start) == other.unsafe_get(i) else {\n      return false\n    }\n  }\n  true\n}\n\n///|\n/// Retrieves the value associated with a `BytesView` key in a map with `Bytes` keys.\n///\n/// This function allows efficient lookups using `BytesView` without creating a new `Bytes` object.\n/// It's particularly useful when working with byte slices or subranges of existing byte arrays.\n///\n/// Parameters:\n///\n/// * `map` : The hash map with `Bytes` keys to search in.\n/// * `key` : A `BytesView` representing the key to look up.\n///\n/// Returns `Some(value)` if a matching key exists in the map, `None` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map = { b\"hello\": 1, b\"world\": 2 }\n///   let bytes = b\"prefix_hello_suffix\"\n///   let view = bytes[7:12] // view of \"hello\"\n///   inspect(map.get_from_bytes(view), content=\"Some(1)\")\n/// }\n/// ```\npub fn[V] Map::get_from_bytes(map : Self[Bytes, V], key : BytesView) -> V? {\n  let hash = key.hash()\n  for i = 0, idx = hash & map.capacity_mask {\n    guard map.entries[idx] is Some(entry) else { break None }\n    if entry.hash == hash && key.equal_to_bytes(entry.key) {\n      break Some(entry.value)\n    }\n    if i > entry.psl {\n      break None\n    }\n    continue i + 1, (idx + 1) & map.capacity_mask\n  }\n}\n\n///|\n/// Retrieves the value associated with a `StringView` key in a map with `String` keys.\n///\n/// This function allows efficient lookups using `StringView` without creating a new `String` object.\n/// It's particularly useful when working with substrings or string slices.\n///\n/// Parameters:\n///\n/// * `map` : The hash map with `String` keys to search in.\n/// * `key` : A `StringView` representing the key to look up.\n///\n/// Returns `Some(value)` if a matching key exists in the map, `None` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map = { \"hello\": 1, \"world\": 2 }\n///   let str = \"say hello to everyone\"\n///   let view = str.view(start_offset=4, end_offset=9) // view of \"hello\"\n///   inspect(map.get_from_string(view), content=\"Some(1)\")\n/// }\n/// ```\npub fn[V] Map::get_from_string(map : Self[String, V], key : StringView) -> V? {\n  let hash = key.hash()\n  for i = 0, idx = hash & map.capacity_mask {\n    guard map.entries[idx] is Some(entry) else { break None }\n    if entry.hash == hash && key.equal_to_string(entry.key) {\n      break Some(entry.value)\n    }\n    if i > entry.psl {\n      break None\n    }\n    continue i + 1, (idx + 1) & map.capacity_mask\n  }\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Returns the smallest power of two greater than or equal to `self`.\n/// This function will panic if `self` is negative. For values greater than\n/// the largest representable power of two (2^30 = 1073741824), it returns\n/// the largest representable power of two.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   inspect((0).next_power_of_two(), content=\"1\")\n///   inspect((1).next_power_of_two(), content=\"1\")\n///   inspect((2).next_power_of_two(), content=\"2\")\n///   inspect((3).next_power_of_two(), content=\"4\")\n///   inspect((8).next_power_of_two(), content=\"8\")\n///   inspect((1073741824).next_power_of_two(), content=\"1073741824\")\n///   inspect((2000000000).next_power_of_two(), content=\"1073741824\")\n/// }\n/// ```\npub fn Int::next_power_of_two(self : Int) -> Int {\n  guard self >= 0\n  if self <= 1 {\n    return 1\n  }\n  // The largest power of 2 that fits in a 32-bit signed integer is 2^30\n  let max_power_of_two = 1073741824 // 2^30\n  if self > max_power_of_two {\n    return max_power_of_two\n  }\n  // 2147483647 is the largest value of an integer\n  (2147483647 >> ((self - 1).clz() - 1)) + 1\n}\n\n///|\n/// Returns the minimum of two integers.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   inspect((1).min(2), content=\"1\")\n///   inspect((2).min(1), content=\"1\")\n/// }\n/// ```\npub fn Int::min(self : Int, other : Int) -> Int {\n  if self < other {\n    self\n  } else {\n    other\n  }\n}\n\n///|\n/// Returns the maximum of two integers.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   inspect((1).max(2), content=\"2\")\n///   inspect((2).max(1), content=\"2\")\n/// }\n/// ```\npub fn Int::max(self : Int, other : Int) -> Int {\n  if self > other {\n    self\n  } else {\n    other\n  }\n}\n\n///|\n/// Clamps the value `self` between `min` and `max`.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   inspect((1).clamp(min=0, max=2), content=\"1\")\n///   inspect((-1).clamp(min=0, max=2), content=\"0\")\n///   inspect((3).clamp(min=0, max=2), content=\"2\")\n///   inspect((-1).clamp(min=0, max=2), content=\"0\")\n/// }\n/// ```\npub fn Int::clamp(self : Int, min~ : Int, max~ : Int) -> Int {\n  guard min <= max\n  if self < min {\n    min\n  } else if self > max {\n    max\n  } else {\n    self\n  }\n}\n\n///|\n/// Checks if the integer value represents a UTF-16 leading surrogate.\n/// Leading surrogates are in the range 0xD800 to 0xDBFF.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   inspect((0xD800).is_leading_surrogate(), content=\"true\")\n///   inspect((0xDBFF).is_leading_surrogate(), content=\"true\")\n///   inspect((0xDC00).is_leading_surrogate(), content=\"false\")\n///   inspect((0x41).is_leading_surrogate(), content=\"false\") // 'A'\n/// }\n/// ```\npub fn Int::is_leading_surrogate(self : Int) -> Bool {\n  0xD800 <= self && self <= 0xDBFF\n}\n\n///|\n/// Checks if the integer value represents a UTF-16 trailing surrogate.\n/// Trailing surrogates are in the range 0xDC00 to 0xDFFF.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   inspect((0xDC00).is_trailing_surrogate(), content=\"true\")\n///   inspect((0xDFFF).is_trailing_surrogate(), content=\"true\")\n///   inspect((0xD800).is_trailing_surrogate(), content=\"false\")\n///   inspect((0x41).is_trailing_surrogate(), content=\"false\") // 'A'\n/// }\n/// ```\npub fn Int::is_trailing_surrogate(self : Int) -> Bool {\n  0xDC00 <= self && self <= 0xDFFF\n}\n\n///|\n/// Checks if the integer value represents any UTF-16 surrogate (leading or trailing).\n/// Surrogates are in the range 0xD800 to 0xDFFF.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   inspect((0xD800).is_surrogate(), content=\"true\") // leading surrogate\n///   inspect((0xDC00).is_surrogate(), content=\"true\") // trailing surrogate\n///   inspect((0xDFFF).is_surrogate(), content=\"true\") // trailing surrogate\n///   inspect((0x41).is_surrogate(), content=\"false\") // 'A'\n///   inspect((0x1F600).is_surrogate(), content=\"false\") //  emoji codepoint\n/// }\n/// ```\npub fn Int::is_surrogate(self : Int) -> Bool {\n  0xD800 <= self && self <= 0xDFFF\n}\n\n///|\n/// Computes the absolute value of an integer.\n///\n/// Parameters:\n///\n/// * `self` : The integer whose absolute value is to be computed.\n///\n/// Returns the absolute value of the integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(Int::abs(42), content=\"42\")\n///   inspect(Int::abs(-42), content=\"42\")\n///   inspect(Int::abs(0), content=\"0\")\n/// }\n/// ```\npub fn Int::abs(self : Int) -> Int {\n  if self < 0 {\n    -self\n  } else {\n    self\n  }\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\npub(all) suberror StrConvError {\n  StrConvError(String)\n}\n\n///|\npub impl Show for StrConvError with output(self, logger) {\n  match self {\n    StrConvError(err) => logger.write_string(err)\n  }\n}\n\n///|\nlet range_err_str = \"value out of range\"\n\n///|\nlet syntax_err_str = \"invalid syntax\"\n\n///|\nlet base_err_str = \"invalid base\"\n\n///|\nfn[T] range_err() -> T raise StrConvError {\n  raise StrConvError(range_err_str)\n}\n\n///|\nfn[T] syntax_err() -> T raise StrConvError {\n  raise StrConvError(syntax_err_str)\n}\n\n///|\nfn[T] base_err() -> T raise StrConvError {\n  raise StrConvError(base_err_str)\n}\n","///|\n/// Represent the URL change request from the user, trigger by `@html.a` tag.\n/// The `Internal` means the target URL is in the same domain.\n/// The `External` means the target URL is in another site.\npub(all) enum UrlRequest {\n  Internal(Url)\n  External(String)\n} derive(Show, Eq, Compare)\n\n///|\n/// Url\n/// \n/// ```text\n///  https://example.com:8042/over/there?name=ferret#nose\n///  \\___/   \\______________/\\_________/ \\_________/ \\__/\n///    |            |            |            |        |\n///  scheme     authority       path        query   fragment\n/// ```\n/// \n/// This diagram is from https://package.elm-lang.org/packages/elm/url/latest/Url\npub(all) struct Url {\n  protocol : Protocol\n  host : String\n  port : Int?\n  path : String\n  query : String?\n  fragment : String?\n} derive(Show, Eq, Compare)\n\n///|\npub(all) enum Protocol {\n  Http\n  Https\n  Other(String)\n} derive(Show, Eq, Compare)\n\n///|\npub fn Url::to_string(self : Url) -> String {\n  let protocol = match self.protocol {\n    Http => \"http\"\n    Https => \"https\"\n    _ => panic() // TODO: fix this\n  }\n  let port = match self.port {\n    Some(p) => \":\\{p}\"\n    None => \"\"\n  }\n  let query = match self.query {\n    Some(q) => \"?\\{q}\"\n    None => \"\"\n  }\n  let fragment = match self.fragment {\n    Some(f) => \"#\\{f}\"\n    None => \"\"\n  }\n  \"\\{protocol}://\\{self.host}\\{port}/\\{self.path}\\{query}\\{fragment}\"\n}\n\n///|\npub fn parse(url : String) -> Url raise Error {\n  let (protocol, remain) = match url.split(\"://\").collect() {\n    [\"http\", remain] => (Http, remain)\n    [\"https\", remain] => (Https, remain)\n    [x, remain] => (Other(x.to_string()), remain)\n    [remain] => (Other(\"\"), remain)\n    _ => fail(\"Invalid protocol\")\n  }\n  let (mid, query_and_fragment) = match remain.split(\"?\").collect() {\n    [mid, remain] => (mid, remain)\n    [mid] => (mid, \"\")\n    _ => fail(\"Invalid host\")\n  }\n  let (mid_part, fragment1) = match mid.split(\"#\").collect() {\n    [mid, fragment] => (mid, Some(fragment))\n    [mid] => (mid, None)\n    _ => fail(\"Invalid fragment\")\n  }\n  let (mid, path) = match mid_part.split(\"/\").collect() {\n    [mid] => (mid, \"\")\n    [mid, .. paths] =>\n      (mid, paths.iter().map(@string.View::to_string).join(\"/\"))\n    _ => fail(\"Invalid host\")\n  }\n  let (host, port) = match mid.split(\":\").collect() {\n    [host, port] => {\n      let port = try @strconv.parse_int(port.to_string()) catch {\n        _ => Option::None\n      } noraise {\n        number => Some(number)\n      }\n      (host.to_string(), port)\n    }\n    [host] => (host.to_string(), None)\n    _ => fail(\"Invalid host\")\n  }\n  let (query, fragment2) = match query_and_fragment.split(\"#\").collect() {\n    [query, fragment] => (Some(query.to_string()), Some(fragment))\n    [query] =>\n      if query.is_empty() {\n        (None, None)\n      } else {\n        (Some(query.to_string()), None)\n      }\n    [] => (None, None)\n    _ => fail(\"Invalid query\")\n  }\n  let fragment = match (fragment1, fragment2) {\n    (Some(f1), Some(f2)) => Some(\"\\{f1}#\\{f2}\")\n    (Some(f), None) => Some(f.to_string())\n    (None, Some(f)) => Some(f.to_string())\n    (None, None) => None\n  }\n  { protocol, host, port, path, query, fragment }\n}\n","///|\n#external\ntype Nullable[_]\n\n///|\npub fn[T] Nullable::is_null(self : Nullable[T]) -> Bool {\n  Value::is_null(Value::cast_from(self))\n}\n\n///|\n#deprecated(\"get_exn does not check for null values. Use unwrap instead\")\npub fn[T] Nullable::get_exn(self : Nullable[T]) -> T = \"%identity\"\n\n///| Unwraps the nullable value, panicking if it is null.\npub fn[T] Nullable::unwrap(self : Nullable[T]) -> T {\n  if self.is_null() {\n    abort(\"Cannot unwrap a null value\")\n  }\n  self.get_exn()\n}\n\n///|\npub fn[T] Nullable::to_option(self : Nullable[T]) -> T? {\n  guard not(Value::cast_from(self).is_null()) else { None }\n  Some(self.get_exn())\n}\n\n///|\npub fn[T] Nullable::null() -> Nullable[T] {\n  Value::null().cast()\n}\n\n///|\npub fn[T] Nullable::from_option(value : T?) -> Nullable[T] {\n  value.map(Value::cast_from).unwrap_or_else(Value::null).cast()\n}\n","///|\n/// Store the events that can be triggered by the command.\nstruct Events[M] {\n  on_url_changed : (@url.Url) -> Unit\n  on_url_request : (@url.UrlRequest) -> Unit\n  on_update : (M) -> Unit\n}\n\n///|\n/// Used by the runtime.\npub fn[M] Events::new(\n  on_url_changed : (@url.Url) -> Unit,\n  on_url_request : (@url.UrlRequest) -> Unit,\n  on_update : (M) -> Unit,\n) -> Events[M] {\n  { on_url_changed, on_url_request, on_update }\n}\n\n///|\n/// Trigger the update function with `url_changed` message config by the user.\npub fn[M] Events::trigger_url_changed(self : Events[M], url : @url.Url) -> Unit {\n  (self.on_url_changed)(url)\n}\n\n///|\n/// Trigger the update function with `url_request` message config by the user.\npub fn[M] Events::trigger_url_request(\n  self : Events[M],\n  url : @url.UrlRequest,\n) -> Unit {\n  (self.on_url_request)(url)\n}\n\n///|\n/// Trigger the update function with message `msg`.\npub fn[M] Events::trigger_update(self : Events[M], msg : M) -> Unit {\n  (self.on_update)(msg)\n}\n\n///|\n/// The command type, represents a task that can be executed.\n/// \n/// You can define your own command to interoperate Rabbit-Tea with the outside JS world.\n/// \n/// Before implementing your own command, check the existing commands in the `nav` and `http` packages.\n/// \n/// # Example \n/// \n/// ```moonbit skip\n/// fn delay[M](msg : M, ms : Int) -> Cmd[M] {\n///   Cmd(events => {\n///     set_timeout(() => { events.trigger_update(msg) }, ms)\n///   })\n/// } \n/// \n/// extern \"js\" fn set_timeout(f : () -> Unit, ms : Int) = \"(f,ms) => setTimeout(f, ms)\"\n/// ```\n#alias(Command)\npub(all) struct Cmd[M]((Events[M]) -> Unit)\n\n///|\n/// Map the messages in the command to another type.\npub fn[A, B] Cmd::map(self : Cmd[A], f : (A) -> B) -> Cmd[B] {\n  Cmd(events => {\n    let predef = {\n      on_url_changed: events.on_url_changed,\n      on_url_request: events.on_url_request,\n      on_update: msg => (events.on_update)(f(msg)),\n    }\n    let Cmd(f) = self\n    f(predef)\n  })\n}\n\n///|\n/// Create a command that does nothing.\npub fn[M] none() -> Cmd[M] {\n  Cmd(ignore)\n}\n\n///|\n/// Create a command that runs multiple commands.\npub fn[M] batch(xs : Array[Cmd[M]]) -> Cmd[M] {\n  Cmd(events => xs.each(cmd => (cmd.0)(events)))\n}\n\n///|\n/// Create a command that trigger another update for the given message.\npub fn[M] task(message : M) -> Cmd[M] {\n  Cmd(events => events.trigger_update(message))\n}\n\n///|\n/// Create a command that runs an async function.\n/// \n/// The async function `f` will be called, and the result will be wrapped in a \n/// message `msg`, then trigger another update with this message.\npub fn[A, M] perform(msg : (A) -> M, f : async () -> A noraise) -> Cmd[M] {\n  Cmd(events => @js.async_run(() => events.trigger_update(msg(f()))))\n}\n\n///|\n/// Create a command that runs an async function and handles errors.\n/// \n/// This is similar to `perform`, but it converts the returned value \n/// or thrown error into a `Result`.\npub fn[A, E : Error, M] attempt(\n  msg : (Result[A, E]) -> M,\n  f : async () -> A raise E,\n) -> Cmd[M] {\n  Cmd(events => @js.async_run(() => {\n    let msg = try f() catch {\n      e => msg(Err(e))\n    } noraise {\n      r => msg(Ok(r))\n    }\n    events.trigger_update(msg)\n  }))\n}\n","///|\n#external\ntype Node\n\n///|\npub trait IsNode: IsEventTarget {\n  as_node(Self) -> Node = _\n  get_node_type(Self) -> Int = _\n  get_node_name(Self) -> String = _\n  get_node_value(Self) -> String = _\n  get_first_child(Self) -> Node = _\n  get_last_child(Self) -> Node = _\n  get_next_sibling(Self) -> Node = _\n  get_previous_sibling(Self) -> Node = _\n  get_parent_node(Self) -> Node = _\n  append_child(Self, Node) -> Unit = _\n  remove_child(Self, Node) -> Unit = _\n  replace_child(Self, Node, Node) -> Unit = _\n  insert_before(Self, Node, Node) -> Unit = _\n  get_child(Self, Int) -> Node = _\n  get_child_count(Self) -> Int = _\n}\n\n///|\npub impl IsEventTarget for Node\n\n///|\npub impl @js.Cast for Node with into(value) {\n  value |> ffi_to_node |> _.to_option()\n}\n\n///|\npub impl @js.Cast for Node with from(value) {\n  value |> js_identity\n}\n\n///|\npub impl IsNode for Node\n\n///|\nimpl IsNode with as_node(s) {\n  js_identity(s)\n}\n\n///|\nimpl IsNode with get_node_type(s) {\n  s |> js_identity |> ffi_node_type\n}\n\n///|\nimpl IsNode with get_node_name(s) {\n  s |> js_identity |> ffi_node_name\n}\n\n///|\nimpl IsNode with get_node_value(s) {\n  s |> js_identity |> ffi_node_value\n}\n\n///|\nimpl IsNode with get_first_child(s) {\n  s |> js_identity |> first_child\n}\n\n///|\nimpl IsNode with get_last_child(s) {\n  s |> js_identity |> ffi_last_child\n}\n\n///|\nimpl IsNode with get_next_sibling(s) {\n  s |> js_identity |> ffi_next_sibling\n}\n\n///|\nimpl IsNode with get_previous_sibling(s) {\n  s |> js_identity |> ffi_previous_sibling\n}\n\n///|\nimpl IsNode with get_parent_node(s) {\n  s |> js_identity |> ffi_parent_node\n}\n\n///|\nimpl IsNode with append_child(s, child) {\n  s |> js_identity |> ffi_append_child(child)\n}\n\n///|\nimpl IsNode with remove_child(s, child) {\n  s |> js_identity |> ffi_remove_child(child)\n}\n\n///|\nimpl IsNode with replace_child(s, new, old) {\n  s |> js_identity |> ffi_replace_child(new, old)\n}\n\n///|\nimpl IsNode with insert_before(s, value, before) {\n  s |> js_identity |> insert_before(value, before)\n}\n\n///|\nimpl IsNode with get_child(s, index) {\n  s |> js_identity |> ffi_nth_child(index)\n}\n\n///|\nimpl IsNode with get_child_count(s) {\n  s |> js_identity |> ffi_count_child\n}\n\n// ---------- node API --------------\n\n///|\nextern \"js\" fn ffi_node_type(x : @js.Value) -> Int = \"(x) => x.nodeType\"\n\n///|\nextern \"js\" fn ffi_node_name(x : @js.Value) -> String = \"(x) => x.nodeName\"\n\n///|\nextern \"js\" fn ffi_node_value(x : @js.Value) -> String = \"(x) => x.nodeValue\"\n\n///|\nextern \"js\" fn first_child(x : @js.Value) -> Node = \"(x) => x.firstChild\"\n\n///|\nextern \"js\" fn ffi_last_child(x : @js.Value) -> Node = \"(x) => x.lastChild\"\n\n///|\nextern \"js\" fn ffi_next_sibling(x : @js.Value) -> Node = \"(x) => x.nextSibling\"\n\n///|\nextern \"js\" fn ffi_previous_sibling(x : @js.Value) -> Node = \"(x) => x.previousSibling\"\n\n///|\nextern \"js\" fn ffi_parent_node(x : @js.Value) -> Node = \"(x) => x.parentNode\"\n\n///|\nextern \"js\" fn ffi_append_child(x : @js.Value, child : Node) = \"(p,c) => p.appendChild(c)\"\n\n///|\nextern \"js\" fn ffi_remove_child(x : @js.Value, child : Node) = \"(p,c) => p.removeChild(c)\"\n\n///|\nextern \"js\" fn ffi_replace_child(x : @js.Value, new : Node, old : Node) = \"(p,n,o) => p.replaceChild(n,o)\"\n\n///|\nextern \"js\" fn insert_before(x : @js.Value, value : Node, before : Node) = \"(p,value,before) => p.insertBefore(value,before)\"\n\n// ---------- some specific node API --------------\n// Note: the childNodes property is a NodeList, not an array, so we can't use the Array type.\n\n///|\nextern \"js\" fn ffi_nth_child(x : @js.Value, index : Int) -> Node =\n  #| (x,i) => { \n  #|   const r = x.childNodes[i]; \n  #|   if (r === undefined) throw new Error(`nth_child: index ${i} out of bounds, length=${x.childNodes.length}`);\n  #|   return r;\n  #| }\n\n///|\nextern \"js\" fn ffi_count_child(x : @js.Value) -> Int = \"(x) => x.childNodes.length\"\n","///|\n#external\ntype MouseEvent\n\n///|\npub trait IsMouseEvent: IsUIEvent {\n  as_mouse_event(Self) -> MouseEvent = _\n  get_alt_key(Self) -> Bool = _\n  get_button(Self) -> Int = _\n  get_buttons(Self) -> Int = _\n  get_client_x(Self) -> Int = _\n  get_client_y(Self) -> Int = _\n  get_ctrl_key(Self) -> Bool = _\n  get_meta_key(Self) -> Bool = _\n  get_movement_x(Self) -> Int = _\n  get_movement_y(Self) -> Int = _\n  get_offset_x(Self) -> Int = _\n  get_offset_y(Self) -> Int = _\n  get_page_x(Self) -> Int = _\n  get_page_y(Self) -> Int = _\n  get_related_target(Self) -> EventTarget = _\n  get_screen_x(Self) -> Int = _\n  get_screen_y(Self) -> Int = _\n  get_shift_key(Self) -> Bool = _\n  get_x(Self) -> Int = _\n  get_y(Self) -> Int = _\n  get_modifier_state(Self) -> Int = _\n}\n\n///|\npub impl IsEvent for MouseEvent\n\n///|\npub impl IsUIEvent for MouseEvent\n\n///|\npub impl IsMouseEvent for MouseEvent\n\n///|\npub impl @js.Cast for MouseEvent with into(value) {\n  value |> ffi_to_mouse_event |> _.to_option()\n}\n\n///|\npub impl @js.Cast for MouseEvent with from(value) {\n  value |> js_identity\n}\n\n///|\nimpl IsMouseEvent with as_mouse_event(s) {\n  s |> js_identity\n}\n\n///|\nimpl IsMouseEvent with get_alt_key(s) {\n  s |> js_identity |> ffi_mouse_event_alt_key\n}\n\n///|\nimpl IsMouseEvent with get_button(s) {\n  s |> js_identity |> ffi_mouse_event_button\n}\n\n///|\nimpl IsMouseEvent with get_buttons(s) {\n  s |> js_identity |> ffi_mouse_event_buttons\n}\n\n///|\nimpl IsMouseEvent with get_client_x(s) {\n  s |> js_identity |> ffi_mouse_event_client_x\n}\n\n///|\nimpl IsMouseEvent with get_client_y(s) {\n  s |> js_identity |> ffi_mouse_event_client_y\n}\n\n///|\nimpl IsMouseEvent with get_ctrl_key(s) {\n  s |> js_identity |> ffi_mouse_event_ctrl_key\n}\n\n///|\nimpl IsMouseEvent with get_meta_key(s) {\n  s |> js_identity |> ffi_mouse_event_meta_key\n}\n\n///|\nimpl IsMouseEvent with get_movement_x(s) {\n  s |> js_identity |> ffi_mouse_event_movement_x\n}\n\n///|\nimpl IsMouseEvent with get_movement_y(s) {\n  s |> js_identity |> ffi_mouse_event_movement_y\n}\n\n///|\nimpl IsMouseEvent with get_offset_x(s) {\n  s |> js_identity |> ffi_mouse_event_offset_x\n}\n\n///|\nimpl IsMouseEvent with get_offset_y(s) {\n  s |> js_identity |> ffi_mouse_event_offset_y\n}\n\n///|\nimpl IsMouseEvent with get_page_x(s) {\n  s |> js_identity |> ffi_mouse_event_page_x\n}\n\n///|\nimpl IsMouseEvent with get_page_y(s) {\n  s |> js_identity |> ffi_mouse_event_page_y\n}\n\n///|\nimpl IsMouseEvent with get_related_target(s) {\n  s |> js_identity |> ffi_mouse_event_related_target\n}\n\n///|\nimpl IsMouseEvent with get_screen_x(s) {\n  s |> js_identity |> ffi_mouse_event_screen_x\n}\n\n///|\nimpl IsMouseEvent with get_screen_y(s) {\n  s |> js_identity |> ffi_mouse_event_screen_y\n}\n\n///|\nimpl IsMouseEvent with get_shift_key(s) {\n  s |> js_identity |> ffi_mouse_event_shift_key\n}\n\n///|\nimpl IsMouseEvent with get_x(s) {\n  s |> js_identity |> ffi_mouse_event_x\n}\n\n///|\nimpl IsMouseEvent with get_y(s) {\n  s |> js_identity |> ffi_mouse_event_y\n}\n\n///|\nimpl IsMouseEvent with get_modifier_state(s) {\n  s |> js_identity |> ffi_mouse_event_modifier_state\n}\n\n///|\nextern \"js\" fn ffi_mouse_event_screen_x(e : @js.Value) -> Int = \"(e) => e.screenX\"\n\n///|\nextern \"js\" fn ffi_mouse_event_screen_y(e : @js.Value) -> Int = \"(e) => e.screenY\"\n\n///|\nextern \"js\" fn ffi_mouse_event_client_x(e : @js.Value) -> Int = \"(e) => e.clientX\"\n\n///|\nextern \"js\" fn ffi_mouse_event_client_y(e : @js.Value) -> Int = \"(e) => e.clientY\"\n\n///|\nextern \"js\" fn ffi_mouse_event_offset_x(e : @js.Value) -> Int = \"(e) => e.offsetX\"\n\n///|\nextern \"js\" fn ffi_mouse_event_offset_y(e : @js.Value) -> Int = \"(e) => e.offsetY\"\n\n///|\nextern \"js\" fn ffi_mouse_event_ctrl_key(e : @js.Value) -> Bool = \"(e) => e.ctrlKey\"\n\n///|\nextern \"js\" fn ffi_mouse_event_shift_key(e : @js.Value) -> Bool = \"(e) => e.shiftKey\"\n\n///|\nextern \"js\" fn ffi_mouse_event_alt_key(e : @js.Value) -> Bool = \"(e) => e.altKey\"\n\n///|\nextern \"js\" fn ffi_mouse_event_meta_key(e : @js.Value) -> Bool = \"(e) => e.metaKey\"\n\n///|\nextern \"js\" fn ffi_mouse_event_button(e : @js.Value) -> Int = \"(e) => e.button\"\n\n///|\nextern \"js\" fn ffi_mouse_event_buttons(e : @js.Value) -> Int = \"(e) => e.buttons\"\n\n///|\nextern \"js\" fn ffi_mouse_event_movement_x(e : @js.Value) -> Int = \"(e) => e.movementX\"\n\n///|\nextern \"js\" fn ffi_mouse_event_movement_y(e : @js.Value) -> Int = \"(e) => e.movementY\"\n\n///|\nextern \"js\" fn ffi_mouse_event_page_x(e : @js.Value) -> Int = \"(e) => e.pageX\"\n\n///|\nextern \"js\" fn ffi_mouse_event_page_y(e : @js.Value) -> Int = \"(e) => e.pageY\"\n\n///|\nextern \"js\" fn ffi_mouse_event_related_target(e : @js.Value) -> EventTarget = \"(e) => e.relatedTarget\"\n\n///|\nextern \"js\" fn ffi_mouse_event_x(e : @js.Value) -> Int = \"(e) => e.x\"\n\n///|\nextern \"js\" fn ffi_mouse_event_y(e : @js.Value) -> Int = \"(e) => e.y\"\n\n///|\nextern \"js\" fn ffi_mouse_event_modifier_state(e : @js.Value) -> Int = \"(e) => e.getModifierState()\"\n","///|\n/// https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement\n#external\ntype HTMLElement\n\n///|\n#external\ntype ElementInternals\n\n///|\n#external\ntype EditContext\n\n///|\npub trait IsHtmlElement: IsElement {\n  as_html_element(Self) -> HTMLElement = _\n  // Properties\n  get_access_key(Self) -> String = _\n  set_access_key(Self, String) -> Unit = _\n  get_access_key_label(Self) -> String = _\n  get_anchor_element(Self) -> Element? = _\n  get_attribute_style_map(Self) -> StylePropertyMap = _\n  get_auto_capitalize(Self) -> String = _\n  set_auto_capitalize(Self, String) -> Unit = _\n  get_auto_focus(Self) -> Bool = _\n  set_auto_focus(Self, Bool) -> Unit = _\n  get_auto_correct(Self) -> Bool = _\n  set_auto_correct(Self, Bool) -> Unit = _\n  get_content_editable(Self) -> String = _\n  set_content_editable(Self, String) -> Unit = _\n  get_dataset(Self) -> DOMStringMap = _\n  get_dir(Self) -> String = _\n  set_dir(Self, String) -> Unit = _\n  get_draggable(Self) -> Bool = _\n  set_draggable(Self, Bool) -> Unit = _\n  get_edit_context(Self) -> EditContext? = _\n  set_edit_context(Self, EditContext?) -> Unit = _\n  get_enter_key_hint(Self) -> String = _\n  set_enter_key_hint(Self, String) -> Unit = _\n  get_hidden(Self) -> @js.Value = _\n  set_hidden(Self, @js.Value) -> Unit = _\n  get_inert(Self) -> Bool = _\n  set_inert(Self, Bool) -> Unit = _\n  get_inner_text(Self) -> String = _\n  set_inner_text(Self, String) -> Unit = _\n  get_input_mode(Self) -> String = _\n  set_input_mode(Self, String) -> Unit = _\n  get_is_content_editable(Self) -> Bool = _\n  get_lang(Self) -> String = _\n  set_lang(Self, String) -> Unit = _\n  get_nonce(Self) -> String = _\n  set_nonce(Self, String) -> Unit = _\n  get_offset_height(Self) -> Double = _\n  get_offset_left(Self) -> Double = _\n  get_offset_parent(Self) -> Element? = _\n  get_offset_top(Self) -> Double = _\n  get_offset_width(Self) -> Double = _\n  get_outer_text(Self) -> String = _\n  set_outer_text(Self, String) -> Unit = _\n  get_popover(Self) -> String? = _\n  set_popover(Self, String?) -> Unit = _\n  get_spellcheck(Self) -> Bool = _\n  set_spellcheck(Self, Bool) -> Unit = _\n  get_style(Self) -> CSSStyleDeclaration = _\n  set_style_declaration(Self, CSSStyleDeclaration) -> Unit = _\n  get_tab_index(Self) -> Int = _\n  set_tab_index(Self, Int) -> Unit = _\n  get_title(Self) -> String = _\n  set_title(Self, String) -> Unit = _\n  get_translate(Self) -> Bool = _\n  set_translate(Self, Bool) -> Unit = _\n  get_virtual_keyboard_policy(Self) -> String = _\n  set_virtual_keyboard_policy(Self, String) -> Unit = _\n  get_writing_suggestions(Self) -> String = _\n  set_writing_suggestions(Self, String) -> Unit = _\n\n  // Methods\n  attach_internals(Self) -> ElementInternals = _\n  blur(Self) -> Unit = _\n  click(Self) -> Unit = _\n  focus(Self) -> Unit = _\n  hide_popover(Self) -> Unit = _\n  show_popover(Self) -> Unit = _\n  toggle_popover(Self, Bool?) -> Bool = _\n}\n\n///|\npub impl IsEventTarget for HTMLElement\n\n///|\npub impl @js.Cast for HTMLElement with into(value) {\n  value |> ffi_to_html_element |> _.to_option()\n}\n\n///|\npub impl @js.Cast for HTMLElement with from(value) {\n  value |> js_identity\n}\n\n///|\npub impl IsNode for HTMLElement\n\n///|\npub impl IsElement for HTMLElement\n\n///|\npub impl IsHtmlElement for HTMLElement\n\n///|\nimpl IsHtmlElement with as_html_element(s) {\n  js_identity(s)\n}\n\n///|\nimpl IsHtmlElement with get_access_key(s) {\n  ffi_html_element_get_access_key(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with set_access_key(s, value) {\n  ffi_html_element_set_access_key(s.as_html_element(), value)\n}\n\n///|\nimpl IsHtmlElement with get_access_key_label(s) {\n  ffi_html_element_get_access_key_label(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with get_anchor_element(s) {\n  ffi_html_element_get_anchor_element(s.as_html_element()).to_option()\n}\n\n///|\nimpl IsHtmlElement with get_attribute_style_map(s) {\n  ffi_html_element_get_attribute_style_map(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with get_auto_capitalize(s) {\n  ffi_html_element_get_autocapitalize(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with set_auto_capitalize(s, value) {\n  ffi_html_element_set_autocapitalize(s.as_html_element(), value)\n}\n\n///|\nimpl IsHtmlElement with get_auto_focus(s) {\n  ffi_html_element_get_autofocus(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with set_auto_focus(s, value) {\n  ffi_html_element_set_autofocus(s.as_html_element(), value)\n}\n\n///|\nimpl IsHtmlElement with get_auto_correct(s) {\n  ffi_html_element_get_autocorrect(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with set_auto_correct(s, value) {\n  ffi_html_element_set_autocorrect(s.as_html_element(), value)\n}\n\n///|\nimpl IsHtmlElement with get_content_editable(s) {\n  ffi_html_element_get_content_editable(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with set_content_editable(s, value) {\n  ffi_html_element_set_content_editable(s.as_html_element(), value)\n}\n\n///|\nimpl IsHtmlElement with get_dataset(s) {\n  ffi_html_element_get_dataset(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with get_dir(s) {\n  ffi_html_element_get_dir(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with set_dir(s, value) {\n  ffi_html_element_set_dir(s.as_html_element(), value)\n}\n\n///|\nimpl IsHtmlElement with get_draggable(s) {\n  ffi_html_element_get_draggable(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with set_draggable(s, value) {\n  ffi_html_element_set_draggable(s.as_html_element(), value)\n}\n\n///|\nimpl IsHtmlElement with get_edit_context(s) {\n  ffi_html_element_get_edit_context(s.as_html_element()).to_option()\n}\n\n///|\nimpl IsHtmlElement with set_edit_context(s, value) {\n  ffi_html_element_set_edit_context(s.as_html_element(), value)\n}\n\n///|\nimpl IsHtmlElement with get_enter_key_hint(s) {\n  ffi_html_element_get_enter_key_hint(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with set_enter_key_hint(s, value) {\n  ffi_html_element_set_enter_key_hint(s.as_html_element(), value)\n}\n\n///|\nimpl IsHtmlElement with get_hidden(s) {\n  ffi_html_element_get_hidden(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with set_hidden(s, value) {\n  ffi_html_element_set_hidden(s.as_html_element(), value)\n}\n\n///|\nimpl IsHtmlElement with get_inert(s) {\n  ffi_html_element_get_inert(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with set_inert(s, value) {\n  ffi_html_element_set_inert(s.as_html_element(), value)\n}\n\n///|\nimpl IsHtmlElement with get_inner_text(s) {\n  ffi_html_element_get_inner_text(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with set_inner_text(s, value) {\n  ffi_html_element_set_inner_text(s.as_html_element(), value)\n}\n\n///|\nimpl IsHtmlElement with get_input_mode(s) {\n  ffi_html_element_get_input_mode(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with set_input_mode(s, value) {\n  ffi_html_element_set_input_mode(s.as_html_element(), value)\n}\n\n///|\nimpl IsHtmlElement with get_is_content_editable(s) {\n  ffi_html_element_get_is_content_editable(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with get_lang(s) {\n  ffi_html_element_get_lang(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with set_lang(s, value) {\n  ffi_html_element_set_lang(s.as_html_element(), value)\n}\n\n///|\nimpl IsHtmlElement with get_nonce(s) {\n  ffi_html_element_get_nonce(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with set_nonce(s, value) {\n  ffi_html_element_set_nonce(s.as_html_element(), value)\n}\n\n///|\nimpl IsHtmlElement with get_offset_height(s) {\n  ffi_html_element_get_offset_height(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with get_offset_left(s) {\n  ffi_html_element_get_offset_left(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with get_offset_parent(s) {\n  ffi_html_element_get_offset_parent(s.as_html_element()).to_option()\n}\n\n///|\nimpl IsHtmlElement with get_offset_top(s) {\n  ffi_html_element_get_offset_top(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with get_offset_width(s) {\n  ffi_html_element_get_offset_width(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with get_outer_text(s) {\n  ffi_html_element_get_outer_text(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with set_outer_text(s, value) {\n  ffi_html_element_set_outer_text(s.as_html_element(), value)\n}\n\n///|\nimpl IsHtmlElement with get_popover(s) {\n  ffi_html_element_get_popover(s.as_html_element()).to_option()\n}\n\n///|\nimpl IsHtmlElement with set_popover(s, value) {\n  ffi_html_element_set_popover(s.as_html_element(), value)\n}\n\n///|\nimpl IsHtmlElement with get_spellcheck(s) {\n  ffi_html_element_get_spellcheck(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with set_spellcheck(s, value) {\n  ffi_html_element_set_spellcheck(s.as_html_element(), value)\n}\n\n///|\nimpl IsHtmlElement with get_style(s) {\n  ffi_html_element_get_style(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with set_style_declaration(s, value) {\n  ffi_html_element_set_style_declaration(s.as_html_element(), value)\n}\n\n///|\nimpl IsHtmlElement with get_tab_index(s) {\n  ffi_html_element_get_tab_index(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with set_tab_index(s, value) {\n  ffi_html_element_set_tab_index(s.as_html_element(), value)\n}\n\n///|\nimpl IsHtmlElement with get_title(s) {\n  ffi_html_element_get_title(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with set_title(s, value) {\n  ffi_html_element_set_title(s.as_html_element(), value)\n}\n\n///|\nimpl IsHtmlElement with get_translate(s) {\n  ffi_html_element_get_translate(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with set_translate(s, value) {\n  ffi_html_element_set_translate(s.as_html_element(), value)\n}\n\n///|\nimpl IsHtmlElement with get_virtual_keyboard_policy(s) {\n  ffi_html_element_get_virtual_keyboard_policy(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with set_virtual_keyboard_policy(s, value) {\n  ffi_html_element_set_virtual_keyboard_policy(s.as_html_element(), value)\n}\n\n///|\nimpl IsHtmlElement with get_writing_suggestions(s) {\n  ffi_html_element_get_writing_suggestions(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with set_writing_suggestions(s, value) {\n  ffi_html_element_set_writing_suggestions(s.as_html_element(), value)\n}\n\n///|\nimpl IsHtmlElement with attach_internals(s) {\n  ffi_html_element_attach_internals(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with blur(s) {\n  ffi_html_element_blur(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with click(s) {\n  ffi_html_element_click(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with focus(s) {\n  ffi_html_element_focus(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with hide_popover(s) {\n  ffi_html_element_hide_popover(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with show_popover(s) {\n  ffi_html_element_show_popover(s.as_html_element())\n}\n\n///|\nimpl IsHtmlElement with toggle_popover(s, force) {\n  ffi_html_element_toggle_popover(s.as_html_element(), force)\n}\n\n///|\nextern \"js\" fn ffi_html_element_get_access_key(s : HTMLElement) -> String = \"(s) => s.accessKey\"\n\n///|\nextern \"js\" fn ffi_html_element_set_access_key(\n  s : HTMLElement,\n  value : String,\n) -> Unit = \"(s, value) => s.accessKey = value\"\n\n///|\nextern \"js\" fn ffi_html_element_get_access_key_label(s : HTMLElement) -> String = \"(s) => s.accessKeyLabel\"\n\n///|\nextern \"js\" fn ffi_html_element_get_anchor_element(\n  s : HTMLElement,\n) -> @js.Nullable[Element] = \"(s) => s.anchorElement\"\n\n///|\nextern \"js\" fn ffi_html_element_get_attribute_style_map(\n  s : HTMLElement,\n) -> StylePropertyMap = \"(s) => s.attributeStyleMap\"\n\n///|\nextern \"js\" fn ffi_html_element_get_autocapitalize(s : HTMLElement) -> String = \"(s) => s.autocapitalize\"\n\n///|\nextern \"js\" fn ffi_html_element_set_autocapitalize(\n  s : HTMLElement,\n  value : String,\n) -> Unit = \"(s, value) => s.autocapitalize = value\"\n\n///|\nextern \"js\" fn ffi_html_element_get_autofocus(s : HTMLElement) -> Bool = \"(s) => s.autofocus\"\n\n///|\nextern \"js\" fn ffi_html_element_set_autofocus(\n  s : HTMLElement,\n  value : Bool,\n) -> Unit = \"(s, value) => s.autofocus = value\"\n\n///|\nextern \"js\" fn ffi_html_element_get_autocorrect(s : HTMLElement) -> Bool = \"(s) => s.autocorrect\"\n\n///|\nextern \"js\" fn ffi_html_element_set_autocorrect(\n  s : HTMLElement,\n  value : Bool,\n) -> Unit = \"(s, value) => s.autocorrect = value\"\n\n///|\nextern \"js\" fn ffi_html_element_get_content_editable(s : HTMLElement) -> String = \"(s) => s.contentEditable\"\n\n///|\nextern \"js\" fn ffi_html_element_set_content_editable(\n  s : HTMLElement,\n  value : String,\n) -> Unit = \"(s, value) => s.contentEditable = value\"\n\n///|\nextern \"js\" fn ffi_html_element_get_dataset(s : HTMLElement) -> DOMStringMap = \"(s) => s.dataset\"\n\n///|\nextern \"js\" fn ffi_html_element_get_dir(s : HTMLElement) -> String = \"(s) => s.dir\"\n\n///|\nextern \"js\" fn ffi_html_element_set_dir(\n  s : HTMLElement,\n  value : String,\n) -> Unit = \"(s, value) => s.dir = value\"\n\n///|\nextern \"js\" fn ffi_html_element_get_draggable(s : HTMLElement) -> Bool = \"(s) => s.draggable\"\n\n///|\nextern \"js\" fn ffi_html_element_set_draggable(\n  s : HTMLElement,\n  value : Bool,\n) -> Unit = \"(s, value) => s.draggable = value\"\n\n///|\nextern \"js\" fn ffi_html_element_get_edit_context(\n  s : HTMLElement,\n) -> @js.Nullable[EditContext] = \"(s) => s.editContext\"\n\n///|\nextern \"js\" fn ffi_html_element_set_edit_context(\n  s : HTMLElement,\n  value : EditContext?,\n) -> Unit = \"(s, value) => s.editContext = value\"\n\n///|\nextern \"js\" fn ffi_html_element_get_enter_key_hint(s : HTMLElement) -> String = \"(s) => s.enterKeyHint\"\n\n///|\nextern \"js\" fn ffi_html_element_set_enter_key_hint(\n  s : HTMLElement,\n  value : String,\n) -> Unit = \"(s, value) => s.enterKeyHint = value\"\n\n///|\nextern \"js\" fn ffi_html_element_get_hidden(s : HTMLElement) -> @js.Value = \"(s) => s.hidden\"\n\n///|\nextern \"js\" fn ffi_html_element_set_hidden(\n  s : HTMLElement,\n  value : @js.Value,\n) -> Unit = \"(s, value) => s.hidden = value\"\n\n///|\nextern \"js\" fn ffi_html_element_get_inert(s : HTMLElement) -> Bool = \"(s) => s.inert\"\n\n///|\nextern \"js\" fn ffi_html_element_set_inert(\n  s : HTMLElement,\n  value : Bool,\n) -> Unit = \"(s, value) => s.inert = value\"\n\n///|\nextern \"js\" fn ffi_html_element_get_inner_text(s : HTMLElement) -> String = \"(s) => s.innerText\"\n\n///|\nextern \"js\" fn ffi_html_element_set_inner_text(\n  s : HTMLElement,\n  value : String,\n) -> Unit = \"(s, value) => s.innerText = value\"\n\n///|\nextern \"js\" fn ffi_html_element_get_input_mode(s : HTMLElement) -> String = \"(s) => s.inputMode\"\n\n///|\nextern \"js\" fn ffi_html_element_set_input_mode(\n  s : HTMLElement,\n  value : String,\n) -> Unit = \"(s, value) => s.inputMode = value\"\n\n///|\nextern \"js\" fn ffi_html_element_get_is_content_editable(\n  s : HTMLElement,\n) -> Bool = \"(s) => s.isContentEditable\"\n\n///|\nextern \"js\" fn ffi_html_element_get_lang(s : HTMLElement) -> String = \"(s) => s.lang\"\n\n///|\nextern \"js\" fn ffi_html_element_set_lang(\n  s : HTMLElement,\n  value : String,\n) -> Unit = \"(s, value) => s.lang = value\"\n\n///|\nextern \"js\" fn ffi_html_element_get_nonce(s : HTMLElement) -> String = \"(s) => s.nonce\"\n\n///|\nextern \"js\" fn ffi_html_element_set_nonce(\n  s : HTMLElement,\n  value : String,\n) -> Unit = \"(s, value) => s.nonce = value\"\n\n///|\nextern \"js\" fn ffi_html_element_get_offset_height(s : HTMLElement) -> Double = \"(s) => s.offsetHeight\"\n\n///|\nextern \"js\" fn ffi_html_element_get_offset_left(s : HTMLElement) -> Double = \"(s) => s.offsetLeft\"\n\n///|\nextern \"js\" fn ffi_html_element_get_offset_parent(\n  s : HTMLElement,\n) -> @js.Nullable[Element] = \"(s) => s.offsetParent\"\n\n///|\nextern \"js\" fn ffi_html_element_get_offset_top(s : HTMLElement) -> Double = \"(s) => s.offsetTop\"\n\n///|\nextern \"js\" fn ffi_html_element_get_offset_width(s : HTMLElement) -> Double = \"(s) => s.offsetWidth\"\n\n///|\nextern \"js\" fn ffi_html_element_get_outer_text(s : HTMLElement) -> String = \"(s) => s.outerText\"\n\n///|\nextern \"js\" fn ffi_html_element_set_outer_text(\n  s : HTMLElement,\n  value : String,\n) -> Unit = \"(s, value) => s.outerText = value\"\n\n///|\nextern \"js\" fn ffi_html_element_get_popover(\n  s : HTMLElement,\n) -> @js.Nullable[String] = \"(s) => s.popover\"\n\n///|\nextern \"js\" fn ffi_html_element_set_popover(\n  s : HTMLElement,\n  value : String?,\n) -> Unit = \"(s, value) => s.popover = value\"\n\n///|\nextern \"js\" fn ffi_html_element_get_spellcheck(s : HTMLElement) -> Bool = \"(s) => s.spellcheck\"\n\n///|\nextern \"js\" fn ffi_html_element_set_spellcheck(\n  s : HTMLElement,\n  value : Bool,\n) -> Unit = \"(s, value) => s.spellcheck = value\"\n\n///|\nextern \"js\" fn ffi_html_element_get_style(\n  s : HTMLElement,\n) -> CSSStyleDeclaration = \"(s) => s.style\"\n\n///|\nextern \"js\" fn ffi_html_element_set_style_declaration(\n  s : HTMLElement,\n  value : CSSStyleDeclaration,\n) -> Unit = \"(s, value) => s.style = value\"\n\n///|\nextern \"js\" fn ffi_html_element_get_tab_index(s : HTMLElement) -> Int = \"(s) => s.tabIndex\"\n\n///|\nextern \"js\" fn ffi_html_element_set_tab_index(\n  s : HTMLElement,\n  value : Int,\n) -> Unit = \"(s, value) => s.tabIndex = value\"\n\n///|\nextern \"js\" fn ffi_html_element_get_title(s : HTMLElement) -> String = \"(s) => s.title\"\n\n///|\nextern \"js\" fn ffi_html_element_set_title(\n  s : HTMLElement,\n  value : String,\n) -> Unit = \"(s, value) => s.title = value\"\n\n///|\nextern \"js\" fn ffi_html_element_get_translate(s : HTMLElement) -> Bool = \"(s) => s.translate\"\n\n///|\nextern \"js\" fn ffi_html_element_set_translate(\n  s : HTMLElement,\n  value : Bool,\n) -> Unit = \"(s, value) => s.translate = value\"\n\n///|\nextern \"js\" fn ffi_html_element_get_virtual_keyboard_policy(\n  s : HTMLElement,\n) -> String = \"(s) => s.virtualKeyboardPolicy\"\n\n///|\nextern \"js\" fn ffi_html_element_set_virtual_keyboard_policy(\n  s : HTMLElement,\n  value : String,\n) -> Unit = \"(s, value) => s.virtualKeyboardPolicy = value\"\n\n///|\nextern \"js\" fn ffi_html_element_get_writing_suggestions(\n  s : HTMLElement,\n) -> String = \"(s) => s.writingSuggestions\"\n\n///|\nextern \"js\" fn ffi_html_element_set_writing_suggestions(\n  s : HTMLElement,\n  value : String,\n) -> Unit = \"(s, value) => s.writingSuggestions = value\"\n\n///|\nextern \"js\" fn ffi_html_element_attach_internals(\n  s : HTMLElement,\n) -> ElementInternals = \"(s) => s.attachInternals()\"\n\n///|\nextern \"js\" fn ffi_html_element_blur(s : HTMLElement) -> Unit = \"(s) => s.blur()\"\n\n///|\nextern \"js\" fn ffi_html_element_click(s : HTMLElement) -> Unit = \"(s) => s.click()\"\n\n///|\nextern \"js\" fn ffi_html_element_focus(s : HTMLElement) -> Unit = \"(s) => s.focus()\"\n\n///|\nextern \"js\" fn ffi_html_element_hide_popover(s : HTMLElement) -> Unit = \"(s) => s.hidePopover()\"\n\n///|\nextern \"js\" fn ffi_html_element_show_popover(s : HTMLElement) -> Unit = \"(s) => s.showPopover()\"\n\n///|\nextern \"js\" fn ffi_html_element_toggle_popover(\n  s : HTMLElement,\n  force : Bool?,\n) -> Bool = \"(s, force) => s.togglePopover(force)\"\n","///|\n/// DO NOT USE THIS FUNCTION.\n/// NOTE: There is a bug in the unused analyzer, so make this function public to avoid the warning.\npub fn[E, R] default_exception_handler(exception : E) -> R {\n  console_log(@js.Value::cast_from(exception))\n  panic()\n}\n\n///|\nextern \"js\" fn console_log(x : @js.Value) = \"(x) => console.log(x)\"\n\n///|\n// pub suberror DOMExceptionError DOMException\n// \n// ///|\n// #external\n// priv type HasException[A, B]\n// \n// ///|\n// extern \"js\" fn ffi_result_unwrap_err(s : @js.Value) -> @js.Value = \"(s) => s._moonbit_err\"\n// \n// ///|\n// extern \"js\" fn ffi_result_has_err(s : @js.Value) -> Bool = \"(s) => s._moonbit_err !== undefined\"\n// \n// ///|\n// fn[A, B, E : Error] HasException::convert(\n//   self : HasException[A, B],\n//   handler : (B) -> A raise E\n// ) -> A raise E {\n//   if ffi_result_has_err(js_identity(self)) {\n//     let err : B = self |> js_identity |> ffi_result_unwrap_err |> js_identity\n//     handler(err)\n//   } else {\n//     js_identity(self)\n//   }\n// }\n","///|\n#external\ntype EventTarget\n\n///|\npub trait IsEventTarget: @js.Cast {\n  as_event_target(Self) -> EventTarget = _\n  add_event_listener(Self, String, Listener) -> Unit = _\n  remove_event_listener(Self, String, Listener) -> Unit = _\n  dispatch_event(Self, Event) -> Unit = _\n  to_clipboard(Self) -> Clipboard? = _\n  to_node(Self) -> Node? = _\n  to_document(Self) -> Document? = _\n  to_document_fragment(Self) -> DocumentFragment? = _\n  to_element(Self) -> Element? = _\n  to_html_element(Self) -> HTMLElement? = _\n  to_html_canvas_element(Self) -> HTMLCanvasElement? = _\n  to_html_input_element(Self) -> HTMLInputElement? = _\n  to_html_dialog_element(Self) -> HTMLDialogElement? = _\n  to_html_image_element(Self) -> HTMLImageElement? = _\n  to_html_select_element(Self) -> HTMLSelectElement? = _\n  to_html_media_element(Self) -> HTMLMediaElement? = _\n  to_html_video_element(Self) -> HTMLVideoElement? = _\n  to_text(Self) -> Text? = _\n  to_svg_element(Self) -> SVGElement? = _\n  to_svg_graphics_element(Self) -> SVGGraphicsElement? = _\n  to_svg_image_element(Self) -> SVGImageElement? = _\n  to_window(Self) -> Window? = _\n}\n\n///|\npub type Listener = (Event) -> Unit\n\n///|\npub impl IsEventTarget for EventTarget\n\n///|\npub impl @js.Cast for EventTarget with into(value) {\n  value |> ffi_to_event_target |> _.to_option()\n}\n\n///|\npub impl @js.Cast for EventTarget with from(value) {\n  value |> js_identity\n}\n\n///|\nimpl IsEventTarget with add_event_listener(s, type_, callback) {\n  s |> js_identity |> ffi_add_event_listener(type_, callback)\n}\n\n///|\nimpl IsEventTarget with remove_event_listener(s, type_, callback) {\n  s |> js_identity |> ffi_remove_event_listener(type_, callback)\n}\n\n///|\nimpl IsEventTarget with dispatch_event(s, event) {\n  s |> js_identity |> ffi_dispatch_event(event)\n}\n\n///|\nimpl IsEventTarget with as_event_target(s) {\n  js_identity(s)\n}\n\n///|\nimpl IsEventTarget with to_clipboard(s) {\n  s |> js_identity |> ffi_to_clipboard |> _.to_option()\n}\n\n///|\nimpl IsEventTarget with to_node(s) {\n  s |> js_identity |> ffi_to_node |> _.to_option()\n}\n\n///|\nimpl IsEventTarget with to_document(s) {\n  s |> js_identity |> ffi_to_document |> _.to_option()\n}\n\n///|\nimpl IsEventTarget with to_document_fragment(s) {\n  s |> js_identity |> ffi_to_document_fragment |> _.to_option()\n}\n\n///|\nimpl IsEventTarget with to_element(s) {\n  s |> js_identity |> ffi_to_element |> _.to_option()\n}\n\n///|\nimpl IsEventTarget with to_html_element(s) {\n  s |> js_identity |> ffi_to_html_element |> _.to_option()\n}\n\n///|\nimpl IsEventTarget with to_html_canvas_element(s) {\n  s |> js_identity |> ffi_to_html_canvas_element |> _.to_option()\n}\n\n///|\nimpl IsEventTarget with to_html_input_element(s) {\n  s |> js_identity |> ffi_to_html_input_element |> _.to_option()\n}\n\n///|\nimpl IsEventTarget with to_html_dialog_element(s) {\n  s |> js_identity |> ffi_to_html_dialog_element |> _.to_option()\n}\n\n///|\nimpl IsEventTarget with to_html_image_element(s) {\n  s |> js_identity |> ffi_to_html_image_element |> _.to_option()\n}\n\n///|\nimpl IsEventTarget with to_html_select_element(s) {\n  s |> js_identity |> ffi_to_html_select_element |> _.to_option()\n}\n\n///|\nimpl IsEventTarget with to_text(s) {\n  s |> js_identity |> ffi_to_text |> _.to_option()\n}\n\n///|\nimpl IsEventTarget with to_svg_element(s) {\n  s |> js_identity |> ffi_to_svg_element |> _.to_option()\n}\n\n///|\nimpl IsEventTarget with to_svg_graphics_element(s) {\n  s |> js_identity |> ffi_to_svg_graphics_element |> _.to_option()\n}\n\n///|\nimpl IsEventTarget with to_svg_image_element(s) {\n  s |> js_identity |> ffi_to_svg_image_element |> _.to_option()\n}\n\n///|\nimpl IsEventTarget with to_html_media_element(s) {\n  s |> js_identity |> ffi_to_html_media_element |> _.to_option()\n}\n\n///|\nimpl IsEventTarget with to_html_video_element(s) {\n  s |> js_identity |> ffi_to_html_video_element |> _.to_option()\n}\n\n///|\nimpl IsEventTarget with to_window(s) {\n  s |> js_identity |> ffi_to_window |> _.to_option()\n}\n\n///|\nextern \"js\" fn ffi_to_node(x : @js.Value) -> @js.Nullable[Node] =\n  #| (x) => x instanceof Node ? x : null\n\n///|\nextern \"js\" fn ffi_to_clipboard(x : @js.Value) -> @js.Nullable[Clipboard] =\n  #| (x) => x instanceof Clipboard ? x : null\n\n///|\nextern \"js\" fn ffi_add_event_listener(\n  x : @js.Value,\n  type_ : String,\n  callback : Listener,\n) =\n  #| (target, type, listener) => target.addEventListener(type, listener)\n\n///|\nextern \"js\" fn ffi_remove_event_listener(\n  x : @js.Value,\n  type_ : String,\n  callback : Listener,\n) =\n  #| (target, type, listener) => target.removeEventListener(type, listener)\n\n///|\nextern \"js\" fn ffi_dispatch_event(x : @js.Value, event : Event) =\n  #| (target, event) => target.dispatchEvent(event)\n\n///|\nextern \"js\" fn ffi_to_document(x : @js.Value) -> @js.Nullable[Document] =\n  #| (x) => x.nodeType===9 ? x : null\n\n///|\nextern \"js\" fn ffi_to_document_fragment(\n  x : @js.Value,\n) -> @js.Nullable[DocumentFragment] =\n  #| (x) => x.nodeType===11 ? x : null\n\n///|\nextern \"js\" fn ffi_to_element(x : @js.Value) -> @js.Nullable[Element] =\n  #| (x) => x.nodeType===1 ? x : null\n\n///|\nextern \"js\" fn ffi_to_text(x : @js.Value) -> @js.Nullable[Text] =\n  #| (x) => x.nodeType===3 ? x : null\n\n///|\nextern \"js\" fn ffi_to_html_element(x : @js.Value) -> @js.Nullable[HTMLElement] =\n  #| (x) => x instanceof HTMLElement ? x : null\n\n///|\nextern \"js\" fn ffi_to_html_canvas_element(\n  x : @js.Value,\n) -> @js.Nullable[HTMLCanvasElement] =\n  #| (x) => x instanceof HTMLCanvasElement ? x : null\n\n///|\nextern \"js\" fn ffi_to_html_input_element(\n  x : @js.Value,\n) -> @js.Nullable[HTMLInputElement] =\n  #| (x) => x instanceof HTMLInputElement ? x : null\n\n///|\nextern \"js\" fn ffi_to_html_select_element(\n  x : @js.Value,\n) -> @js.Nullable[HTMLSelectElement] =\n  #| (x) => x instanceof HTMLSelectElement ? x : null\n\n///|\nextern \"js\" fn ffi_to_html_dialog_element(\n  x : @js.Value,\n) -> @js.Nullable[HTMLDialogElement] =\n  #| (x) => x instanceof HTMLDialogElement ? x : null\n\n///|\nextern \"js\" fn ffi_to_html_image_element(\n  x : @js.Value,\n) -> @js.Nullable[HTMLImageElement] =\n  #| (x) => x instanceof HTMLImageElement ? x : null\n\n///|\nextern \"js\" fn ffi_to_event_target(x : @js.Value) -> @js.Nullable[EventTarget] =\n  #| (self) => self instanceof EventTarget ? self : null\n\n///|\nextern \"js\" fn ffi_to_svg_element(x : @js.Value) -> @js.Nullable[SVGElement] = \"(x) => x instanceof SVGElement ? x : null\"\n\n///|\nextern \"js\" fn ffi_to_svg_graphics_element(\n  x : @js.Value,\n) -> @js.Nullable[SVGGraphicsElement] = \"(x) => x instanceof SVGGraphicsElement ? x : null\"\n\n///|\nextern \"js\" fn ffi_to_svg_image_element(\n  x : @js.Value,\n) -> @js.Nullable[SVGImageElement] = \"(x) => x instanceof SVGImageElement ? x : null\"\n\n///|\n\n///|\nextern \"js\" fn ffi_to_html_video_element(\n  x : @js.Value,\n) -> @js.Nullable[HTMLVideoElement] = \"(x) => x instanceof HTMLVideoElement ? x : null\"\n\n///|\nextern \"js\" fn ffi_to_window(value : @js.Value) -> @js.Nullable[Window] = \"(value) => value instanceof Window ? value : null\"\n","///|\n#external\ntype Event\n\n///|\nfn[A, B] js_identity(a : A) -> B {\n  @js.Value::cast_from(a).cast()\n}\n\n///|\npub trait IsEvent: @js.Cast {\n  target(Self) -> EventTarget = _\n  prevent_default(Self) -> Unit = _\n  stop_propagation(Self) -> Unit = _\n  as_event(Self) -> Event = _\n  to_ui_event(Self) -> UIEvent? = _\n  to_clipboard_event(Self) -> ClipboardEvent? = _\n  to_mouse_event(Self) -> MouseEvent? = _\n  to_input_event(Self) -> InputEvent? = _\n  to_focus_event(Self) -> FocusEvent? = _\n  to_keyboard_event(Self) -> KeyboardEvent? = _\n  to_animation_event(Self) -> AnimationEvent? = _\n  to_before_unload_event(Self) -> BeforeUnloadEvent? = _\n  to_blob_event(Self) -> BlobEvent? = _\n  to_close_event(Self) -> CloseEvent? = _\n  to_composition_event(Self) -> CompositionEvent? = _\n  to_custom_event(Self) -> CustomEvent? = _\n  to_drag_event(Self) -> DragEvent? = _\n  to_wheel_event(Self) -> WheelEvent? = _\n}\n\n///|\npub impl IsEvent for Event\n\n///|\npub impl @js.Cast for Event with into(value) {\n  value |> ffi_to_event |> _.to_option()\n}\n\n///|\npub impl @js.Cast for Event with from(value) {\n  value |> js_identity\n}\n\n///|\nimpl IsEvent with target(s) {\n  s |> js_identity |> ffi_event_target\n}\n\n///|\nimpl IsEvent with prevent_default(s) {\n  s.as_event() |> ffi_event_prevent_default\n}\n\n///|\nimpl IsEvent with stop_propagation(s) {\n  s.as_event() |> ffi_event_stop_propagation\n}\n\n///|\nimpl IsEvent with as_event(s) {\n  js_identity(s)\n}\n\n///|\nimpl IsEvent with to_ui_event(s) {\n  s |> js_identity |> ffi_to_ui_event |> _.to_option()\n}\n\n///|\nimpl IsEvent with to_clipboard_event(s) {\n  s |> js_identity |> ffi_to_clipboard_event |> _.to_option()\n}\n\n///|\nimpl IsEvent with to_mouse_event(s) {\n  s |> js_identity |> ffi_to_mouse_event |> _.to_option()\n}\n\n///|\nimpl IsEvent with to_input_event(s) {\n  s |> js_identity |> ffi_to_input_event |> _.to_option()\n}\n\n///|\nimpl IsEvent with to_focus_event(s) {\n  s |> js_identity |> ffi_to_focus_event |> _.to_option()\n}\n\n///|\nimpl IsEvent with to_keyboard_event(s) {\n  s |> js_identity |> ffi_to_keyboard_event |> _.to_option()\n}\n\n///|\nimpl IsEvent with to_animation_event(s) {\n  s |> js_identity |> ffi_to_animation_event |> _.to_option()\n}\n\n///|\nimpl IsEvent with to_before_unload_event(s) {\n  s |> js_identity |> ffi_to_before_unload_event |> _.to_option()\n}\n\n///|\nimpl IsEvent with to_blob_event(s) {\n  s |> js_identity |> ffi_to_blob_event |> _.to_option()\n}\n\n///|\nimpl IsEvent with to_close_event(s) {\n  s |> js_identity |> ffi_to_close_event |> _.to_option()\n}\n\n///|\nimpl IsEvent with to_composition_event(s) {\n  s |> js_identity |> ffi_to_composition_event |> _.to_option()\n}\n\n///|\nimpl IsEvent with to_custom_event(s) {\n  s |> js_identity |> ffi_to_custom_event |> _.to_option()\n}\n\n///|\nimpl IsEvent with to_drag_event(s) {\n  s |> js_identity |> ffi_to_drag_event |> _.to_option()\n}\n\n///|\nimpl IsEvent with to_wheel_event(s) {\n  s |> js_identity |> ffi_to_wheel_event |> _.to_option()\n}\n\n///|\nextern \"js\" fn ffi_event_target(x : @js.Value) -> EventTarget = \"(self) => self.target\"\n\n///|\nextern \"js\" fn ffi_to_ui_event(x : @js.Value) -> @js.Nullable[UIEvent] =\n  #| (x) => x instanceof UIEvent ? x : null\n\n///|\nextern \"js\" fn ffi_to_clipboard_event(\n  x : @js.Value,\n) -> @js.Nullable[ClipboardEvent] =\n  #| (x) => x instanceof ClipboardEvent ? x : null\n\n///|\nextern \"js\" fn ffi_event_prevent_default(x : Event) = \"(self) => self.preventDefault()\"\n\n///|\nextern \"js\" fn ffi_event_stop_propagation(x : Event) = \"(self) => self.stopPropagation()\"\n\n///|\nextern \"js\" fn ffi_to_mouse_event(x : @js.Value) -> @js.Nullable[MouseEvent] =\n  #| (e) => e instanceof MouseEvent ? e : null\n\n///|\nextern \"js\" fn ffi_to_input_event(x : @js.Value) -> @js.Nullable[InputEvent] =\n  #| (e) => e instanceof InputEvent ? e : null\n\n///|\nextern \"js\" fn ffi_to_focus_event(x : @js.Value) -> @js.Nullable[FocusEvent] =\n  #| (e) => e instanceof FocusEvent ? e : null\n\n///|\nextern \"js\" fn ffi_to_keyboard_event(\n  x : @js.Value,\n) -> @js.Nullable[KeyboardEvent] =\n  #| (e) => e instanceof KeyboardEvent ? e : null\n\n///|\nextern \"js\" fn ffi_to_animation_event(\n  x : @js.Value,\n) -> @js.Nullable[AnimationEvent] =\n  #| (e) => e instanceof AnimationEvent ? e : null\n\n///|\nextern \"js\" fn ffi_to_before_unload_event(\n  x : @js.Value,\n) -> @js.Nullable[BeforeUnloadEvent] =\n  #| (e) => e instanceof BeforeUnloadEvent ? e : null\n\n///|\nextern \"js\" fn ffi_to_blob_event(x : @js.Value) -> @js.Nullable[BlobEvent] =\n  #| (e) => e instanceof BlobEvent ? e : null\n\n///|\nextern \"js\" fn ffi_to_close_event(x : @js.Value) -> @js.Nullable[CloseEvent] =\n  #| (e) => e instanceof CloseEvent ? e : null\n\n///|\nextern \"js\" fn ffi_to_composition_event(\n  x : @js.Value,\n) -> @js.Nullable[CompositionEvent] =\n  #| (e) => e instanceof CompositionEvent ? e : null\n\n///|\nextern \"js\" fn ffi_to_custom_event(x : @js.Value) -> @js.Nullable[CustomEvent] =\n  #| (e) => e instanceof CustomEvent ? e : null\n\n///|\nextern \"js\" fn ffi_to_drag_event(x : @js.Value) -> @js.Nullable[DragEvent] =\n  #| (e) => e instanceof DragEvent ? e : null\n\n///|\nextern \"js\" fn ffi_to_wheel_event(x : @js.Value) -> @js.Nullable[WheelEvent] =\n  #| (e) => e instanceof WheelEvent ? e : null\n\n///|\nextern \"js\" fn ffi_to_event(x : @js.Value) -> @js.Nullable[Event] =\n  #| (e) => e instanceof Event ? e : null\n","///|\n#external\ntype Element\n\n///|\npub trait IsElement: IsNode {\n  as_element(Self) -> Element = _\n  get_children(Self) -> Array[Element] = _\n  set_attribute(Self, String, String) -> Unit = _\n  get_attribute(Self, String) -> String = _\n  remove_attribute(Self, String) -> Unit = _\n  set_property(Self, String, @js.Value) -> Unit = _\n  get_property(Self, String) -> String = _\n  remove_property(Self, String) -> Unit = _\n  scroll_into_view(Self) -> Unit = _\n  get_scroll_top(Self) -> Double = _\n  set_scroll_top(Self, Double) -> Unit = _\n  get_scroll_left(Self) -> Double = _\n  set_scroll_left(Self, Double) -> Unit = _\n  get_scroll_width(Self) -> Double = _\n  get_scroll_height(Self) -> Double = _\n  set_inner_html(Self, String) -> Unit = _\n  get_bounding_client_rect(Self) -> DOMRect = _\n}\n\n///|\npub impl IsEventTarget for Element\n\n///|\npub impl @js.Cast for Element with into(value) {\n  value |> ffi_to_element |> _.to_option()\n}\n\n///|\npub impl @js.Cast for Element with from(value) {\n  value |> js_identity\n}\n\n///|\npub impl IsNode for Element\n\n///|\npub impl IsElement for Element\n\n///|\nimpl IsElement with as_element(s) {\n  js_identity(s)\n}\n\n///|\nimpl IsElement with get_children(s) {\n  s |> js_identity |> ffi_element_children\n}\n\n///|\nimpl IsElement with set_attribute(s, attr, value) {\n  s |> js_identity |> ffi_element_set_attribute(attr, value)\n}\n\n///|\nimpl IsElement with get_attribute(s, attr) {\n  s |> js_identity |> ffi_element_get_attribute(attr)\n}\n\n///|\nimpl IsElement with remove_attribute(s, attr) {\n  s |> js_identity |> ffi_element_remove_attribute(attr)\n}\n\n///|\nimpl IsElement with set_property(s, prop, value) {\n  s |> js_identity |> ffi_element_set_property(prop, value)\n}\n\n///|\nimpl IsElement with get_property(s, prop) {\n  s |> js_identity |> ffi_element_get_property(prop)\n}\n\n///|\nimpl IsElement with remove_property(s, prop) {\n  s |> js_identity |> ffi_element_remove_property(prop)\n}\n\n///|\nimpl IsElement with scroll_into_view(s) {\n  s |> js_identity |> ffi_element_scroll_into_view\n}\n\n///|\nimpl IsElement with get_scroll_top(s) {\n  s |> js_identity |> ffi_element_get_scroll_top\n}\n\n///|\nimpl IsElement with set_scroll_top(s, value) {\n  s |> js_identity |> ffi_element_set_scroll_top(value)\n}\n\n///|\nimpl IsElement with get_scroll_left(s) {\n  s |> js_identity |> ffi_element_get_scroll_left\n}\n\n///|\nimpl IsElement with set_scroll_left(s, value) {\n  s |> js_identity |> ffi_element_set_scroll_left(value)\n}\n\n///|\nimpl IsElement with get_scroll_width(s) {\n  s |> js_identity |> ffi_element_get_scroll_width\n}\n\n///|\nimpl IsElement with get_scroll_height(s) {\n  s |> js_identity |> ffi_element_get_scroll_height\n}\n\n///|\nimpl IsElement with set_inner_html(s, html) {\n  s |> js_identity |> ffi_element_set_inner_html(html)\n}\n\n///|\nimpl IsElement with get_bounding_client_rect(s) {\n  s |> js_identity |> ffi_element_get_bounding_client_rect\n}\n\n///|\nextern \"js\" fn ffi_element_children(x : @js.Value) -> Array[Element] =\n  #| (self) => self.children\n\n// NOTE: The DOM tree also includes the TEXT_NODE, which is not an element.\n// Therefore, a vdom patch algorithm should not be based on the ffi above.\n// https://dom.spec.whatwg.org/#ref-for-dom-node-nodetype%E2%91%A0\n\n///|\nextern \"js\" fn ffi_element_set_attribute(\n  x : @js.Value,\n  attr : String,\n  value : String,\n) = \"(self,attr,value) => self.setAttribute(attr, value)\"\n\n///|\nextern \"js\" fn ffi_element_get_attribute(\n  x : @js.Value,\n  attr : String,\n) -> String = \"(self,attr) => self.getAttribute(attr)\"\n\n///|\nextern \"js\" fn ffi_element_remove_attribute(x : @js.Value, attr : String) = \"(self,attr) => self.removeAttribute(attr)\"\n\n///|\nextern \"js\" fn ffi_element_set_property(\n  x : @js.Value,\n  prop : String,\n  value : @js.Value,\n) = \"(self,prop,value) => self[prop] = value\"\n\n///|\nextern \"js\" fn ffi_element_remove_property(x : @js.Value, prop : String) = \"(self,prop) => delete self[prop]\"\n\n///|\nextern \"js\" fn ffi_element_get_property(x : @js.Value, prop : String) -> String = \"(self,prop) => self[prop]\"\n\n///|\n/// https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView\nextern \"js\" fn ffi_element_scroll_into_view(x : @js.Value) = \"(self) => self.scrollIntoView()\"\n\n///|\n/// https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTop\nextern \"js\" fn ffi_element_get_scroll_top(x : @js.Value) -> Double = \"(self) => self.scrollTop\"\n\n///|\n/// https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTop\nextern \"js\" fn ffi_element_set_scroll_top(x : @js.Value, value : Double) = \"(s,v) => s.scrollTop = v\"\n\n///|\n/// https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollLeft\nextern \"js\" fn ffi_element_get_scroll_left(x : @js.Value) -> Double = \"(self) => self.scrollLeft\"\n\n///|\n/// https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollLeft\nextern \"js\" fn ffi_element_set_scroll_left(x : @js.Value, value : Double) = \"(s,v) => s.scrollLeft = v\"\n\n///|\n/// https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollWidth\nextern \"js\" fn ffi_element_get_scroll_width(x : @js.Value) -> Double = \"(self) => self.scrollWidth\"\n\n///|\n/// https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight\nextern \"js\" fn ffi_element_get_scroll_height(x : @js.Value) -> Double = \"(self) => self.scrollHeight\"\n\n///|\nextern \"js\" fn ffi_element_set_inner_html(x : @js.Value, html : String) -> Unit = \"(self,html) => self.innerHTML = html\"\n\n///|\nextern \"js\" fn ffi_element_get_bounding_client_rect(x : @js.Value) -> DOMRect =\n  #| (self) => self.getBoundingClientRect()\n","///|\nstruct Sandbox[Msg, Model, View] {\n  mut model : Model\n  update : (Msg, Model) -> (@cmd.Cmd[Msg], Model)\n  view : (Model) -> View\n  after_update : (View) -> Unit\n  on_url_changed : ((@url.Url) -> Msg)?\n  on_url_request : ((@url.UrlRequest) -> Msg)?\n  mut predefined : @cmd.Events[Msg]?\n}\n\n///|\n// used by vdom\npub fn[Msg, Model, View] Sandbox::get_predefined_events(\n  self : Sandbox[Msg, Model, View],\n) -> @cmd.Events[Msg] {\n  self.predefined.unwrap()\n}\n\n///|\n// used by vdom\npub fn[Msg, Model, View] Sandbox::get_on_url_changed(\n  self : Sandbox[Msg, Model, View],\n) -> ((@url.Url) -> Msg)? {\n  self.on_url_changed\n}\n\n///|\npub fn[Msg, Model, View] Sandbox::get_on_url_request(\n  self : Sandbox[Msg, Model, View],\n) -> ((@url.UrlRequest) -> Msg)? {\n  self.on_url_request\n}\n\n///|\n/// Update the model and launch commands.\npub fn[Msg, Model, View] Sandbox::update(\n  self : Sandbox[Msg, Model, View],\n  message : Msg,\n) -> Unit {\n  let (cmd, model) = (self.update)(message, self.model)\n  self.model = model\n  let view = (self.view)(self.model)\n  (self.after_update)(view)\n  // TODO: \n  // The command may trigger another message immediately, causing the VDOM to be generated twice.\n  // We need to optimize this.\n  self.launch(cmd)\n}\n\n///|\n/// Refresh the view.\n/// This function will call the view function and patch the result to the DOM.\npub fn[Msg, Model, View] Sandbox::refresh(\n  self : Sandbox[Msg, Model, View],\n) -> Unit {\n  let view = (self.view)(self.model)\n  (self.after_update)(view)\n}\n\n///|\npub fn[Model, Msg, View] Sandbox::new(\n  model : Model,\n  update : (Msg, Model) -> (@cmd.Cmd[Msg], Model),\n  view : (Model) -> View,\n  after_update~ : (View) -> Unit,\n  url_changed? : (@url.Url) -> Msg,\n  url_request? : (@url.UrlRequest) -> Msg,\n) -> Sandbox[Msg, Model, View] {\n  let sandbox = {\n    model,\n    update,\n    view,\n    after_update,\n    on_url_changed: url_changed,\n    on_url_request: url_request,\n    predefined: None,\n  }\n  let on_url_changed = match url_changed {\n    Some(f) => url => sandbox.update(f(url))\n    None => ignore\n  }\n  let on_url_request = match url_request {\n    Some(f) => url => sandbox.update(f(url))\n    None => ignore\n  }\n  @dom.window()\n  .to_event_target()\n  .add_event_listener(\"popstate\", _ => {\n    guard (try? @url.parse(@dom.window().current_url())) is Ok(url)\n    on_url_changed(url)\n  })\n  sandbox.predefined = Some(\n    @cmd.Events::new(on_url_changed, on_url_request, sandbox.update(_)),\n  )\n  sandbox\n}\n","///|\nenum Node[Msg] {\n  Node(\n    String,\n    namespace_uri~ : String?,\n    attrs~ : Array[Attribute[Msg]],\n    children~ : Array[Node[Msg]],\n    // Store the event listener used in real DOM\n    listeners~ : Array[(String, @dom.Listener)]\n  )\n  ExternalNode(\n    @dom.Node,\n    Ref[Array[Attribute[Msg]]?],\n    width~ : Int,\n    height~ : Int\n  )\n  Text(String)\n  Nothing\n}\n\n///|\n/// Convert msg type of Node.\n/// \n/// This is a expensive operation and should be used rarely.\npub fn[A, B] Node::map(self : Node[A], f : (A) -> B) -> Node[B] {\n  match self {\n    Node(tag, attrs~, children~, listeners~, namespace_uri~) => {\n      let attrs = attrs.map(_.map(f))\n      let children = children.map(_.map(f))\n      Node(tag, attrs~, children~, listeners~, namespace_uri~)\n    }\n    ExternalNode(node, attrs, width~, height~) => {\n      let attrs = attrs.map(_.map(_.map(_.map(f))))\n      ExternalNode(node, attrs, width~, height~)\n    }\n    Text(value) => Text(value)\n    Nothing => Nothing\n  }\n}\n\n///|\n/// Create a DOM node \npub fn[Msg] node(\n  tag : String,\n  attrs : Array[Attribute[Msg]],\n  children : Array[Node[Msg]],\n) -> Node[Msg] {\n  Node(tag, attrs~, children~, listeners=[], namespace_uri=None)\n}\n\n///|\npub fn[Msg] node_ns(\n  namespace_uri : String,\n  qualified_name : String,\n  attrs : Array[Attribute[Msg]],\n  children : Array[Node[Msg]],\n) -> Node[Msg] {\n  Node(\n    qualified_name,\n    attrs~,\n    children~,\n    listeners=[],\n    namespace_uri=Some(namespace_uri),\n  )\n}\n\n///|\nconst ESCAPED_LINK_TAG = \"RABBIT-TEA-ESCAPED-LINK\"\n\n///|\nconst NORMAL_LINK_TAG = \"a\"\n\n///|\n/// Create a link node.\n/// The `escape` parameter is used to create a link that will not trigger the `url_request` message.\npub fn[Msg] link(\n  attrs : Array[Attribute[Msg]],\n  children : Array[Node[Msg]],\n  escape? : Bool = false,\n) -> Node[Msg] {\n  let tag = if escape { ESCAPED_LINK_TAG } else { NORMAL_LINK_TAG }\n  node(tag, attrs, children)\n}\n\n///|\npub fn[Msg] external(\n  node : @dom.Node,\n  attrs : Ref[Array[Attribute[Msg]]?],\n  width~ : Int,\n  height~ : Int,\n) -> Node[Msg] {\n  ExternalNode(node, attrs, width~, height~)\n}\n\n///|\n/// Create a plain text\npub fn[Msg] text(value : String) -> Node[Msg] {\n  Text(value)\n}\n\n///|\n/// Create a dummy node\npub fn[Msg] nothing() -> Node[Msg] {\n  Nothing\n}\n\n///|\nstruct Attribute[Msg](String, AttrValue[Msg])\n\n///|\npriv enum AttrValue[Msg] {\n  AttrEvent(Handler[Msg])\n  AttrStyle(String)\n  AttrString(String)\n  // NOTE: Property is used to set the property of the element, this is different \n  // from the AttrString, which set the attribute of the element.\n  // See https://github.com/elm/html/blob/master/properties-vs-attributes.md\n  //\n  // Further more, the behavior of property may be different with attribute, even \n  // they have the same name. For example, if you set the `href` by `setAttribute`, the\n  // `href` will be the value you specified, but by property, the value will be \n  // resolved to an absolute URL. \n  AttrProperty(@variant.Variant)\n}\n\n///|\npub(all) enum Handler[Msg] {\n  Normal(Msg)\n  HandleEvent((@dom.Event) -> Msg)\n  Custom(Msg, stop_propagation~ : Bool, prevent_default~ : Bool)\n}\n\n///|\nfn[Msg] is_same_type(x : Node[Msg], y : Node[Msg]) -> Bool {\n  match (x, y) {\n    (Node(_), Node(_)) => true\n    (Text(_), Text(_)) => true\n    (Nothing, Nothing) => true\n    (ExternalNode(_), ExternalNode(_)) => true\n    _ => false\n  }\n}\n\n///|\n// pub impl[Msg] Eq for Handler[Msg] with op_equal(_a, _b) {\n//   false // TODO: implement this\n// }\n\n///|\n// impl[Msg] Eq for AttrValue[Msg] with op_equal(_a, _b) {\n//   false // TODO: implement this\n// }\n\n///|\n// impl[Msg] Eq for Attribute[Msg] with op_equal(_a, _b) {\n//   false // TODO: implement this\n// }\n\n///|\npub fn[A, B] Handler::map(self : Handler[A], f : (A) -> B) -> Handler[B] {\n  match self {\n    Normal(msg) => Normal(f(msg))\n    HandleEvent(g) => HandleEvent(event => event |> g |> f)\n    Custom(msg, stop_propagation~, prevent_default~) =>\n      Custom(f(msg), stop_propagation~, prevent_default~)\n  }\n}\n\n///|\npub fn[A, B] Attribute::map(self : Attribute[A], f : (A) -> B) -> Attribute[B] {\n  let value = match self.1 {\n    AttrEvent(handler) => AttrEvent(handler.map(f))\n    AttrStyle(value) => AttrStyle(value)\n    AttrString(value) => AttrString(value)\n    AttrProperty(value) => AttrProperty(value)\n  }\n  Attribute(self.0, value)\n}\n\n///|\n/// Get the inner tuple from Attribute\nfn[Msg] Attribute::inner(self : Attribute[Msg]) -> (String, AttrValue[Msg]) {\n  (self.0, self.1)\n}\n\n///|\n/// Create an custom event handler\npub fn[Msg] on(event : String, handler : Handler[Msg]) -> Attribute[Msg] {\n  Attribute(event, AttrEvent(handler))\n}\n\n///|\n/// Create an attribute\npub fn[Msg] attribute(key : String, value : String) -> Attribute[Msg] {\n  Attribute(key, AttrString(value))\n}\n\n///|\n/// Create an property\npub fn[Msg] property(key : String, value : @variant.Variant) -> Attribute[Msg] {\n  Attribute(key, AttrProperty(value))\n}\n\n///|\n/// Create an style attribute\npub fn[Msg] style(key : String, value : String) -> Attribute[Msg] {\n  Attribute(key, AttrStyle(value))\n}\n\n///|\n/// Convert virtual DOM to real DOM\nfn[Msg, Model, View] Node::to_node(\n  self : Node[Msg],\n  sandbox : @adapter.Sandbox[Msg, Model, View],\n) -> @dom.Node {\n  // NOTE:\n  // In Elm, the sandbox is a spacial type and handled in the runtime. But in Moonbit,\n  // the sandbox is just a normal type and handled in the user code. Because any operation\n  // in TEA require the state of sandbox, it cause the type parameter like Msg, Model, View \n  // to be passed around in API, very painful.\n  // \n  // This function require a sandbox value, and use closure to eliminate the type parameter.\n  fn attach_attrs(\n    attrs : Array[Attribute[Msg]],\n    element : @dom.Element,\n    generated_listeners : Array[(String, @dom.Listener)],\n  ) {\n    attrs.each(x => match x {\n      Attribute(event, AttrEvent(handler)) => {\n        let listener = match handler {\n          Normal(msg) => _ => sandbox.update(msg)\n          HandleEvent(f) => event => sandbox.update(f(event))\n          Custom(msg, stop_propagation~, prevent_default~) =>\n            fn(event : @dom.Event) { // TODO: remove this annotation will cause type error, why?\n              if stop_propagation {\n                event.stop_propagation()\n              }\n              if prevent_default {\n                event.prevent_default()\n              }\n              sandbox.update(msg)\n            }\n        }\n        element.add_event_listener(event, listener)\n        generated_listeners.push((event, listener))\n      }\n      Attribute(key, AttrString(value)) => element.set_attribute(key, value)\n      Attribute(key, AttrStyle(value)) =>\n        element.to_html_element().unwrap().get_style().set_property(key, value)\n      Attribute(key, AttrProperty(value)) =>\n        element.set_property(key, variant_to_js_value(value))\n    })\n  }\n\n  match self {\n    Node(tag, attrs~, children~, listeners~, namespace_uri~) => {\n      // NOTE:\n      // This is important for those who want to write a router in the app. \n      // When the `a` tag is clicked, the href is parsed and wrapped in \n      // the `url_request` message, then resent to the update function. \n      //\n      // If the `url_request` message was not provided, let the browser \n      // handle the click event.\n      // \n      // If the user hold the meta key or ctrl key, let the browser handle the click event.\n      let element = match (namespace_uri, sandbox.get_on_url_request(), tag) {\n        (Some(ns), _, _) => {\n          let element = @dom.document().create_element_ns(ns, tag)\n          attach_attrs(attrs, element, listeners)\n          element\n        }\n        (_, Some(url_request), NORMAL_LINK_TAG) => {\n          let element = @dom.document().create_element(tag)\n          attach_attrs(attrs, element, listeners)\n          element.add_event_listener(\"click\", event => {\n            let mouse_event = event\n              .to_ui_event()\n              .unwrap()\n              .to_mouse_event()\n              .unwrap()\n            if not(mouse_event.get_meta_key() || mouse_event.get_ctrl_key()) {\n              event.prevent_default()\n              let href = element.get_property(\"href\")\n              guard (try? @url.parse(@dom.window().current_url())) is Ok(curr)\n              guard (try? @url.parse(href)) is Ok(next)\n              let request = if curr.protocol == next.protocol &&\n                curr.host == next.host &&\n                curr.port == next.port {\n                @url.Internal(next)\n              } else {\n                External(href)\n              }\n              sandbox.update(url_request(request))\n            }\n          })\n          element\n        }\n        // We allow user to create a escaped link, which will not trigger the url_request message.\n        // This is useful when user want to create a link that jump to another site directly.\n        (_, _, ESCAPED_LINK_TAG) => {\n          let element = @dom.document().create_element(\"a\")\n          attach_attrs(attrs, element, listeners)\n          element\n        }\n        _ => {\n          let element = @dom.document().create_element(tag)\n          attach_attrs(attrs, element, listeners)\n          element\n        }\n      }\n      for child in children {\n        element.append_child(child.to_node(sandbox))\n      }\n      element.as_node()\n    }\n    ExternalNode(node, attrs, width~, height~) => {\n      match attrs.val {\n        Some(xs) => {\n          attach_attrs(xs, node.to_element().unwrap(), [])\n          attrs.val = None\n        }\n        None => ()\n      }\n      let element = @dom.document().create_element(\"div\")\n      element\n      .to_html_element()\n      .unwrap()\n      .get_style()\n      ..set_property(\"width\", width.to_string())\n      ..set_property(\"height\", height.to_string())\n      element..append_child(node).as_node()\n    }\n    Text(value) => @dom.document().create_text_node(value).as_node()\n    Nothing => @dom.document().create_text_node(\"\").as_node()\n  }\n}\n\n///|\npub fn variant_to_js_value(value : @variant.Variant) -> @js.Value {\n  match value {\n    String(value) => @js.Value::cast_from(value)\n    Floating(value) => @js.Value::cast_from(value)\n    Integer(value) => @js.Value::cast_from(value)\n    Boolean(value) => @js.Value::cast_from(value)\n  }\n}\n\n///|\npub fn[Msg, Model, View] Node::patch(\n  self : Node[Msg],\n  old : Node[Msg],\n  sandbox : @adapter.Sandbox[Msg, Model, View],\n  mount~ : String,\n) -> Unit {\n  let patches = diff(old, self)\n  fn aux(patches : Patch[Msg], current : @dom.Node) -> Unit {\n    match patches {\n      Drop(index, length) =>\n        for i in 0..<length {\n          current.remove_child(current.get_child(index))\n        }\n      Remove(index) => current.remove_child(current.get_child(index))\n      Replace(index, node) =>\n        current.replace_child(node.to_node(sandbox), current.get_child(index))\n      InsertBefore(index, node) =>\n        if current.get_child_count() == 0 {\n          current.append_child(node.to_node(sandbox))\n        } else {\n          current.insert_before(node.to_node(sandbox), current.get_child(index))\n        }\n      Append(nodes) =>\n        for node in nodes {\n          current.append_child(node.to_node(sandbox))\n        }\n      Update(update) =>\n        match update {\n          UpdateNode(index, attrs_patches, childs_patches, new_listeners) => {\n            let node = current.get_child(index)\n            let element = node.to_element().unwrap()\n            for patch in attrs_patches {\n              match patch {\n                AttrRemove(key) => element.remove_attribute(key)\n                AttrAdd(key, value) => element.set_attribute(key, value)\n                StyleAdd(key, value) => {\n                  let element = element.to_html_element().unwrap()\n                  element.get_style().set_property(key, value)\n                }\n                StyleRemove(key) => {\n                  let element = element.to_html_element().unwrap()\n                  ignore(element.get_style().remove_property(key))\n                }\n                PropertyAdd(key, value) =>\n                  element.set_property(key, variant_to_js_value(value))\n                PropertyRemove(key) => element.remove_property(key)\n                EventRemove(key, listener) =>\n                  element.as_event_target().remove_event_listener(key, listener)\n                EventAdd(key, handler) => {\n                  let listener = match handler {\n                    Normal(msg) => _ => sandbox.update(msg)\n                    HandleEvent(f) => event => sandbox.update(f(event))\n                    Custom(msg, stop_propagation~, prevent_default~) =>\n                      fn(event : @dom.Event) {\n                        if stop_propagation {\n                          event.stop_propagation()\n                        }\n                        if prevent_default {\n                          event.prevent_default()\n                        }\n                        sandbox.update(msg)\n                      }\n                  }\n                  element.add_event_listener(key, listener)\n                  new_listeners.push((key, listener))\n                }\n              }\n            }\n            for patch in childs_patches {\n              aux(patch, node)\n            }\n          }\n          UpdateText(index, value) => {\n            let text_node = @dom.document().create_text_node(value)\n            current.replace_child(text_node.as_node(), current.get_child(index))\n          }\n        }\n    }\n  }\n\n  let root = @dom.document().get_element_by_id(mount).unwrap().as_node()\n  aux(patches, root)\n}\n\n///|\npriv enum AttrsUpdate[Msg] {\n  AttrRemove(String)\n  AttrAdd(String, String)\n  StyleAdd(String, String)\n  StyleRemove(String)\n  PropertyAdd(String, @variant.Variant)\n  PropertyRemove(String)\n  EventRemove(String, @dom.Listener)\n  EventAdd(String, Handler[Msg])\n}\n\n///|\nenum Patch[Msg] {\n  Drop(Int, Int)\n  Remove(Int)\n  Replace(Int, Node[Msg])\n  InsertBefore(Int, Node[Msg])\n  Append(Array[Node[Msg]])\n  Update(Update[Msg])\n}\n\n///|\ntest {\n  // TODO: this is used to suppress unused warnings. Remove this later.\n  ignore((Patch::Remove(_) : (Int) -> Patch[Unit]))\n  ignore((Patch::InsertBefore(_, _) : (Int, Node[Unit]) -> Patch[Unit]))\n}\n\n///|\npriv enum Update[Msg] {\n  UpdateNode(\n    Int,\n    Array[AttrsUpdate[Msg]],\n    Array[Patch[Msg]],\n    Array[(String, @dom.Listener)]\n  )\n  UpdateText(Int, String)\n}\n\n///|\n/// Now the root node must be a Node\npub fn[Msg] diff(root_old : Node[Msg], root_new : Node[Msg]) -> Patch[Msg] {\n  guard root_old is Node(_, attrs=attrs_old, listeners~, ..)\n  guard root_new is Node(_, attrs=attrs_new, ..)\n  Update(\n    UpdateNode(\n      0,\n      attrs_diff(attrs_old, attrs_new, listeners),\n      do_diff(root_old, root_new),\n      [],\n    ),\n  )\n}\n\n///|\npub fn[Msg] do_diff(old : Node[Msg], new : Node[Msg]) -> Array[Patch[Msg]] {\n  let children_old = match old {\n    Node(_, children~, ..) => children\n    _ => abort(\"old is not a node or fragment\")\n  }\n  let children_new = match new {\n    Node(_, children~, ..) => children\n    _ => abort(\"new is not a node or fragment\")\n  }\n  if children_old.length() == 0 && children_new.length() == 0 {\n    []\n  } else {\n    diff_without_key(children_old, children_new)\n  }\n}\n\n// To be improved!!! Now this implementation will affect the performance of the diff algorithm.\n// And If a AttributeString's name is same as a AttrEvent's name, the diff algorithm will not work.\n// Now we think the events is different although they never changed.\n\n///|\nfn[Msg] attrs_diff(\n  old : Array[Attribute[Msg]],\n  new : Array[Attribute[Msg]],\n  // We think the event is different although they never changed.\n  // The listeners is used to remove the event listener when the attribute is removed.\n  listeners : Array[(String, @dom.Listener)],\n) -> Array[AttrsUpdate[Msg]] {\n  let old_map = Map::from_iter(old.iter().map(x => x.inner()))\n  let new_map = Map::from_iter(new.iter().map(x => x.inner()))\n  let result = []\n  for x in listeners {\n    result.push(EventRemove(x.0, x.1))\n  }\n  for key, value in old_map {\n    match value {\n      // We think the event is different although they never changed.\n      AttrEvent(_) => ()\n      AttrStyle(value) =>\n        if new_map.contains(key) {\n          // FIXME: avoid unwrap and guard let\n          guard new_map.get(key).unwrap() is AttrStyle(value_new)\n          if value != value_new {\n            result.push(StyleAdd(key, value_new))\n          }\n        } else {\n          result.push(StyleRemove(key))\n        }\n      AttrString(value) =>\n        if new_map.contains(key) {\n          // FIXME: avoid unwrap and guard let\n          guard new_map.get(key).unwrap() is AttrString(value_new)\n          if value != value_new {\n            result.push(AttrAdd(key, value_new))\n          }\n        } else {\n          result.push(AttrRemove(key))\n        }\n      AttrProperty(value) =>\n        if new_map.contains(key) {\n          // FIXME: avoid unwrap and guard let\n          guard new_map.get(key).unwrap() is AttrProperty(value_new)\n          if value != value_new {\n            result.push(PropertyAdd(key, value_new))\n          }\n        } else {\n          result.push(PropertyRemove(key))\n        }\n    }\n  }\n  for key, value in new_map {\n    match value {\n      // We think the event is different although they never changed.\n      AttrEvent(handler) => result.push(EventAdd(key, handler))\n      AttrStyle(value) =>\n        if not(old_map.contains(key)) {\n          result.push(StyleAdd(key, value))\n        }\n      AttrString(value) =>\n        if not(old_map.contains(key)) {\n          result.push(AttrAdd(key, value))\n        }\n      AttrProperty(value) =>\n        if not(old_map.contains(key)) {\n          result.push(PropertyAdd(key, value))\n        }\n    }\n  }\n  result\n}\n\n///|\npub fn[Msg] diff_without_key(\n  old : Array[Node[Msg]],\n  new : Array[Node[Msg]],\n) -> Array[Patch[Msg]] {\n  fn aux(\n    xs : ArrayView[Node[Msg]],\n    ys : ArrayView[Node[Msg]],\n    patches : Array[Patch[Msg]],\n    index : Int,\n  ) -> Unit {\n    match (xs, ys) {\n      ([], []) => ()\n      ([], tl) => patches.push(Append(tl.map(x => x)))\n      (l, []) => patches.push(Drop(index, l.length()))\n      ([x, .. tl1], [y, .. tl2]) => {\n        if is_same_type(x, y) {\n          match (x, y) {\n            (\n              Node(taga, attrs=xattrs, listeners~, ..),\n              Node(tagb, attrs=yattrs, listeners=new_listeners, ..),\n            ) =>\n              if taga == tagb {\n                let attrs_patches = attrs_diff(xattrs, yattrs, listeners)\n                let childs_patches = do_diff(x, y)\n                if attrs_patches.length() > 0 || childs_patches.length() > 0 {\n                  patches.push(\n                    Update(\n                      UpdateNode(\n                        index, attrs_patches, childs_patches, new_listeners,\n                      ),\n                    ),\n                  )\n                }\n              } else {\n                patches.push(Replace(index, y))\n              }\n            (ExternalNode(_), ExternalNode(_)) =>\n              patches.push(Replace(index, y))\n            (Text(value_a), Text(value_b)) =>\n              if value_a != value_b {\n                patches.push(Update(UpdateText(index, value_b)))\n              }\n            _ => ()\n          }\n        } else {\n          patches.push(Replace(index, y))\n        }\n        aux(tl1, tl2, patches, index + 1)\n      }\n    }\n  }\n\n  let patches = []\n  aux(old[:], new[:], patches, 0)\n  patches\n}\n","///|\n#alias(T)\npub(all) struct Html[Msg](@vdom.Node[Msg])\n\n///|\n/// Convert msg type of Html.\n/// \n/// This is a expensive operation and should be used rarely.\npub fn[A, B] Html::map(self : Html[A], f : (A) -> B) -> Html[B] {\n  self.0.map(f)\n}\n\n///|\npub fn[Msg] Html::to_virtual_dom(self : Html[Msg]) -> @vdom.Node[Msg] {\n  // Wrap the node with a root node. This node represents the root of the real DOM managed by TEA.\n  node(\"root\", [], [self]).0\n}\n\n///|\npub fn[Msg] node(\n  tag : String,\n  attributes : Array[Attribute[Msg]],\n  children : Array[Html[Msg]],\n) -> Html[Msg] {\n  @vdom.node(tag, attributes.map(x => x.0), children.map(x => x.0))\n}\n\n///|\nfn[Msg] common_node(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  tag : String,\n  attributes : Array[Attribute[Msg]],\n  children : Array[Html[Msg]],\n) -> Html[Msg] {\n  let attrs = []\n  if style.length() > 0 {\n    attrs.push(attribute(\"style\", style.join(\";\")))\n  }\n  if class is Some(class) {\n    attrs.push(attribute(\"class\", class))\n  }\n  if id is Some(id) {\n    attrs.push(attribute(\"id\", id))\n  }\n  node(tag, attributes + attrs, children)\n}\n\n///|\n/// Represents an empty element\npub fn[M] nothing() -> Html[M] {\n  @vdom.nothing()\n}\n\n///|\npub fn[M] button(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  click? : M,\n  children : Array[Html[M]],\n) -> Html[M] {\n  let attrs = []\n  if click is Some(click) {\n    attrs.push(on_click(_ => click))\n  }\n  common_node(style~, class?, id?, \"button\", attrs, children)\n}\n\n///|\npub fn[M] h1(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  common_node(style~, class?, id?, \"h1\", [], children)\n}\n\n///|\npub fn[M] h2(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  common_node(style~, class?, id?, \"h2\", [], children)\n}\n\n///|\npub fn[M] h3(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  common_node(style~, class?, id?, \"h3\", [], children)\n}\n\n///|\npub fn[M] h4(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  common_node(style~, class?, id?, \"h4\", [], children)\n}\n\n///|\npub fn[M] h5(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  common_node(style~, class?, id?, \"h5\", [], children)\n}\n\n///|\npub fn[M] h6(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  common_node(style~, class?, id?, \"h6\", [], children)\n}\n\n// ------ grouping content ------\n\n///|\npub fn[M] div(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  click? : M,\n  children : Array[Html[M]],\n) -> Html[M] {\n  let attrs = []\n  if click is Some(click) {\n    attrs.push(on_click(_ => click))\n  }\n  common_node(style~, class?, id?, \"div\", attrs, children)\n}\n\n///|\npub fn[M] p(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  common_node(style~, class?, id?, \"p\", [], children)\n}\n\n///|\npub fn[M] hr(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  children? : Array[Html[M]] = [],\n) -> Html[M] {\n  common_node(style~, class?, id?, \"hr\", [], children)\n}\n\n///|\npub fn[M] pre(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  common_node(style~, class?, id?, \"pre\", [], children)\n}\n\n///|\npub fn[M] blockquote(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  common_node(style~, class?, id?, \"blockquote\", [], children)\n}\n\n///|\npub fn[M] section(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  common_node(style~, class?, id?, \"section\", [], children)\n}\n\n// ---- text ----\n\n///|\npub fn[M] span(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  common_node(style~, class?, id?, \"span\", [], children)\n}\n\n///|\n/// Create `a` element.\n/// \n/// # Parameters\n/// \n/// - `escape`: an optional boolean that determines whether the link \n///  should be escaped. By default, it is set to `false`. \n/// \n///   When `escape` is set to `true`, clicking the escaped link will cause the browser \n///   to immediately navigate to the `href` target, bypassing any interception logic. \n///   As a result, the `UrlRequest` message will not be triggered.\n/// \n/// - `target`: an optional `Target` that specifies where to open the link.\n/// \n/// If the user holds the `ctrl` key (or the command key on macOS) while clicking the link,\n/// the click event will be handled by the browser, and the `UrlRequest` will not be triggered either.\npub fn[M] a(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  href~ : String,\n  target? : Target = Self,\n  children : Array[Html[M]],\n  escape? : Bool = false,\n) -> Html[M] {\n  let attrs = [\n    @vdom.attribute(\"href\", href),\n    @vdom.attribute(\"target\", target.to_string()),\n  ]\n  if style.length() > 0 {\n    attrs.push(@vdom.attribute(\"style\", style.join(\";\")))\n  }\n  if class is Some(class) {\n    attrs.push(@vdom.attribute(\"class\", class))\n  }\n  if id is Some(id) {\n    attrs.push(@vdom.attribute(\"id\", id))\n  }\n  @vdom.link(attrs, children.map(x => x.0), escape~)\n}\n\n///|\npub fn[M] code(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  common_node(style~, class?, id?, \"code\", [], children)\n}\n\n///|\npub fn[M] em(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  common_node(style~, class?, id?, \"em\", [], children)\n}\n\n///|\npub fn[M] strong(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  common_node(style~, class?, id?, \"strong\", [], children)\n}\n\n///|\npub fn[M] i(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  common_node(style~, class?, id?, \"i\", [], children)\n}\n\n///|\npub fn[M] b(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  common_node(style~, class?, id?, \"b\", [], children)\n}\n\n///|\npub fn[M] u(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  common_node(style~, class?, id?, \"u\", [], children)\n}\n\n///|\npub fn[M] sub(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  common_node(style~, class?, id?, \"sub\", [], children)\n}\n\n///|\npub fn[M] sup(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  common_node(style~, class?, id?, \"sup\", [], children)\n}\n\n///|\npub fn[Msg] text(str : String) -> Html[Msg] {\n  @vdom.text(str)\n}\n\n// ---- lists ----\n\n///|\npub fn[M] ul(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  click? : M,\n  children : Array[Html[M]],\n) -> Html[M] {\n  let attrs = []\n  if click is Some(click) {\n    attrs.push(on_click(_ => click))\n  }\n  common_node(style~, class?, id?, \"ul\", attrs, children)\n}\n\n///|\n/// Notice that the `type` attribute for `ol` is not important for the browser now.\n/// If you want to change the type of the list, you should use the `list-style-type` property in CSS.\npub fn[M] ol(\n  style? : Array[String] = [],\n  reversed? : Bool,\n  start? : Int,\n  id? : String,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  let attrs = []\n  if reversed is Some(reversed) {\n    // TODO: test this attribute\n    attrs.push(attribute(\"reversed\", reversed.to_string()))\n  }\n  if start is Some(start) {\n    // TODO: test this attribute\n    attrs.push(attribute(\"start\", start.to_string()))\n  }\n  common_node(style~, class?, id?, \"ol\", attrs, children)\n}\n\n///|\npub fn[M] li(\n  style? : Array[String] = [],\n  value? : Int,\n  id? : String,\n  class? : String,\n  click? : M,\n  children : Array[Html[M]],\n) -> Html[M] {\n  let attrs = []\n  if click is Some(click) {\n    attrs.push(on_click(_ => click))\n  }\n  if value is Some(value) {\n    attrs.push(attribute(\"value\", value.to_string()))\n  }\n  common_node(style~, class?, id?, \"li\", attrs, children)\n}\n\n///|\npub fn[M] dl(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  common_node(style~, class?, id?, \"dl\", [], children)\n}\n\n///|\npub fn[M] dt(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  common_node(style~, class?, id?, \"dt\", [], children)\n}\n\n///|\npub fn[M] dd(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  common_node(style~, class?, id?, \"dd\", [], children)\n}\n\n// ---- embbded content ----\n\n///|\npub fn[M] img(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  src? : String,\n  alt? : String,\n  title? : String,\n  width? : Int,\n  height? : Int,\n  border? : Int,\n  children : Array[Html[M]],\n) -> Html[M] {\n  let attrs = []\n  if src is Some(src) {\n    attrs.push(attribute(\"src\", src))\n  }\n  if alt is Some(alt) {\n    attrs.push(attribute(\"alt\", alt))\n  }\n  if title is Some(title) {\n    attrs.push(attribute(\"title\", title))\n  }\n  if width is Some(width) {\n    attrs.push(attribute(\"width\", width.to_string()))\n  }\n  if height is Some(height) {\n    attrs.push(attribute(\"height\", height.to_string()))\n  }\n  if border is Some(border) {\n    attrs.push(attribute(\"border\", border.to_string()))\n  }\n  common_node(style~, class?, id?, \"img\", attrs, children)\n}\n\n///|\npub fn[M] iframe(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  src? : String,\n  title? : String,\n  width? : Int,\n  height? : Int,\n) -> Html[M] {\n  let attrs = []\n  if src is Some(src) {\n    attrs.push(attribute(\"src\", src))\n  }\n  if title is Some(title) {\n    attrs.push(attribute(\"title\", title))\n  }\n  if width is Some(width) {\n    attrs.push(attribute(\"width\", width.to_string()))\n  }\n  if height is Some(height) {\n    attrs.push(attribute(\"height\", height.to_string()))\n  }\n  common_node(style~, class?, id?, \"iframe\", attrs, [])\n}\n\n// ---- inputs ----\n\n///|\npub fn[M] br(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n) -> Html[M] {\n  common_node(style~, class?, id?, \"br\", [], [])\n}\n\n///|\npub(all) enum InputType {\n  Button\n  Checkbox\n  Color\n  Date\n  DateTimeLocal\n  Email\n  File\n  Hidden\n  Image\n  Month\n  Number\n  Password\n  Radio\n  Range\n  Reset\n  Search\n  Submit\n  Tel\n  Text\n  Time\n  Url\n  Week\n}\n\n///|\npub(all) enum AutoComplete {\n  On\n  Off\n}\n\n///|\npub fn[M] form(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  action? : String,\n  name? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  let attrs = []\n  if action is Some(action) {\n    attrs.push(attribute(\"action\", action))\n  }\n  if name is Some(name) {\n    attrs.push(attribute(\"name\", name))\n  }\n  common_node(style~, class?, id?, \"form\", attrs, children)\n}\n\n///|\npub fn[M] label(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  for_? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  let attrs = []\n  if for_ is Some(for_) {\n    attrs.push(attribute(\"for\", for_))\n  }\n  common_node(style~, class?, id?, \"label\", attrs, children)\n}\n\n///|\npub fn[M] input(\n  input_type? : InputType = Text,\n  name? : String,\n  value? : String,\n  checked? : Bool,\n  read_only? : Bool,\n  multiple? : Bool,\n  accept? : String,\n  placeholder? : String,\n  auto_complete? : AutoComplete,\n  style? : Array[String] = [],\n  max? : Int,\n  min? : Int,\n  step? : Int,\n  maxlength? : Int,\n  minlength? : Int,\n  pattern? : String,\n  size? : Int,\n  width? : Int,\n  height? : Int,\n  id? : String,\n  class? : String,\n  children? : Array[Html[M]] = [],\n  change? : (String) -> M,\n  input? : (String) -> M,\n) -> Html[M] {\n  let input_type = match input_type {\n    Button => \"button\"\n    Checkbox => \"checkbox\"\n    Color => \"color\"\n    Date => \"date\"\n    DateTimeLocal => \"datetime-local\"\n    Email => \"email\"\n    File => \"file\"\n    Hidden => \"hidden\"\n    Image => \"image\"\n    Month => \"month\"\n    Number => \"number\"\n    Password => \"password\"\n    Radio => \"radio\"\n    Range => \"range\"\n    Reset => \"reset\"\n    Search => \"search\"\n    Submit => \"submit\"\n    Tel => \"tel\"\n    Text => \"text\"\n    Time => \"time\"\n    Url => \"url\"\n    Week => \"week\"\n  }\n  let auto_complete = match auto_complete {\n    Some(On) => \"on\"\n    _ => \"off\"\n  }\n  let attrs = []\n  attrs.push(attribute(\"type\", input_type))\n  attrs.push(attribute(\"autocomplete\", auto_complete))\n  if name is Some(name) {\n    attrs.push(attribute(\"name\", name))\n  }\n  if value is Some(value) {\n    attrs.push(property(\"value\", String(value)))\n  }\n  if checked is Some(checked) {\n    attrs.push(property(\"checked\", Boolean(checked)))\n  }\n  if read_only is Some(read_only) {\n    attrs.push(property(\"readonly\", Boolean(read_only)))\n  }\n  if multiple is Some(multiple) {\n    attrs.push(property(\"multiple\", Boolean(multiple)))\n  }\n  if accept is Some(accept) {\n    attrs.push(attribute(\"accept\", accept))\n  }\n  if max is Some(max) {\n    attrs.push(attribute(\"max\", max.to_string()))\n  }\n  if min is Some(min) {\n    attrs.push(attribute(\"min\", min.to_string()))\n  }\n  if step is Some(step) {\n    attrs.push(attribute(\"step\", step.to_string()))\n  }\n  if maxlength is Some(maxlength) {\n    attrs.push(attribute(\"maxlength\", maxlength.to_string()))\n  }\n  if minlength is Some(minlength) {\n    attrs.push(attribute(\"minlength\", minlength.to_string()))\n  }\n  if pattern is Some(pattern) {\n    attrs.push(attribute(\"pattern\", pattern))\n  }\n  if size is Some(size) {\n    attrs.push(attribute(\"size\", size.to_string()))\n  }\n  if width is Some(width) {\n    attrs.push(attribute(\"width\", width.to_string()))\n  }\n  if height is Some(height) {\n    attrs.push(attribute(\"height\", height.to_string()))\n  }\n  if placeholder is Some(placeholder) {\n    attrs.push(attribute(\"placeholder\", placeholder))\n  }\n  if change is Some(to_msg) {\n    attrs.push(on_change(to_msg))\n  }\n  if input is Some(to_msg) {\n    attrs.push(on_input(to_msg))\n  }\n  common_node(\"input\", attrs, children, style~, id?, class?)\n}\n\n///|\npub fn[M] select(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  disabled? : Bool,\n  name? : String,\n  change? : (String) -> M,\n  children : Array[Html[M]],\n) -> Html[M] {\n  // TODO: support more attribute for select tag\n  let attrs = []\n  if style.length() > 0 {\n    attrs.push(attribute(\"style\", style.join(\";\")))\n  }\n  if id is Some(id) {\n    attrs.push(attribute(\"id\", id))\n  }\n  if class is Some(class) {\n    attrs.push(attribute(\"class\", class))\n  }\n  if disabled is Some(value) {\n    attrs.push(property(\"disabled\", Boolean(value)))\n  }\n  if name is Some(name) {\n    attrs.push(attribute(\"name\", name))\n  }\n  if change is Some(to_msg) {\n    attrs.push(on_change(to_msg))\n  }\n  node(\"select\", attrs, children)\n}\n\n///|\npub fn[M] option(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  disabled? : Bool,\n  value? : String,\n  selected? : Bool = false,\n  children : Array[Html[M]],\n) -> Html[M] {\n  // TODO: support more attribute for option tag\n\n  let attrs = []\n  if style.length() > 0 {\n    attrs.push(attribute(\"style\", style.join(\";\")))\n  }\n  if id is Some(id) {\n    attrs.push(attribute(\"id\", id))\n  }\n  if class is Some(class) {\n    attrs.push(attribute(\"class\", class))\n  }\n  if disabled is Some(value) {\n    attrs.push(property(\"disabled\", Boolean(value)))\n  }\n  if value is Some(value) {\n    attrs.push(attribute(\"value\", value))\n  }\n  attrs.push(property(\"selected\", Boolean(selected)))\n  node(\"option\", attrs, children)\n}\n\n///|\npub fn[Msg] external(\n  node : @dom.Node,\n  attrs : Ref[Array[Attribute[Msg]]?],\n  width~ : Int,\n  height~ : Int,\n) -> Html[Msg] {\n  let attrs = attrs.map(_.map(_.map(x => x.0)))\n  @vdom.external(node, attrs, width~, height~)\n}\n\n// table\n\n///|\npub fn[M] table(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  common_node(\"table\", [], style~, id?, class?, children)\n}\n\n///|\npub fn[M] caption(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  common_node(\"caption\", [], style~, id?, class?, children)\n}\n\n///|\npub fn[M] thead(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  common_node(\"thead\", [], style~, id?, class?, children)\n}\n\n///|\npub fn[M] tbody(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  common_node(\"tbody\", [], style~, id?, class?, children)\n}\n\n///|\npub fn[M] col(\n  style? : Array[String] = [],\n  id? : String,\n  span? : Int,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  let attrs = []\n  if span is Some(span) {\n    attrs.push(attribute(\"span\", span.to_string()))\n  }\n  common_node(\"col\", attrs, style~, id?, class?, children)\n}\n\n///|\npub fn[M] colgroup(\n  style? : Array[String] = [],\n  id? : String,\n  span? : Int,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  let attrs = []\n  if span is Some(span) {\n    attrs.push(attribute(\"span\", span.to_string()))\n  }\n  common_node(\"colgroup\", attrs, style~, id?, class?, children)\n}\n\n///|\npub fn[M] tr(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  common_node(\"tr\", [], style~, id?, class?, children)\n}\n\n///|\npub fn[M] td(\n  style? : Array[String] = [],\n  id? : String,\n  colspan? : Int,\n  rowspan? : Int,\n  headers? : String,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  let attrs = []\n  if colspan is Some(colspan) {\n    attrs.push(attribute(\"colspan\", colspan.to_string()))\n  }\n  if rowspan is Some(rowspan) {\n    attrs.push(attribute(\"rowspan\", rowspan.to_string()))\n  }\n  if headers is Some(headers) {\n    attrs.push(attribute(\"headers\", headers))\n  }\n  common_node(\"td\", attrs, style~, id?, class?, children)\n}\n\n///|\npub(all) enum Scope {\n  Row\n  Col\n  RowGroup\n  ColGroup\n}\n\n///|\npub fn[M] th(\n  style? : Array[String] = [],\n  id? : String,\n  abbr? : String,\n  colspan? : Int,\n  rowspan? : Int,\n  headers? : String,\n  scope? : Scope,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  let attrs = []\n  if colspan is Some(colspan) {\n    attrs.push(attribute(\"colspan\", colspan.to_string()))\n  }\n  if rowspan is Some(rowspan) {\n    attrs.push(attribute(\"rowspan\", rowspan.to_string()))\n  }\n  if headers is Some(headers) {\n    attrs.push(attribute(\"headers\", headers))\n  }\n  if abbr is Some(abbr) {\n    attrs.push(attribute(\"abbr\", abbr))\n  }\n  if scope is Some(scope) {\n    attrs.push(\n      attribute(\n        \"scope\",\n        match scope {\n          Row => \"row\"\n          Col => \"col\"\n          RowGroup => \"rowgroup\"\n          ColGroup => \"colgroup\"\n        },\n      ),\n    )\n  }\n  common_node(\"th\", attrs, style~, id?, class?, children)\n}\n\n///|\npub fn[M] tfoot(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  children : Array[Html[M]],\n) -> Html[M] {\n  common_node(\"tfoot\", [], style~, id?, class?, children)\n}\n\n///|\n/// Dialog element. \n/// \n/// Hint: You can use the `show` and `close` commands in the `@dialog` package\n/// to manipulate the dialog.\n///\n/// # Attributes\n/// \n/// - `open`: indicates whether the dialog is open or closed by default.\n/// \n/// # Messages\n/// \n/// - `close`: triggered when the dialog is closed. \n///   \n///   The string payload of the `close` message is the return value of the dialog.\n/// \n/// - `cancel`: triggered when the user instructs the browser that they wish to \n///   dismiss the current open dialog.\n/// \n///   It can be triggered when the user presses `esc` or uses the `request_close` command.\n/// \n///   If the `cancel` argument is provided, **the dialog will not close automatically** \n///   after this message is triggered. You can use the `@dialog.close` command \n///   to close it or `@cmd.none` to keep it open.\n/// \n/// # Example\n/// \n/// ```moonbit skip\n/// typealias Model = String\n/// \n/// enum Msg {\n///   Open\n///   Closed(String)\n///   YesNo(Bool)\n/// }\n/// \n/// fn update(msg : Msg, model : Model) -> (Cmd[Msg], Model) {\n///   match msg {\n///     Open => (@dialog.show(\"confirm\"), model)\n///     YesNo(answer) => (@dialog.close(\"confirm\", return_value=answer.to_string()), model) \n///     Closed(value) => (none(), value)\n///   }\n/// }\n/// \n/// fn view(model : Model) -> Html[Msg] {\n///   div([\n///     h1([text(model)]),\n///     button(click=Msg::Open, [text(\"open\")]),\n///     dialog(id=\"confirm\", close=Msg::Closed, [\n///       p([text(\"Are you sure?\")]),\n///       button(click=YesNo(true), [text(\"Yes\")]),\n///       button(click=YesNo(false), [text(\"No\")]),\n///     ]),\n///   ])\n/// }\n/// ```\n/// \npub fn[M] dialog(\n  style? : Array[String] = [],\n  id? : String,\n  class? : String,\n  open? : Bool,\n  close? : (String) -> M,\n  cancel? : M,\n  children : Array[Html[M]],\n) -> Html[M] {\n  let attrs = []\n  if open is Some(open) {\n    attrs.push(property(\"open\", Boolean(open)))\n  }\n  if close is Some(close) {\n    attrs.push(\n      @vdom.on(\n        \"close\",\n        HandleEvent(event => {\n          let html_element = event\n            .target()\n            .to_node()\n            .unwrap()\n            .to_element()\n            .unwrap()\n            .to_html_element()\n            .unwrap()\n            .to_html_dialog_element()\n            .unwrap()\n          close(html_element.return_value())\n        }),\n      ),\n    )\n  }\n  if cancel is Some(cancel) {\n    attrs.push(\n      @vdom.on(\n        \"cancel\",\n        HandleEvent(event => {\n          event.prevent_default()\n          cancel\n        }),\n      ),\n    )\n  }\n  common_node(\"dialog\", attrs, style~, id?, class?, children)\n}\n","///|\nstruct Attribute[Msg](@vdom.Attribute[Msg])\n\n///|\n/// Specify an style\npub fn[Msg] style(key : String, value : String) -> Attribute[Msg] {\n  @vdom.style(key, value)\n}\n\n///|\npub fn[Msg] attribute(key : String, value : String) -> Attribute[Msg] {\n  @vdom.attribute(key, value)\n}\n\n///|\npub fn[M] property(key : String, value : @variant.Variant) -> Attribute[M] {\n  @vdom.property(key, value)\n}\n\n///|\npub fn[Msg] href(value : String) -> Attribute[Msg] {\n  // Note: `href` will be the value you specified, but by property, the value \n  // will be resolved to an absolute URL.\n  @vdom.property(\"href\", @variant.String(value))\n}\n\n///|\npub(all) enum Target {\n  Self\n  Blank\n}\n\n///|\nfn Target::to_string(self : Target) -> String {\n  match self {\n    Self => \"_self\"\n    Blank => \"_blank\"\n  }\n}\n\n///|\npub fn[Msg] target(value : Target) -> Attribute[Msg] {\n  @vdom.attribute(\"target\", value.to_string())\n}\n","///|\npub using @cmd {type Cmd, type Command}\n\n///|\npub using @cmd {none, batch, task, perform, attempt}\n\n///|\nusing @html {type Html}\n\n///|\n/// Start the application.\n/// \n/// - `model` is the state of your application.\n/// - `view` is a way to turn your model into HTML.\n/// - `update` a way to update your state based on messages.\n/// \n/// These three are the core of the TEA. Rabbit-TEA is highly unstable at this time, \n/// but it follows the same pattern as Elm. You can visit https://guide.elm-lang.org/ \n/// to get more intuition!\n/// \n/// To start the application with router, you can use the `application` function.\npub fn[Model, Message] new(\n  model~ : Model,\n  update~ : (Message, Model) -> (Cmd[Message], Model),\n  view~ : (Model) -> Html[Message],\n  mount? : String = \"app\",\n) -> App[Message, Model] {\n  @dom.document()\n  .get_element_by_id(mount)\n  .unwrap()\n  .set_inner_html(\"<div></div>\")\n  let mut sandbox = None\n  let mut curr_dom = @vdom.node(\"div\", [], [])\n  fn after_update(html : @html.Html[Message]) {\n    guard sandbox is Some(sandbox)\n    let new_dom = html.to_virtual_dom()\n    new_dom.patch(curr_dom, sandbox, mount~)\n    curr_dom = new_dom\n  }\n\n  let sb = @browser.Sandbox::new(model, update, view, after_update~)\n  sandbox = Some(sb)\n  sb.refresh()\n  App::{ sandbox: sb }\n}\n\n///|\n/// Start the application.\n/// \n/// - `model` is the state of your application.\n/// - `view` is a way to turn your model into HTML.\n/// - `update` a way to update your state based on messages.\n/// \n/// These three are the core of the TEA. Rabbit-TEA is highly unstable at this time, \n/// but it follows the same pattern as Elm. You can visit https://guide.elm-lang.org/ \n/// to get more intuition!\n/// \n/// To start the application with router, you can use the `application` function.\npub fn[Model, Message] startup(\n  model~ : Model,\n  update~ : (Message, Model) -> (Cmd[Message], Model),\n  view~ : (Model) -> Html[Message],\n  mount? : String = \"app\",\n) -> Unit {\n  ignore(new(model~, update~, view~, mount~))\n}\n\n///|\nstruct App[Msg, Model] {\n  sandbox : @browser.Sandbox[Msg, Model, @html.Html[Msg]]\n}\n\n///|\n/// run the update function of the application.\npub fn[Msg, Model] App::dispatch(self : App[Msg, Model], msg : Msg) -> Unit {\n  self.sandbox.update(msg)\n}\n\n///|\npub fn[Model, Msg] new_with_route(\n  initialize~ : (@url.Url) -> (Cmd[Msg], Model),\n  update~ : (Msg, Model) -> (Cmd[Msg], Model),\n  view~ : (Model) -> @html.Html[Msg],\n  url_changed? : (@url.Url) -> Msg,\n  url_request? : (@url.UrlRequest) -> Msg,\n  mount? : String = \"app\",\n) -> App[Msg, Model] {\n  @dom.document()\n  .get_element_by_id(mount)\n  .unwrap()\n  .set_inner_html(\"<div></div>\")\n  let mut sandbox_ref = None\n  let mut curr_dom = @vdom.node(\"div\", [], [])\n  fn after_update(html : @html.Html[Msg]) {\n    guard sandbox_ref is Some(sandbox)\n    let new_dom = html.to_virtual_dom()\n    new_dom.patch(curr_dom, sandbox, mount~)\n    curr_dom = new_dom\n  }\n\n  guard (try? @url.parse(@dom.window().current_url())) is Ok(url)\n  let (cmd, model) = initialize(url)\n  let sandbox = @browser.Sandbox::new(\n    model,\n    update,\n    view,\n    after_update~,\n    url_request?,\n    url_changed?,\n  )\n  sandbox_ref = Some(sandbox)\n  sandbox..launch(cmd)..refresh()\n  App::{ sandbox, }\n}\n\n///|\n/// Start the application with initial URL. \n/// \n/// - `url_changed` is a message that will be passed when the URL is changed by the navigation API in the `@browser` package.\n/// - `url_request` is a message that will be passed when an `<a>` tag is clicked.\n/// - `initialize` will be called when the application is started. \n/// \npub fn[Model, Msg] application(\n  initialize~ : (@url.Url) -> (Cmd[Msg], Model),\n  update~ : (Msg, Model) -> (Cmd[Msg], Model),\n  view~ : (Model) -> @html.Html[Msg],\n  url_changed? : (@url.Url) -> Msg,\n  url_request? : (@url.UrlRequest) -> Msg,\n  mount? : String = \"app\",\n) -> Unit {\n  ignore(\n    new_with_route(\n      initialize~,\n      update~,\n      view~,\n      url_changed?,\n      url_request?,\n      mount~,\n    ),\n  )\n}\n","///|\nusing @tea {none}\n\n///|\nusing @tea {type Cmd}\n\n///|\nusing @html {type Html, div, h1, p, text, input}\n\n///|\nstruct Model {\n  value : String\n  is_focused : Bool\n  last_event : String\n}\n\n///|\nenum Msg {\n  Init\n  InputChanged(String)\n  Focused\n  Blurred\n}\n\n///|\nfn[M] bind_focus_blur_listener(\n  id : String,\n  focused_msg : M,\n  blurred_msg : M,\n) -> Cmd[M] {\n  Cmd(events => {\n    install_focus_blur(id, fn() { events.trigger_update(focused_msg) }, fn() {\n      events.trigger_update(blurred_msg)\n    })\n  })\n}\n\n///|\nextern \"js\" fn install_focus_blur(\n  id : String,\n  on_focus : () -> Unit,\n  on_blur : () -> Unit,\n) =\n  #|(id, onFocus, onBlur) => {\n  #|  const el = document.getElementById(id);\n  #|  if (!el) return;\n  #|  el.addEventListener('focus', onFocus);\n  #|  el.addEventListener('blur', onBlur);\n  #|}\n\n///|\nfn update(msg : Msg, model : Model) -> (Cmd[Msg], Model) {\n  match msg {\n    Init =>\n      (\n        bind_focus_blur_listener(\"tracked-input\", Msg::Focused, Msg::Blurred),\n        model,\n      )\n    InputChanged(value) => (none(), { ..model, value, last_event: \"input\" })\n    Focused => (none(), { ..model, is_focused: true, last_event: \"focus\" })\n    Blurred => (none(), { ..model, is_focused: false, last_event: \"blur\" })\n  }\n}\n\n///|\nfn view(model : Model) -> Html[Msg] {\n  div(\n    class=\"mx-auto mt-16 max-w-xl space-y-4 rounded-lg border border-slate-300 bg-white p-6\",\n    [\n      h1(class=\"text-2xl font-bold text-slate-900\", [\n        text(\"Rabbit-TEA focus/blur sample\"),\n      ]),\n      p(class=\"text-slate-600\", [\n        text(\"Type in the input and switch focus to see events.\"),\n      ]),\n      input(\n        id=\"tracked-input\",\n        class=\"w-full rounded border border-slate-300 px-3 py-2\",\n        placeholder=\"Focus and blur this input\",\n        value=model.value,\n        input=v => Msg::InputChanged(v),\n      ),\n      p(class=\"text-slate-800\", [\n        text(\n          \"focused: \\{model.is_focused.to_string()}, last_event: \\{model.last_event}, value: \\{model.value}\",\n        ),\n      ]),\n    ],\n  )\n}\n\n///|\nfn main {\n  let model = { value: \"\", is_focused: false, last_event: \"none\" }\n  let app = @tea.new(model~, update~, view~)\n  app.dispatch(Msg::Init)\n}\n"],"names":["_M0FP311moonbitlang4core7builtin12random__seed","Result$Err$0$","param0","Result$Ok$0$","Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError","Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure","Error$moonbitlang$47$core$47$builtin$46$CreatingViewError$46$IndexOutOfBounds","Error$moonbitlang$47$core$47$builtin$46$CreatingViewError$46$InvalidIndex","_M0FP311moonbitlang4core7builtin19int__to__string__js","Result$Err$1$","Result$Ok$1$","Result$Err$2$","Result$Ok$2$","Result$Err$3$","Result$Ok$3$","Result$Err$4$","Result$Ok$4$","Result$Err$5$","Result$Ok$5$","Result$Err$6$","Result$Ok$6$","_M0MP311moonbitlang4core7builtin7JSArray4push","_M0FP311moonbitlang4core7builtin23try__init__wasm__helper","_M0MP311moonbitlang4core7builtin7MyInt6411div__bigint","_M0MP311moonbitlang4core7builtin7MyInt647compare","Result$Err$7$","Result$Ok$7$","Result$Err$8$","Result$Ok$8$","Result$Err$9$","Result$Ok$9$","Result$Err$10$","Result$Ok$10$","$9223372036854775807L","$10L","$1L","$16L","$_9223372036854775808L","$0L","$64$Yoorkin$47$rabbit$45$tea$47$url$46$Protocol$Http","$64$Yoorkin$47$rabbit$45$tea$47$url$46$Protocol$Https","$64$Yoorkin$47$rabbit$45$tea$47$url$46$Protocol$Other","Result$Err$11$","Result$Ok$11$","_M0MP36rami3l8js_2dffi2js5Value8is__null","Option$None$12$","Option$Some$12$","Option$None$13$","Option$Some$13$","Option$None$14$","Option$Some$14$","Option$None$15$","Option$Some$15$","Option$None$16$","Option$Some$16$","Option$None$17$","Option$Some$17$","_M0MP37Yoorkin12rabbit_2dtea3dom6Window12current__url","_M0FP37Yoorkin12rabbit_2dtea3dom6window","_M0MP37Yoorkin12rabbit_2dtea3dom6Window17to__event__target","_M0FP37Yoorkin12rabbit_2dtea3dom18ffi__to__ui__event","_M0FP37Yoorkin12rabbit_2dtea3dom18ffi__append__child","_M0FP37Yoorkin12rabbit_2dtea3dom18ffi__remove__child","_M0FP37Yoorkin12rabbit_2dtea3dom19ffi__replace__child","_M0FP37Yoorkin12rabbit_2dtea3dom14insert__before","_M0FP37Yoorkin12rabbit_2dtea3dom15ffi__nth__child","_M0FP37Yoorkin12rabbit_2dtea3dom17ffi__count__child","_M0FP37Yoorkin12rabbit_2dtea3dom21ffi__to__mouse__event","_M0FP37Yoorkin12rabbit_2dtea3dom28ffi__mouse__event__ctrl__key","_M0FP37Yoorkin12rabbit_2dtea3dom28ffi__mouse__event__meta__key","_M0MP37Yoorkin12rabbit_2dtea3dom17HTMLSelectElement5value","_M0FP37Yoorkin12rabbit_2dtea3dom29ffi__to__html__input__element","_M0MP37Yoorkin12rabbit_2dtea3dom16HTMLInputElement5value","_M0FP37Yoorkin12rabbit_2dtea3dom22ffi__to__html__element","_M0FP37Yoorkin12rabbit_2dtea3dom30ffi__html__element__get__style","_M0FP37Yoorkin12rabbit_2dtea3dom12console__log","_M0FP37Yoorkin12rabbit_2dtea3dom25ffi__add__event__listener","_M0FP37Yoorkin12rabbit_2dtea3dom28ffi__remove__event__listener","_M0FP37Yoorkin12rabbit_2dtea3dom16ffi__to__element","_M0FP37Yoorkin12rabbit_2dtea3dom30ffi__to__html__select__element","_M0FP37Yoorkin12rabbit_2dtea3dom18ffi__event__target","_M0FP37Yoorkin12rabbit_2dtea3dom28ffi__event__prevent__default","_M0FP37Yoorkin12rabbit_2dtea3dom29ffi__event__stop__propagation","_M0FP37Yoorkin12rabbit_2dtea3dom28ffi__element__set__attribute","_M0FP37Yoorkin12rabbit_2dtea3dom31ffi__element__remove__attribute","_M0FP37Yoorkin12rabbit_2dtea3dom27ffi__element__set__property","_M0FP37Yoorkin12rabbit_2dtea3dom27ffi__element__get__property","_M0FP37Yoorkin12rabbit_2dtea3dom30ffi__element__remove__property","_M0FP37Yoorkin12rabbit_2dtea3dom30ffi__element__set__inner__html","_M0MP37Yoorkin12rabbit_2dtea3dom19CSSStyleDeclaration13set__property","_M0MP37Yoorkin12rabbit_2dtea3dom19CSSStyleDeclaration16remove__property","_M0FP37Yoorkin12rabbit_2dtea3dom8document","_M0MP37Yoorkin12rabbit_2dtea3dom8Document15create__element","_M0MP37Yoorkin12rabbit_2dtea3dom8Document27create__element__ns_2einner","_M0MP37Yoorkin12rabbit_2dtea3dom8Document18create__text__node","_M0MP37Yoorkin12rabbit_2dtea3dom8Document20get__element__by__id","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Node$18$","param1","param2","param3","param4","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$ExternalNode$18$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Node$Text$18$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrEvent$18$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrStyle$18$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrString$18$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrValue$AttrProperty$18$","$64$Yoorkin$47$rabbit$45$tea$47$url$46$UrlRequest$Internal","$64$Yoorkin$47$rabbit$45$tea$47$url$46$UrlRequest$External","Option$None$19$","Option$Some$19$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$AttrRemove$18$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$AttrAdd$18$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$StyleAdd$18$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$StyleRemove$18$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$PropertyAdd$18$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$PropertyRemove$18$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$EventRemove$18$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$AttrsUpdate$EventAdd$18$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Patch$Drop$18$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Patch$Remove$18$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Patch$Replace$18$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Patch$InsertBefore$18$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Patch$Append$18$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Patch$Update$18$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Update$UpdateNode$18$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Update$UpdateText$18$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$Normal$18$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$HandleEvent$18$","$64$Yoorkin$47$rabbit$45$tea$47$internal$47$vdom$46$Handler$Custom$18$","$64$Yoorkin$47$rabbit$45$tea$47$variant$46$Variant$Boolean","$64$Yoorkin$47$rabbit$45$tea$47$variant$46$Variant$Integer","$64$Yoorkin$47$rabbit$45$tea$47$variant$46$Variant$Floating","$64$Yoorkin$47$rabbit$45$tea$47$variant$46$Variant$String","_M0FP310typinglabs18rabbit__playground4main20install__focus__blur","Msg$Init","Msg$InputChanged","Msg$Focused","Msg$Blurred","Option$None$20$","Option$Some$20$","Option$None$21$","Option$Some$21$","_M0FP095_40moonbitlang_2fcore_2fbuiltin_2eStringBuilder_24as_24_40moonbitlang_2fcore_2fbuiltin_2eLogger","_M0FP311moonbitlang4core7builtin19wasm__helper__cache","_M0FP311moonbitlang4core7strconv14base__err__str","_M0FP311moonbitlang4core7strconv15range__err__str","_M0FP311moonbitlang4core7strconv16syntax__err__str","_M0FP311moonbitlang4core7strconv36parse__int64_2einner_2e_2abind_7c603","_M0FP311moonbitlang4core7builtin4seed","_M0FP311moonbitlang4core7builtin33brute__force__find_2econstr_2f340","_M0FP311moonbitlang4core7builtin43boyer__moore__horspool__find_2econstr_2f326","_M0FP311moonbitlang4core5abort5abortGuE","msg","_M0FP311moonbitlang4core5abort5abortGRP311moonbitlang4core7builtin5ArrayGRP47Yoorkin12rabbit_2dtea8internal4vdom4NodeGRP310typinglabs18rabbit__playground4main3MsgEEE","_M0FP311moonbitlang4core5abort5abortGRP311moonbitlang4core7builtin9ArrayViewGRP311moonbitlang4core6string10StringViewEE","_M0FP311moonbitlang4core5abort5abortGRP311moonbitlang4core6string10StringViewE","_M0FP311moonbitlang4core5abort5abortGOiE","_M0FP311moonbitlang4core5abort5abortGRP47Yoorkin12rabbit_2dtea8internal4vdom4NodeGRP310typinglabs18rabbit__playground4main3MsgEE","_M0FP311moonbitlang4core7builtin4rotl","x","r","_M0MP311moonbitlang4core7builtin6Hasher8consume4","self","input","_M0MP311moonbitlang4core7builtin6Hasher13combine__uint","value","_M0FP311moonbitlang4core7builtin5abortGuE","string","loc","_M0FP311moonbitlang4core7builtin5abortGRP311moonbitlang4core7builtin5ArrayGRP47Yoorkin12rabbit_2dtea8internal4vdom4NodeGRP310typinglabs18rabbit__playground4main3MsgEEE","_M0FP311moonbitlang4core7builtin5abortGRP311moonbitlang4core7builtin9ArrayViewGRP311moonbitlang4core6string10StringViewEE","_M0FP311moonbitlang4core7builtin5abortGRP311moonbitlang4core6string10StringViewE","_M0FP311moonbitlang4core7builtin5abortGOiE","_M0FP311moonbitlang4core7builtin5abortGRP47Yoorkin12rabbit_2dtea8internal4vdom4NodeGRP310typinglabs18rabbit__playground4main3MsgEE","_M0MP311moonbitlang4core5array10FixedArray12unsafe__blitGRP311moonbitlang4core7builtin17UnsafeMaybeUninitGRP37Yoorkin12rabbit_2dtea4html9AttributeGRP310typinglabs18rabbit__playground4main3MsgEEE","dst","dst_offset","src","src_offset","len","_tmp","i","_M0MP311moonbitlang4core7builtin18UninitializedArray12unsafe__blitGRP37Yoorkin12rabbit_2dtea4html9AttributeGRP310typinglabs18rabbit__playground4main3MsgEE","_M0FP311moonbitlang4core7builtin6ignoreGRP37Yoorkin12rabbit_2dtea3url3UrlE","t","_M0FP311moonbitlang4core7builtin6ignoreGRP37Yoorkin12rabbit_2dtea3url10UrlRequestE","_M0FP311moonbitlang4core7builtin6ignoreGRP37Yoorkin12rabbit_2dtea3cmd6EventsGRP310typinglabs18rabbit__playground4main3MsgEE","_M0MP311moonbitlang4core7builtin13StringBuilder11new_2einner","size_hint","_M0MP311moonbitlang4core7builtin13StringBuilder10to__string","_M0IP311moonbitlang4core7builtin13StringBuilderP311moonbitlang4core7builtin6Logger11write__char","ch","*bind","_M0MP311moonbitlang4core6uint166UInt1622is__leading__surrogate","_M0MP311moonbitlang4core6uint166UInt1623is__trailing__surrogate","_M0FP311moonbitlang4core7builtin32code__point__of__surrogate__pair","leading","trailing","_M0MP311moonbitlang4core6uint166UInt1616unsafe__to__char","_M0MP311moonbitlang4core6string6String16unsafe__char__at","index","c1","c2","_M0MP311moonbitlang4core7builtin13SourceLocRepr5parse","repr","*data","*start","*end","*cursor","accept_state","match_end","match_tag_saver_0","match_tag_saver_1","match_tag_saver_2","match_tag_saver_3","match_tag_saver_4","tag_0","tag_1","tag_1_1","tag_1_2","tag_3","tag_2","tag_2_1","tag_4","next_char","dispatch_15","start_line","*try_err","*ok","*err","start_column","pkg","filename","end_line","end_column","_M0IP311moonbitlang4core7builtin13StringBuilderP311moonbitlang4core7builtin6Logger13write__string","str","_M0MP311moonbitlang4core7builtin7MyInt647to__int","_M0IP311moonbitlang4core6uint166UInt16P311moonbitlang4core7builtin2Eq5equal","that","_M0IP311moonbitlang4core6uint166UInt16P311moonbitlang4core7builtin2Eq10not__equal","_M0IP311moonbitlang4core6uint166UInt16P311moonbitlang4core7builtin7Compare7compare","_M0MP311moonbitlang4core7builtin7MyInt649from__int","_M0MP311moonbitlang4core3int3Int9to__int64","_M0MP311moonbitlang4core7builtin6Hasher7combineGsE","_M0IP016_24default__implP311moonbitlang4core7builtin2Eq10not__equalGRP37Yoorkin12rabbit_2dtea7variant7VariantE","y","_M0IP016_24default__implP311moonbitlang4core7builtin2Eq10not__equalGsE","_M0IP016_24default__implP311moonbitlang4core7builtin2Eq10not__equalGRP311moonbitlang4core6string10StringViewE","_M0IP016_24default__implP311moonbitlang4core7builtin7Compare6op__ltGlE","_M0IP016_24default__implP311moonbitlang4core7builtin7Compare6op__gtGlE","_M0IP016_24default__implP311moonbitlang4core7builtin7Compare6op__leGlE","_M0IP016_24default__implP311moonbitlang4core7builtin7Compare6op__leGkE","_M0IP016_24default__implP311moonbitlang4core7builtin7Compare6op__geGlE","_M0IP016_24default__implP311moonbitlang4core7builtin7Compare6op__geGkE","_M0MP311moonbitlang4core7builtin6Hasher9avalanche","acc","_M0MP311moonbitlang4core7builtin6Hasher8finalize","_M0MP311moonbitlang4core7builtin6Hasher11new_2einner","seed","_M0MP311moonbitlang4core7builtin6Hasher3new","seed.opt","*Some","_M0IP016_24default__implP311moonbitlang4core7builtin4Hash4hashGsE","h","_M0MP311moonbitlang4core6string6String11sub_2einner","start","end","_M0MP311moonbitlang4core6string6String3sub","start.opt","_M0IP016_24default__implP311moonbitlang4core7builtin6Logger16write__substringGRP311moonbitlang4core7builtin13StringBuilderE","_M0MP311moonbitlang4core6string10StringView4data","_M0MP311moonbitlang4core6string10StringView6length","_M0MP311moonbitlang4core6string10StringView13start__offset","_M0IP016_24default__implP311moonbitlang4core7builtin4Show10to__stringGbE","logger","_M0IP016_24default__implP311moonbitlang4core7builtin4Show10to__stringGRP311moonbitlang4core7builtin9SourceLocE","_M0IP016_24default__implP311moonbitlang4core7builtin4Show10to__stringGiE","_M0MP311moonbitlang4core7builtin4Iter4nextGRP311moonbitlang4core6string10StringViewE","*func","_M0MP311moonbitlang4core7builtin4Iter4nextGsE","_M0MP311moonbitlang4core7builtin4Iter4nextGUsRP47Yoorkin12rabbit_2dtea8internal4vdom9AttrValueGRP310typinglabs18rabbit__playground4main3MsgEEE","_M0MP311moonbitlang4core7builtin4Iter4nextGRP47Yoorkin12rabbit_2dtea8internal4vdom9AttributeGRP310typinglabs18rabbit__playground4main3MsgEE","_M0MP311moonbitlang4core7builtin4Iter4nextGcE","_M0MP311moonbitlang4core3int3Int18to__string_2einner","radix","_M0FP311moonbitlang4core7builtin4failGUOsORP311moonbitlang4core6string10StringViewEE","_M0FP311moonbitlang4core7builtin4failGUsOiEE","_M0FP311moonbitlang4core7builtin4failGURP311moonbitlang4core6string10StringViewsEE","_M0FP311moonbitlang4core7builtin4failGURP311moonbitlang4core6string10StringViewORP311moonbitlang4core6string10StringViewEE","_M0FP311moonbitlang4core7builtin4failGURP311moonbitlang4core6string10StringViewRP311moonbitlang4core6string10StringViewEE","_M0FP311moonbitlang4core7builtin4failGURP37Yoorkin12rabbit_2dtea3url8ProtocolRP311moonbitlang4core6string10StringViewEE","_M0MP311moonbitlang4core6string10StringView11unsafe__get","_M0MP311moonbitlang4core7builtin4Iter3newGRP311moonbitlang4core6string10StringViewE","f","_M0MP311moonbitlang4core7builtin4Iter3newGcE","_M0MP311moonbitlang4core7builtin4Iter3newGRP47Yoorkin12rabbit_2dtea8internal4vdom9AttributeGRP310typinglabs18rabbit__playground4main3MsgEE","_M0MP311moonbitlang4core7builtin4Iter3newGUsRP47Yoorkin12rabbit_2dtea8internal4vdom9AttrValueGRP310typinglabs18rabbit__playground4main3MsgEEE","_M0MP311moonbitlang4core6string10StringView12view_2einner","start_offset","end_offset","_M0IP311moonbitlang4core6string10StringViewP311moonbitlang4core7builtin4Show10to__string","_M0MP311moonbitlang4core6string10StringView4iter","_M0IP311moonbitlang4core6string10StringViewP311moonbitlang4core7builtin2Eq5equal","other","_M0MP311moonbitlang4core6string6String12view_2einner","_M0MP311moonbitlang4core5array9ArrayView6lengthGRP311moonbitlang4core6string10StringViewE","_M0MP311moonbitlang4core5array9ArrayView6lengthGRP47Yoorkin12rabbit_2dtea8internal4vdom4NodeGRP310typinglabs18rabbit__playground4main3MsgEE","_M0MP311moonbitlang4core5array9ArrayView6lengthGUsRP47Yoorkin12rabbit_2dtea8internal4vdom9AttrValueGRP310typinglabs18rabbit__playground4main3MsgEEE","_M0MP311moonbitlang4core5array9ArrayView6lengthGRP47Yoorkin12rabbit_2dtea8internal4vdom9AttributeGRP310typinglabs18rabbit__playground4main3MsgEE","_M0MP311moonbitlang4core5array9ArrayView6lengthGsE","_M0MP311moonbitlang4core6string6String24char__length__eq_2einner","count","_M0MP311moonbitlang4core6string6String24char__length__ge_2einner","_M0MP311moonbitlang4core6string6String31offset__of__nth__char__backward","n","char_count","utf16_offset","c","_M0MP311moonbitlang4core6string6String30offset__of__nth__char__forward","_M0MP311moonbitlang4core6string6String29offset__of__nth__char_2einner","_M0IP311moonbitlang4core7builtin13StringBuilderP311moonbitlang4core7builtin6Logger11write__view","_M0FP311moonbitlang4core7builtin28boyer__moore__horspool__find","haystack","needle","haystack_len","needle_len","skip_table","*end4308","*end4314","j","_M0FP311moonbitlang4core7builtin18brute__force__find","needle_first","forward_len","_M0MP311moonbitlang4core6string10StringView4find","_M0MP311moonbitlang4core5array5Array4pushGUsWRP37Yoorkin12rabbit_2dtea3dom5EventEuEE","_M0MP311moonbitlang4core5array5Array4pushGRP37Yoorkin12rabbit_2dtea4html9AttributeGRP310typinglabs18rabbit__playground4main3MsgEE","_M0MP311moonbitlang4core5array5Array4pushGRP47Yoorkin12rabbit_2dtea8internal4vdom11AttrsUpdateGRP310typinglabs18rabbit__playground4main3MsgEE","_M0MP311moonbitlang4core5array5Array4pushGRP311moonbitlang4core6string10StringViewE","_M0MP311moonbitlang4core5array5Array4pushGRP47Yoorkin12rabbit_2dtea8internal4vdom5PatchGRP310typinglabs18rabbit__playground4main3MsgEE","_M0MP311moonbitlang4core6string10StringView9is__empty","_M0MP311moonbitlang4core7builtin4Iter3mapGRP311moonbitlang4core6string10StringViewsE","*x","_M0MP311moonbitlang4core7builtin4Iter3mapGRP47Yoorkin12rabbit_2dtea8internal4vdom9AttributeGRP310typinglabs18rabbit__playground4main3MsgEUsRP47Yoorkin12rabbit_2dtea8internal4vdom9AttrValueGRP310typinglabs18rabbit__playground4main3MsgEEE","_M0MP311moonbitlang4core7builtin4Iter3mapGcRP311moonbitlang4core6string10StringViewE","_M0IP311moonbitlang4core4char4CharP311moonbitlang4core7builtin4Show10to__string","_M0MP311moonbitlang4core6string10StringView5split","sep","sep_len","remaining","*view","_M0MP311moonbitlang4core6string6String5split","_M0MP311moonbitlang4core7builtin4Iter9to__arrayGRP311moonbitlang4core6string10StringViewE","result","_M0IP311moonbitlang4core6string6StringP311moonbitlang4core7builtin12ToStringView16to__string__view","_M0IP311moonbitlang4core4bool4BoolP311moonbitlang4core7builtin4Show6output","_M0IP311moonbitlang4core3int3IntP311moonbitlang4core7builtin4Show6output","_M0IP311moonbitlang4core6string6StringP311moonbitlang4core7builtin4Show10to__string","_M0MP311moonbitlang4core5array9ArrayView4iterGRP311moonbitlang4core6string10StringViewE","elem","_M0MP311moonbitlang4core5array9ArrayView4iterGRP47Yoorkin12rabbit_2dtea8internal4vdom9AttributeGRP310typinglabs18rabbit__playground4main3MsgEE","_M0MP311moonbitlang4core5array5Array4iterGRP47Yoorkin12rabbit_2dtea8internal4vdom9AttributeGRP310typinglabs18rabbit__playground4main3MsgEE","_M0MP311moonbitlang4core5array9ArrayView2atGRP47Yoorkin12rabbit_2dtea8internal4vdom4NodeGRP310typinglabs18rabbit__playground4main3MsgEE","_M0IP311moonbitlang4core6option6OptionP311moonbitlang4core7builtin2Eq5equalGiE","*y","_M0MP311moonbitlang4core6option6Option6unwrapGRP37Yoorkin12rabbit_2dtea3dom7ElementE","_M0MP311moonbitlang4core6option6Option6unwrapGRP37Yoorkin12rabbit_2dtea3dom11HTMLElementE","_M0MP311moonbitlang4core6option6Option6unwrapGRP37Yoorkin12rabbit_2dtea3dom10MouseEventE","_M0MP311moonbitlang4core6option6Option6unwrapGRP37Yoorkin12rabbit_2dtea3dom7UIEventE","_M0MP311moonbitlang4core6option6Option6unwrapGRP37Yoorkin12rabbit_2dtea3cmd6EventsGRP310typinglabs18rabbit__playground4main3MsgEE","_M0MP311moonbitlang4core6option6Option6unwrapGRP47Yoorkin12rabbit_2dtea8internal4vdom9AttrValueGRP310typinglabs18rabbit__playground4main3MsgEE","_M0MP311moonbitlang4core6option6Option6unwrapGRP37Yoorkin12rabbit_2dtea3dom16HTMLInputElementE","_M0MP311moonbitlang4core6option6Option6unwrapGRP311moonbitlang4core7builtin5EntryGsRP47Yoorkin12rabbit_2dtea8internal4vdom9AttrValueGRP310typinglabs18rabbit__playground4main3MsgEEE","_M0FP311moonbitlang4core7builtin21calc__grow__threshold","capacity","_M0MP311moonbitlang4core3int3Int20next__power__of__two","_M0MP311moonbitlang4core7builtin3Map11new_2einnerGsRP47Yoorkin12rabbit_2dtea8internal4vdom9AttrValueGRP310typinglabs18rabbit__playground4main3MsgEE","_M0MP311moonbitlang4core7builtin3Map20add__entry__to__tailGsRP47Yoorkin12rabbit_2dtea8internal4vdom9AttrValueGRP310typinglabs18rabbit__playground4main3MsgEE","idx","entry","_M0MP311moonbitlang4core7builtin3Map10set__entryGsRP47Yoorkin12rabbit_2dtea8internal4vdom9AttrValueGRP310typinglabs18rabbit__playground4main3MsgEE","new_idx","*next","_M0MP311moonbitlang4core7builtin3Map10push__awayGsRP47Yoorkin12rabbit_2dtea8internal4vdom9AttrValueGRP310typinglabs18rabbit__playground4main3MsgEE","psl","*curr_entry","_M0MP311moonbitlang4core7builtin3Map15set__with__hashGsRP47Yoorkin12rabbit_2dtea8internal4vdom9AttrValueGRP310typinglabs18rabbit__playground4main3MsgEE","key","hash","_M0MP311moonbitlang4core7builtin3Map4growGsRP47Yoorkin12rabbit_2dtea8internal4vdom9AttrValueGRP310typinglabs18rabbit__playground4main3MsgEE","old_head","new_capacity","*param","*key","*value","*hash","_M0MP311moonbitlang4core7builtin3Map3setGsRP47Yoorkin12rabbit_2dtea8internal4vdom9AttrValueGRP310typinglabs18rabbit__playground4main3MsgEE","_M0MP311moonbitlang4core7builtin3Map11from__arrayGsRP47Yoorkin12rabbit_2dtea8internal4vdom9AttrValueGRP310typinglabs18rabbit__playground4main3MsgEE","arr","length","m","*len","*i","e","_M0MP311moonbitlang4core7builtin3Map3getGsRP47Yoorkin12rabbit_2dtea8internal4vdom9AttrValueGRP310typinglabs18rabbit__playground4main3MsgEE","*entry","_M0MP311moonbitlang4core7builtin3Map8containsGsRP47Yoorkin12rabbit_2dtea8internal4vdom9AttrValueGRP310typinglabs18rabbit__playground4main3MsgEE","_M0MP311moonbitlang4core7builtin3Map4iterGsRP47Yoorkin12rabbit_2dtea8internal4vdom9AttrValueGRP310typinglabs18rabbit__playground4main3MsgEE","curr_entry","_M0MP311moonbitlang4core7builtin3Map5iter2GsRP47Yoorkin12rabbit_2dtea8internal4vdom9AttrValueGRP310typinglabs18rabbit__playground4main3MsgEE","_M0MP311moonbitlang4core7builtin3Map10from__iterGsRP47Yoorkin12rabbit_2dtea8internal4vdom9AttrValueGRP310typinglabs18rabbit__playground4main3MsgEE","iter","*k","*v","_M0MP311moonbitlang4core5array5Array3mapGRP37Yoorkin12rabbit_2dtea4html9AttributeGRP310typinglabs18rabbit__playground4main3MsgERP47Yoorkin12rabbit_2dtea8internal4vdom9AttributeGRP310typinglabs18rabbit__playground4main3MsgEE","v","_M0MP311moonbitlang4core5array5Array3mapGRP37Yoorkin12rabbit_2dtea4html4HtmlGRP310typinglabs18rabbit__playground4main3MsgERP47Yoorkin12rabbit_2dtea8internal4vdom4NodeGRP310typinglabs18rabbit__playground4main3MsgEE","_M0MP311moonbitlang4core7builtin4Iter4join","_M0MP311moonbitlang4core7builtin5Iter24nextGsRP47Yoorkin12rabbit_2dtea8internal4vdom9AttrValueGRP310typinglabs18rabbit__playground4main3MsgEE","_M0MP311moonbitlang4core6string6String20unsafe__charcode__at","_M0MP311moonbitlang4core7builtin7MyInt6411add__hi__lo","bhi","blo","*ahi","*alo","lo","s","as_","bs","hi","_M0IP311moonbitlang4core7builtin7MyInt64P311moonbitlang4core7builtin3Add3add","_M0IP311moonbitlang4core7builtin7MyInt64P311moonbitlang4core7builtin3Sub3sub","_M0IP311moonbitlang4core7builtin7MyInt64P311moonbitlang4core7builtin3Mul3mul","*bhi","*blo","ahi","alo","a48","a32","a16","a00","b48","b32","b16","b00","c00","c16","c32","c48","_M0FP311moonbitlang4core7builtin29try__get__int64__wasm__helper","_M0IP311moonbitlang4core7builtin7MyInt64P311moonbitlang4core7builtin3Div3div","*exports","_M0IP311moonbitlang4core5int645Int64P311moonbitlang4core7builtin3Add3add","_M0IP311moonbitlang4core5int645Int64P311moonbitlang4core7builtin3Sub3sub","_M0IP311moonbitlang4core5int645Int64P311moonbitlang4core7builtin3Mul3mul","_M0IP311moonbitlang4core5int645Int64P311moonbitlang4core7builtin3Div3div","_M0IP311moonbitlang4core5int645Int64P311moonbitlang4core7builtin7Compare7compare","_M0MP311moonbitlang4core5int645Int647to__int","_M0MP311moonbitlang4core7builtin6Hasher15combine__string","*end2501","_M0IP311moonbitlang4core6string6StringP311moonbitlang4core7builtin4Hash13hash__combine","hasher","_M0IP311moonbitlang4core7builtin13SourceLocReprP311moonbitlang4core7builtin4Show6output","package_name","module_name","*module_name","*package_name","*pkg_name","_M0IP311moonbitlang4core7builtin9SourceLocP311moonbitlang4core7builtin4Show6output","_M0MP311moonbitlang4core5array5Array12view_2einnerGRP311moonbitlang4core6string10StringViewE","_M0MP311moonbitlang4core5array5Array5makeiGRP47Yoorkin12rabbit_2dtea8internal4vdom4NodeGRP310typinglabs18rabbit__playground4main3MsgEE","array","_M0MP311moonbitlang4core5array9ArrayView3mapGRP47Yoorkin12rabbit_2dtea8internal4vdom4NodeGRP310typinglabs18rabbit__playground4main3MsgERP47Yoorkin12rabbit_2dtea8internal4vdom4NodeGRP310typinglabs18rabbit__playground4main3MsgEE","_M0MP311moonbitlang4core5array9ArrayView4joinGsE","separator","*hd","hd","buf","_M0IP311moonbitlang4core5array5ArrayP311moonbitlang4core7builtin3Add3addGRP37Yoorkin12rabbit_2dtea4html9AttributeGRP310typinglabs18rabbit__playground4main3MsgEE","_M0MP311moonbitlang4core5array5Array4eachGRP47Yoorkin12rabbit_2dtea8internal4vdom9AttributeGRP310typinglabs18rabbit__playground4main3MsgEE","_M0MP311moonbitlang4core5array5Array4joinGsE","_M0FP311moonbitlang4core7strconv9base__errGUiRP311moonbitlang4core6string10StringViewbEE","_M0FP311moonbitlang4core7strconv25check__and__consume__base","view","base","rest","_M0FP311moonbitlang4core7strconv10range__errGuE","_M0FP311moonbitlang4core7strconv10range__errGlE","_M0FP311moonbitlang4core7strconv11syntax__errGiE","_M0FP311moonbitlang4core7strconv11syntax__errGlE","_M0FP311moonbitlang4core7strconv19overflow__threshold","neg","_M0FP311moonbitlang4core7strconv20parse__int64_2einner","*neg","*rest","*num_base","*allow_underscore","overflow_threshold","has_digit","*param_0","*param_1","*param_2","d","next_acc","_M0FP311moonbitlang4core7strconv18parse__int_2einner","_M0IP37Yoorkin12rabbit_2dtea3url8ProtocolP311moonbitlang4core7builtin2Eq5equal","*x_111","*x_112","*x0_113","*y0_114","*Other","**x0_113","**y0_114","_M0FP37Yoorkin12rabbit_2dtea3url5parse","url","protocol","remain","*remain","*protocol","mid","query_and_fragment","*mid","*query_and_fragment","mid_part","fragment1","fragment","*fragment","*mid_part","*fragment1","path","paths","*path","host","port","*host","*port","number","query","fragment2","*query","*fragment2","f1","f2","*f","*f1","*f2","_M0MP36rami3l8js_2dffi2js8Nullable8is__nullGRP37Yoorkin12rabbit_2dtea3dom7ElementE","_M0MP36rami3l8js_2dffi2js8Nullable6unwrapGRP37Yoorkin12rabbit_2dtea3dom7ElementE","_M0MP36rami3l8js_2dffi2js8Nullable10to__optionGRP37Yoorkin12rabbit_2dtea3dom7ElementE","_M0MP36rami3l8js_2dffi2js8Nullable10to__optionGRP37Yoorkin12rabbit_2dtea3dom11HTMLElementE","_M0MP36rami3l8js_2dffi2js8Nullable10to__optionGRP37Yoorkin12rabbit_2dtea3dom10MouseEventE","_M0MP36rami3l8js_2dffi2js8Nullable10to__optionGRP37Yoorkin12rabbit_2dtea3dom7UIEventE","_M0MP36rami3l8js_2dffi2js8Nullable10to__optionGRP37Yoorkin12rabbit_2dtea3dom16HTMLInputElementE","_M0MP36rami3l8js_2dffi2js8Nullable10to__optionGRP37Yoorkin12rabbit_2dtea3dom17HTMLSelectElementE","_M0MP37Yoorkin12rabbit_2dtea3cmd6Events3newGRP310typinglabs18rabbit__playground4main3MsgE","on_url_changed","on_url_request","on_update","_M0MP37Yoorkin12rabbit_2dtea3cmd6Events15trigger__updateGRP310typinglabs18rabbit__playground4main3MsgE","_M0FP37Yoorkin12rabbit_2dtea3cmd4noneGRP310typinglabs18rabbit__playground4main3MsgE","_M0FP37Yoorkin12rabbit_2dtea3dom12js__identityGRP37Yoorkin12rabbit_2dtea3dom7ElementRP36rami3l8js_2dffi2js5ValueE","a","_M0FP37Yoorkin12rabbit_2dtea3dom12js__identityGRP37Yoorkin12rabbit_2dtea3dom4NodeRP36rami3l8js_2dffi2js5ValueE","_M0FP37Yoorkin12rabbit_2dtea3dom12js__identityGRP37Yoorkin12rabbit_2dtea3dom7ElementRP37Yoorkin12rabbit_2dtea3dom4NodeE","_M0FP37Yoorkin12rabbit_2dtea3dom12js__identityGRP37Yoorkin12rabbit_2dtea3dom11EventTargetRP36rami3l8js_2dffi2js5ValueE","_M0FP37Yoorkin12rabbit_2dtea3dom12js__identityGRP37Yoorkin12rabbit_2dtea3dom7ElementRP37Yoorkin12rabbit_2dtea3dom11EventTargetE","_M0FP37Yoorkin12rabbit_2dtea3dom12js__identityGRP37Yoorkin12rabbit_2dtea3dom5EventRP37Yoorkin12rabbit_2dtea3dom5EventE","_M0FP37Yoorkin12rabbit_2dtea3dom12js__identityGRP37Yoorkin12rabbit_2dtea3dom11HTMLElementRP37Yoorkin12rabbit_2dtea3dom11HTMLElementE","_M0FP37Yoorkin12rabbit_2dtea3dom12js__identityGRP37Yoorkin12rabbit_2dtea3dom7UIEventRP36rami3l8js_2dffi2js5ValueE","_M0FP37Yoorkin12rabbit_2dtea3dom12js__identityGRP37Yoorkin12rabbit_2dtea3dom5EventRP36rami3l8js_2dffi2js5ValueE","_M0FP37Yoorkin12rabbit_2dtea3dom12js__identityGRP37Yoorkin12rabbit_2dtea3dom10MouseEventRP36rami3l8js_2dffi2js5ValueE","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom6IsNode8as__nodeGRP37Yoorkin12rabbit_2dtea3dom7ElementE","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom6IsNode13append__childGRP37Yoorkin12rabbit_2dtea3dom4NodeE","child","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom6IsNode13append__childGRP37Yoorkin12rabbit_2dtea3dom7ElementE","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom6IsNode13remove__childGRP37Yoorkin12rabbit_2dtea3dom4NodeE","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom6IsNode14replace__childGRP37Yoorkin12rabbit_2dtea3dom4NodeE","new","old","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom6IsNode14insert__beforeGRP37Yoorkin12rabbit_2dtea3dom4NodeE","before","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom6IsNode10get__childGRP37Yoorkin12rabbit_2dtea3dom4NodeE","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom6IsNode17get__child__countGRP37Yoorkin12rabbit_2dtea3dom4NodeE","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom12IsMouseEvent14get__ctrl__keyGRP37Yoorkin12rabbit_2dtea3dom10MouseEventE","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom12IsMouseEvent14get__meta__keyGRP37Yoorkin12rabbit_2dtea3dom10MouseEventE","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom13IsHtmlElement17as__html__elementGRP37Yoorkin12rabbit_2dtea3dom11HTMLElementE","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom13IsHtmlElement10get__styleGRP37Yoorkin12rabbit_2dtea3dom11HTMLElementE","_M0FP37Yoorkin12rabbit_2dtea3dom27default__exception__handlerGRP37Yoorkin12rabbit_2dtea3dom12DOMExceptionRP37Yoorkin12rabbit_2dtea3dom7ElementE","exception","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom13IsEventTarget20add__event__listenerGRP37Yoorkin12rabbit_2dtea3dom7ElementE","type_","callback","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom13IsEventTarget20add__event__listenerGRP37Yoorkin12rabbit_2dtea3dom11EventTargetE","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom13IsEventTarget23remove__event__listenerGRP37Yoorkin12rabbit_2dtea3dom11EventTargetE","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom13IsEventTarget17as__event__targetGRP37Yoorkin12rabbit_2dtea3dom7ElementE","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom13IsEventTarget11to__elementGRP37Yoorkin12rabbit_2dtea3dom4NodeE","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom13IsEventTarget17to__html__elementGRP37Yoorkin12rabbit_2dtea3dom7ElementE","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom13IsEventTarget24to__html__input__elementGRP37Yoorkin12rabbit_2dtea3dom11EventTargetE","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom13IsEventTarget25to__html__select__elementGRP37Yoorkin12rabbit_2dtea3dom11EventTargetE","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom7IsEvent6targetGRP37Yoorkin12rabbit_2dtea3dom5EventE","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom7IsEvent16prevent__defaultGRP37Yoorkin12rabbit_2dtea3dom5EventE","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom7IsEvent17stop__propagationGRP37Yoorkin12rabbit_2dtea3dom5EventE","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom7IsEvent9as__eventGRP37Yoorkin12rabbit_2dtea3dom5EventE","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom7IsEvent13to__ui__eventGRP37Yoorkin12rabbit_2dtea3dom5EventE","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom7IsEvent16to__mouse__eventGRP37Yoorkin12rabbit_2dtea3dom7UIEventE","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom7IsEvent16to__mouse__eventGRP37Yoorkin12rabbit_2dtea3dom5EventE","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom9IsElement14set__attributeGRP37Yoorkin12rabbit_2dtea3dom7ElementE","attr","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom9IsElement17remove__attributeGRP37Yoorkin12rabbit_2dtea3dom7ElementE","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom9IsElement13set__propertyGRP37Yoorkin12rabbit_2dtea3dom7ElementE","prop","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom9IsElement13get__propertyGRP37Yoorkin12rabbit_2dtea3dom7ElementE","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom9IsElement16remove__propertyGRP37Yoorkin12rabbit_2dtea3dom7ElementE","_M0IP016_24default__implP37Yoorkin12rabbit_2dtea3dom9IsElement16set__inner__htmlGRP37Yoorkin12rabbit_2dtea3dom7ElementE","html","_M0MP37Yoorkin12rabbit_2dtea3dom8Document19create__element__ns","namespace_uri","qualified_name","on_namespace_error.opt","on_invalid_character_error.opt","on_namespace_error","on_invalid_character_error","_M0MP47Yoorkin12rabbit_2dtea8internal7browser7Sandbox21get__on__url__requestGRP310typinglabs18rabbit__playground4main3MsgRP310typinglabs18rabbit__playground4main5ModelRP37Yoorkin12rabbit_2dtea4html4HtmlGRP310typinglabs18rabbit__playground4main3MsgEE","_M0MP47Yoorkin12rabbit_2dtea8internal7browser7Sandbox6launchGRP310typinglabs18rabbit__playground4main3MsgRP310typinglabs18rabbit__playground4main5ModelRP37Yoorkin12rabbit_2dtea4html4HtmlGRP310typinglabs18rabbit__playground4main3MsgEE","cmd","_M0MP47Yoorkin12rabbit_2dtea8internal7browser7Sandbox6updateGRP310typinglabs18rabbit__playground4main3MsgRP310typinglabs18rabbit__playground4main5ModelRP37Yoorkin12rabbit_2dtea4html4HtmlGRP310typinglabs18rabbit__playground4main3MsgEE","message","model","*cmd","*model","_M0MP47Yoorkin12rabbit_2dtea8internal7browser7Sandbox7refreshGRP310typinglabs18rabbit__playground4main3MsgRP310typinglabs18rabbit__playground4main5ModelRP37Yoorkin12rabbit_2dtea4html4HtmlGRP310typinglabs18rabbit__playground4main3MsgEE","_M0MP47Yoorkin12rabbit_2dtea8internal7browser7Sandbox3newGRP310typinglabs18rabbit__playground4main5ModelRP310typinglabs18rabbit__playground4main3MsgRP37Yoorkin12rabbit_2dtea4html4HtmlGRP310typinglabs18rabbit__playground4main3MsgEE","update","after_update","url_changed","url_request","sandbox","*discard_","*Ok","*url","*hole18","_M0IP37Yoorkin12rabbit_2dtea7variant7VariantP311moonbitlang4core7builtin2Eq5equal","*x_33","*x_34","*x0_41","*y0_42","*x0_39","*y0_40","*x0_37","*y0_38","*x0_35","*y0_36","*Boolean","**x0_35","**y0_36","*Integer","**x0_37","**y0_38","*Floating","**x0_39","**y0_40","*String","**x0_41","**y0_42","_M0FP47Yoorkin12rabbit_2dtea8internal4vdom4nodeGRP310typinglabs18rabbit__playground4main3MsgE","tag","attrs","children","_M0FP47Yoorkin12rabbit_2dtea8internal4vdom4textGRP310typinglabs18rabbit__playground4main3MsgE","_M0FP47Yoorkin12rabbit_2dtea8internal4vdom14is__same__typeGRP310typinglabs18rabbit__playground4main3MsgE","_M0MP47Yoorkin12rabbit_2dtea8internal4vdom9Attribute5innerGRP310typinglabs18rabbit__playground4main3MsgE","_M0FP47Yoorkin12rabbit_2dtea8internal4vdom2onGRP310typinglabs18rabbit__playground4main3MsgE","event","handler","_M0FP47Yoorkin12rabbit_2dtea8internal4vdom9attributeGRP310typinglabs18rabbit__playground4main3MsgE","_M0FP47Yoorkin12rabbit_2dtea8internal4vdom8propertyGRP310typinglabs18rabbit__playground4main3MsgE","_M0FP47Yoorkin12rabbit_2dtea8internal4vdom22variant__to__js__value","_M0MP47Yoorkin12rabbit_2dtea8internal4vdom4Node8to__nodeGRP310typinglabs18rabbit__playground4main3MsgRP310typinglabs18rabbit__playground4main5ModelRP37Yoorkin12rabbit_2dtea4html4HtmlGRP310typinglabs18rabbit__playground4main3MsgEE","attach_attrs","element","generated_listeners","*event","*AttrEvent","*handler","*AttrString","*AttrStyle","*AttrProperty","listener","stop_propagation","prevent_default","*Normal","*msg","*HandleEvent","*Custom","*stop_propagation","*prevent_default","width","node","height","listeners","*Node","*tag","*attrs","*children","*listeners","*namespace_uri","*ExternalNode","*node","*width","*height","*Text","ns","*url_request","*ns","mouse_event","href","curr","*curr","next","request","*arr","xs","*xs","*self","_M0FP47Yoorkin12rabbit_2dtea8internal4vdom11attrs__diffGRP310typinglabs18rabbit__playground4main3MsgE","old_map","new_map","*it","value_new","*value_new","_M0FP47Yoorkin12rabbit_2dtea8internal4vdom8do__diffGRP310typinglabs18rabbit__playground4main3MsgE","children_old","children_new","_M0FP47Yoorkin12rabbit_2dtea8internal4vdom18diff__without__keyGRP310typinglabs18rabbit__playground4main3MsgE","aux","ys","patches","tl1","tl2","l","tl","value_a","value_b","taga","xattrs","yattrs","tagb","new_listeners","*taga","*xattrs","*tagb","*yattrs","*new_listeners","*value_a","*value_b","attrs_patches","childs_patches","_M0FP47Yoorkin12rabbit_2dtea8internal4vdom4diffGRP310typinglabs18rabbit__playground4main3MsgE","root_old","root_new","attrs_old","*attrs_old","attrs_new","*attrs_new","_M0MP47Yoorkin12rabbit_2dtea8internal4vdom4Node5patchGRP310typinglabs18rabbit__playground4main3MsgRP310typinglabs18rabbit__playground4main5ModelRP37Yoorkin12rabbit_2dtea4html4HtmlGRP310typinglabs18rabbit__playground4main3MsgEE","mount","current","nodes","*Drop","*index","*length","*Remove","*Replace","*InsertBefore","*Append","*nodes","*Update","*update","*start79","*end80","*UpdateNode","*attrs_patches","*childs_patches","*UpdateText","patch","*AttrRemove","*AttrAdd","*StyleAdd","*StyleRemove","*PropertyAdd","*PropertyRemove","*EventRemove","*listener","*EventAdd","text_node","root","_M0FP37Yoorkin12rabbit_2dtea4html4nodeGRP310typinglabs18rabbit__playground4main3MsgE","attributes","_M0MP37Yoorkin12rabbit_2dtea4html4Html16to__virtual__domGRP310typinglabs18rabbit__playground4main3MsgE","_M0FP37Yoorkin12rabbit_2dtea4html9attributeGRP310typinglabs18rabbit__playground4main3MsgE","_M0FP37Yoorkin12rabbit_2dtea4html20common__node_2einnerGRP310typinglabs18rabbit__playground4main3MsgE","style","id","class","*class","*id","_M0FP37Yoorkin12rabbit_2dtea4html9on__mouseGRP310typinglabs18rabbit__playground4main3MsgE","_M0FP37Yoorkin12rabbit_2dtea4html9on__clickGRP310typinglabs18rabbit__playground4main3MsgE","_M0FP37Yoorkin12rabbit_2dtea4html10h1_2einnerGRP310typinglabs18rabbit__playground4main3MsgE","_M0FP37Yoorkin12rabbit_2dtea4html2h1GRP310typinglabs18rabbit__playground4main3MsgE","style.opt","_M0FP37Yoorkin12rabbit_2dtea4html11div_2einnerGRP310typinglabs18rabbit__playground4main3MsgE","click","*click","_M0FP37Yoorkin12rabbit_2dtea4html3divGRP310typinglabs18rabbit__playground4main3MsgE","_M0FP37Yoorkin12rabbit_2dtea4html9p_2einnerGRP310typinglabs18rabbit__playground4main3MsgE","_M0FP37Yoorkin12rabbit_2dtea4html1pGRP310typinglabs18rabbit__playground4main3MsgE","_M0FP37Yoorkin12rabbit_2dtea4html4textGRP310typinglabs18rabbit__playground4main3MsgE","_M0FP37Yoorkin12rabbit_2dtea4html10on__changeGRP310typinglabs18rabbit__playground4main3MsgE","target","_M0FP37Yoorkin12rabbit_2dtea4html9on__inputGRP310typinglabs18rabbit__playground4main3MsgE","_M0FP37Yoorkin12rabbit_2dtea4html8propertyGRP310typinglabs18rabbit__playground4main3MsgE","_M0FP37Yoorkin12rabbit_2dtea4html13input_2einnerGRP310typinglabs18rabbit__playground4main3MsgE","input_type","name","checked","read_only","multiple","accept","placeholder","auto_complete","max","min","step","maxlength","minlength","pattern","size","change","*name","*checked","*read_only","*multiple","*accept","*max","*min","*step","*maxlength","*minlength","*pattern","*size","*placeholder","to_msg","*to_msg","_M0FP37Yoorkin12rabbit_2dtea4html5inputGRP310typinglabs18rabbit__playground4main3MsgE","input_type.opt","children.opt","_M0FP27Yoorkin12rabbit_2dtea11new_2einnerGRP310typinglabs18rabbit__playground4main5ModelRP310typinglabs18rabbit__playground4main3MsgE","curr_dom","*sandbox","new_dom","sb","_M0MP27Yoorkin12rabbit_2dtea3App8dispatchGRP310typinglabs18rabbit__playground4main3MsgRP310typinglabs18rabbit__playground4main5ModelE","_M0FP310typinglabs18rabbit__playground4main27bind__focus__blur__listenerGRP310typinglabs18rabbit__playground4main3MsgE","focused_msg","blurred_msg","events","_M0FP310typinglabs18rabbit__playground4main6update","*InputChanged","_M0FP310typinglabs18rabbit__playground4main4view","app"],"mappings":"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"}